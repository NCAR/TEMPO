var tipuesearch = {"pages":[{"title":" TEMPO Microphysics ","text":"TEMPO Microphysics Developer Info Anders A. Jensen","tags":"home","url":"index.html"},{"title":"MLdata – TEMPO Microphysics ","text":"type, public :: MLdata Components Type Visibility Attributes Name Initial integer, public :: input_size integer, public :: output_size integer, public :: node_size real, public, allocatable, dimension(:) :: transform_mean real, public, allocatable, dimension(:) :: transform_var real, public, allocatable, dimension(:,:) :: weights00 real, public, allocatable, dimension(:) :: bias00 real, public, allocatable, dimension(:,:) :: weights01 real, public, allocatable, dimension(:) :: bias01","tags":"","url":"type/mldata.html"},{"title":"ty_tempo_init_cfgs – TEMPO Microphysics ","text":"type, public :: ty_tempo_init_cfgs Components Type Visibility Attributes Name Initial logical, public :: aerosolaware_flag = .true. flag to run aerosol-aware microphysics logical, public :: hailaware_flag = .true. flag to run hail-aware microphysics logical, public :: restart_flag = .false. flag for restart or DA cycling character(len=4), public :: model_flag flag for model","tags":"","url":"type/ty_tempo_init_cfgs.html"},{"title":"ty_tempo_driver_cfgs – TEMPO Microphysics ","text":"type, public :: ty_tempo_driver_cfgs Components Type Visibility Attributes Name Initial logical, public :: semi_sedi = .false. flag for semi-lagrangian sedimentation","tags":"","url":"type/ty_tempo_driver_cfgs.html"},{"title":"ty_tempo_table_cfgs – TEMPO Microphysics ","text":"type, public :: ty_tempo_table_cfgs Components Type Visibility Attributes Name Initial character(len=100), public :: ccn_table_name = 'ccn_activate.bin' ccn table name character(len=100), public :: qrqg_table_name = 'qr_acr_qg_data_tempo_v3' rain-graupel collection table name character(len=100), public :: qrqs_table_name = 'qr_acr_qs_data_tempo_v3' rain-snow collection table name character(len=100), public :: freezewater_table_name = 'freeze_water_data_tempo_v3' freeze water collection table name","tags":"","url":"type/ty_tempo_table_cfgs.html"},{"title":"calc_gamma_p – TEMPO Microphysics","text":"public  function calc_gamma_p(a, x) result(gamma_p) normalized lower gamma function calculated either with a \nseries expansion or continued fraction method\ninput: a = gamma function argument, x = upper limit of integration\noutput: gamma_p = Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~calc_gamma_p~~CalledByGraph proc~calc_gamma_p calc_gamma_p proc~tempo_init tempo_init proc~tempo_init->proc~calc_gamma_p Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calc_gamma_p.html"},{"title":"calc_rslf – TEMPO Microphysics","text":"public  function calc_rslf(p, t) result(rslf) calculates liquid saturation vapor mixing ratio Note Even with P=1050mb and T=55C, the saturation vapor \npressure only contributes to ~15% of the total pressure Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: p real(kind=wp), intent(in) :: t Return Value real(kind=wp) Called by proc~~calc_rslf~~CalledByGraph proc~calc_rslf calc_rslf proc~mp_tempo_main mp_tempo_main proc~mp_tempo_main->proc~calc_rslf proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~mp_tempo_main Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calc_rslf.html"},{"title":"calc_rsif – TEMPO Microphysics","text":"public  function calc_rsif(p, t) result(rsif) calculates liquid saturation vapor mixing ratio Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: p real(kind=wp), intent(in) :: t Return Value real(kind=wp) Called by proc~~calc_rsif~~CalledByGraph proc~calc_rsif calc_rsif proc~mp_tempo_main mp_tempo_main proc~mp_tempo_main->proc~calc_rsif proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~mp_tempo_main Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calc_rsif.html"},{"title":"get_nuc – TEMPO Microphysics","text":"public  function get_nuc(nc) result(nu_c) Uses module_mp_tempo_params proc~~get_nuc~~UsesGraph proc~get_nuc get_nuc module~module_mp_tempo_params module_mp_tempo_params proc~get_nuc->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. returns nu_c for cloud water (values from 2-15) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: nc Return Value integer Called by proc~~get_nuc~~CalledByGraph proc~get_nuc get_nuc proc~tempo_init tempo_init proc~tempo_init->proc~get_nuc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/get_nuc.html"},{"title":"snow_moments – TEMPO Microphysics","text":"public  subroutine snow_moments(rs, tc, smob, smoc, ns, smo0, smo1, smo2, smoe, smof, smog) Uses module_mp_tempo_params proc~~snow_moments~~UsesGraph proc~snow_moments snow_moments module~module_mp_tempo_params module_mp_tempo_params proc~snow_moments->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute snow moments Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: rs real(kind=wp), intent(in) :: tc real(kind=dp), intent(out) :: smob real(kind=dp), intent(out) :: smoc real(kind=dp), intent(out), optional :: ns real(kind=dp), intent(out), optional :: smo0 real(kind=dp), intent(out), optional :: smo1 real(kind=dp), intent(out), optional :: smo2 real(kind=dp), intent(out), optional :: smoe real(kind=dp), intent(out), optional :: smof real(kind=dp), intent(out), optional :: smog Called by proc~~snow_moments~~CalledByGraph proc~snow_moments snow_moments proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~snow_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/snow_moments.html"},{"title":"predict_number – TEMPO Microphysics","text":"public  function predict_number(qc, qr, qi, qs, pres, temp, w, predict_nc) Arguments Type Intent Optional Attributes Name real, intent(in) :: qc real, intent(in) :: qr real, intent(in) :: qi real, intent(in) :: qs real, intent(in) :: pres real, intent(in) :: temp real, intent(in) :: w logical, intent(in) :: predict_nc Return Value real Calls proc~~predict_number~~CallsGraph proc~predict_number predict_number proc~tempo_save_or_read_ml_data tempo_save_or_read_ml_data proc~predict_number->proc~tempo_save_or_read_ml_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/predict_number.html"},{"title":"tempo_save_or_read_ml_data – TEMPO Microphysics","text":"public  subroutine tempo_save_or_read_ml_data(ml_data_in, ml_data_out) Arguments Type Intent Optional Attributes Name type( MLdata ), intent(in), optional, dimension(2) :: ml_data_in type( MLdata ), intent(out), optional, dimension(2) :: ml_data_out Called by proc~~tempo_save_or_read_ml_data~~CalledByGraph proc~tempo_save_or_read_ml_data tempo_save_or_read_ml_data proc~predict_number predict_number proc~predict_number->proc~tempo_save_or_read_ml_data proc~predict_number_sub predict_number_sub proc~predict_number_sub->proc~tempo_save_or_read_ml_data proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~predict_number_sub Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/tempo_save_or_read_ml_data.html"},{"title":"predict_number_sub – TEMPO Microphysics","text":"public  subroutine predict_number_sub(kts, kte, qc, qr, qi, qs, pres, temp, w, predict_number, predict_nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: kts integer, intent(in) :: kte real, intent(in), dimension(kts:kte) :: qc real, intent(in), dimension(kts:kte) :: qr real, intent(in), dimension(kts:kte) :: qi real, intent(in), dimension(kts:kte) :: qs real, intent(in), dimension(kts:kte) :: pres real, intent(in), dimension(kts:kte) :: temp real, intent(in), dimension(kts:kte) :: w double precision, intent(inout), dimension(kts:kte) :: predict_number logical, intent(in) :: predict_nc Calls proc~~predict_number_sub~~CallsGraph proc~predict_number_sub predict_number_sub proc~tempo_save_or_read_ml_data tempo_save_or_read_ml_data proc~predict_number_sub->proc~tempo_save_or_read_ml_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~predict_number_sub~~CalledByGraph proc~predict_number_sub predict_number_sub proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~predict_number_sub Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/predict_number_sub.html"},{"title":"radar_init – TEMPO Microphysics","text":"public  subroutine radar_init() \\ingroup thompson_radar Arguments None Calls proc~~radar_init~~CallsGraph proc~radar_init radar_init dexp dexp proc~radar_init->dexp dfloat dfloat proc~radar_init->dfloat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/radar_init.html"},{"title":"rayleigh_soak_wetgraupel – TEMPO Microphysics","text":"public  subroutine rayleigh_soak_wetgraupel(x_g, a_geo, b_geo, fmelt, meltratio_outside, m_w, m_i, lambda, C_back, mixingrule, matrix, inclusion, host, hostmatrix, hostinclusion) ingroup thompson_radar Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x_g double precision, intent(in) :: a_geo double precision, intent(in) :: b_geo double precision, intent(in) :: fmelt double precision, intent(in) :: meltratio_outside complex(kind=16), intent(in) :: m_w complex(kind=16), intent(in) :: m_i double precision, intent(in) :: lambda double precision, intent(out) :: C_back character(len=*), intent(in) :: mixingrule character(len=*), intent(in) :: matrix character(len=*), intent(in) :: inclusion character(len=*), intent(in) :: host character(len=*), intent(in) :: hostmatrix character(len=*), intent(in) :: hostinclusion Called by proc~~rayleigh_soak_wetgraupel~~CalledByGraph proc~rayleigh_soak_wetgraupel rayleigh_soak_wetgraupel proc~calc_refl10cm calc_refl10cm proc~calc_refl10cm->proc~rayleigh_soak_wetgraupel proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~calc_refl10cm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/rayleigh_soak_wetgraupel.html"},{"title":"tempo_3d_to_1d_driver – TEMPO Microphysics","text":"public  subroutine tempo_3d_to_1d_driver(qv, qc, qr, qi, qs, qg, qb, ni, nr, nc, ng, nwfa, nifa, nwfa2d, nifa2d, th, pii, p, w, dz, dt_in, itimestep, rainnc, rainncv, snownc, snowncv, graupelnc, graupelncv, sr, frainnc, refl_10cm, diagflag, do_radar_ref, re_cloud, re_ice, re_snow, qcbl, cldfrac, has_reqc, has_reqi, has_reqs, ntc, muc, rainprod, evapprod, max_hail_diameter_column, max_hail_diameter_sfc, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte) ! K LOOP                enddo Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qv real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qc real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qr real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qi real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qs real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qg real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: qb real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: ni real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: nr real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nc real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: ng real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nwfa real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nifa real, intent(in), optional, dimension(ims:ime, jms:jme) :: nwfa2d real, intent(in), optional, dimension(ims:ime, jms:jme) :: nifa2d real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: th real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: pii real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: p real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: w real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: dz real, intent(in) :: dt_in integer, intent(in) :: itimestep real, intent(inout), dimension(ims:ime, jms:jme) :: rainnc real, intent(inout), dimension(ims:ime, jms:jme) :: rainncv real, intent(inout), optional, dimension(ims:ime, jms:jme) :: snownc real, intent(inout), optional, dimension(ims:ime, jms:jme) :: snowncv real, intent(inout), optional, dimension(ims:ime, jms:jme) :: graupelnc real, intent(inout), optional, dimension(ims:ime, jms:jme) :: graupelncv real, intent(inout), dimension(ims:ime, jms:jme) :: sr real, intent(inout), optional, dimension(ims:ime,jms:jme) :: frainnc real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: refl_10cm logical, intent(in), optional :: diagflag integer, intent(in), optional :: do_radar_ref real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_cloud real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_ice real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_snow real, intent(in), optional, dimension(ims:ime, kms:kme, jms:jme) :: qcbl real, intent(in), optional, dimension(ims:ime, kms:kme, jms:jme) :: cldfrac integer, intent(in) :: has_reqc integer, intent(in) :: has_reqi integer, intent(in) :: has_reqs real, intent(in), optional, dimension(ims:ime, jms:jme) :: ntc real, intent(in), optional, dimension(ims:ime, jms:jme) :: muc real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: rainprod real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: evapprod real, intent(inout), optional, dimension(ims:ime,jms:jme) :: max_hail_diameter_column real, intent(inout), optional, dimension(ims:ime,jms:jme) :: max_hail_diameter_sfc integer, intent(in) :: ids integer, intent(in) :: ide integer, intent(in) :: jds integer, intent(in) :: jde integer, intent(in) :: kds integer, intent(in) :: kde integer, intent(in) :: ims integer, intent(in) :: ime integer, intent(in) :: jms integer, intent(in) :: jme integer, intent(in) :: kms integer, intent(in) :: kme integer, intent(in) :: its integer, intent(in) :: ite integer, intent(in) :: jts integer, intent(in) :: jte integer, intent(in) :: kts integer, intent(in) :: kte Calls proc~~tempo_3d_to_1d_driver~~CallsGraph proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~calc_effectrad calc_effectRad proc~tempo_3d_to_1d_driver->proc~calc_effectrad proc~calc_refl10cm calc_refl10cm proc~tempo_3d_to_1d_driver->proc~calc_refl10cm proc~hail_size_diagnostics hail_size_diagnostics proc~tempo_3d_to_1d_driver->proc~hail_size_diagnostics proc~mp_tempo_main mp_tempo_main proc~tempo_3d_to_1d_driver->proc~mp_tempo_main proc~predict_number_sub predict_number_sub proc~tempo_3d_to_1d_driver->proc~predict_number_sub sngl sngl proc~calc_effectrad->sngl dexp dexp proc~calc_refl10cm->dexp proc~rayleigh_soak_wetgraupel rayleigh_soak_wetgraupel proc~calc_refl10cm->proc~rayleigh_soak_wetgraupel proc~calc_refl10cm->sngl proc~create_bins create_bins proc~hail_size_diagnostics->proc~create_bins alog alog proc~mp_tempo_main->alog alog10 alog10 proc~mp_tempo_main->alog10 float float proc~mp_tempo_main->float proc~calc_rsif calc_rsif proc~mp_tempo_main->proc~calc_rsif proc~calc_rslf calc_rslf proc~mp_tempo_main->proc~calc_rslf proc~mp_tempo_main->sngl proc~tempo_save_or_read_ml_data tempo_save_or_read_ml_data proc~predict_number_sub->proc~tempo_save_or_read_ml_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/tempo_3d_to_1d_driver.html"},{"title":"mp_tempo_main – TEMPO Microphysics","text":"public  subroutine mp_tempo_main(qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, qb1d, ni1d, nr1d, nc1d, ng1d, nwfa1d, nifa1d, t1d, p1d, w1d, dzq, pptrain, pptsnow, pptgraul, pptice, ext_diag, sedi_semi, prw_vcdc1, prw_vcde1, tpri_inu1, tpri_ide1_d, tpri_ide1_s, tprs_ide1, tprs_sde1_d, tprs_sde1_s, tprg_gde1_d, tprg_gde1_s, tpri_iha1, tpri_wfz1, tpri_rfz1, tprg_rfz1, tprs_scw1, tprg_scw1, tprg_rcs1, tprs_rcs1, tprr_rci1, tprg_rcg1, tprw_vcd1_c, tprw_vcd1_e, tprr_sml1, tprr_gml1, tprr_rcg1, tprr_rcs1, tprv_rev1, tten1, qvten1, qrten1, qsten1, qgten1, qiten1, niten1, nrten1, ncten1, qcten1, decfl, pfil1, pfll1, lsml, rand1, rand2, rand3, kts, kte, dt, ii, jj) ! #if defined(mpas)\n configs) !                Ef_rr = 1.0 - exp(2300.0*(mvd_r(k)-1950.0E-6))\n  - Rain collecting cloud water.  In CE, assume Dc< Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(kts:kte) :: qv1d real(kind=wp), intent(inout), dimension(kts:kte) :: qc1d real(kind=wp), intent(inout), dimension(kts:kte) :: qi1d real(kind=wp), intent(inout), dimension(kts:kte) :: qr1d real(kind=wp), intent(inout), dimension(kts:kte) :: qs1d real(kind=wp), intent(inout), dimension(kts:kte) :: qg1d real(kind=wp), intent(inout), dimension(kts:kte) :: qb1d real(kind=wp), intent(inout), dimension(kts:kte) :: ni1d real(kind=wp), intent(inout), dimension(kts:kte) :: nr1d real(kind=wp), intent(inout), dimension(kts:kte) :: nc1d real(kind=wp), intent(inout), dimension(kts:kte) :: ng1d real(kind=wp), intent(inout), dimension(kts:kte) :: nwfa1d real(kind=wp), intent(inout), dimension(kts:kte) :: nifa1d real(kind=wp), intent(inout), dimension(kts:kte) :: t1d real(kind=wp), intent(in), dimension(kts:kte) :: p1d real(kind=wp), intent(in), dimension(kts:kte) :: w1d real(kind=wp), intent(in), dimension(kts:kte) :: dzq real(kind=wp), intent(inout) :: pptrain real(kind=wp), intent(inout) :: pptsnow real(kind=wp), intent(inout) :: pptgraul real(kind=wp), intent(inout) :: pptice logical, intent(in) :: ext_diag logical, intent(in) :: sedi_semi real(kind=wp), intent(out), optional, dimension(:) :: prw_vcdc1 real(kind=wp), intent(out), optional, dimension(:) :: prw_vcde1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_inu1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_ide1_d real(kind=wp), intent(out), optional, dimension(:) :: tpri_ide1_s real(kind=wp), intent(out), optional, dimension(:) :: tprs_ide1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_sde1_d real(kind=wp), intent(out), optional, dimension(:) :: tprs_sde1_s real(kind=wp), intent(out), optional, dimension(:) :: tprg_gde1_d real(kind=wp), intent(out), optional, dimension(:) :: tprg_gde1_s real(kind=wp), intent(out), optional, dimension(:) :: tpri_iha1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_wfz1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_rfz1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rfz1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_scw1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_scw1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rci1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rcg1 real(kind=wp), intent(out), optional, dimension(:) :: tprw_vcd1_c real(kind=wp), intent(out), optional, dimension(:) :: tprw_vcd1_e real(kind=wp), intent(out), optional, dimension(:) :: tprr_sml1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_gml1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rcg1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprv_rev1 real(kind=wp), intent(out), optional, dimension(:) :: tten1 real(kind=wp), intent(out), optional, dimension(:) :: qvten1 real(kind=wp), intent(out), optional, dimension(:) :: qrten1 real(kind=wp), intent(out), optional, dimension(:) :: qsten1 real(kind=wp), intent(out), optional, dimension(:) :: qgten1 real(kind=wp), intent(out), optional, dimension(:) :: qiten1 real(kind=wp), intent(out), optional, dimension(:) :: niten1 real(kind=wp), intent(out), optional, dimension(:) :: nrten1 real(kind=wp), intent(out), optional, dimension(:) :: ncten1 real(kind=wp), intent(out), optional, dimension(:) :: qcten1 integer, intent(in), optional :: decfl real(kind=wp), intent(out), optional, dimension(kts:kte) :: pfil1 real(kind=wp), intent(out), optional, dimension(kts:kte) :: pfll1 integer, intent(in), optional :: lsml real(kind=wp), intent(in), optional :: rand1 real(kind=wp), intent(in), optional :: rand2 real(kind=wp), intent(in), optional :: rand3 integer, intent(in) :: kts integer, intent(in) :: kte real(kind=wp), intent(in) :: dt type(ty_tempo_cfg), intent(in) :: configs integer, intent(in) :: ii integer, intent(in) :: jj Calls proc~~mp_tempo_main~~CallsGraph proc~mp_tempo_main mp_tempo_main alog alog proc~mp_tempo_main->alog alog10 alog10 proc~mp_tempo_main->alog10 float float proc~mp_tempo_main->float proc~calc_rsif calc_rsif proc~mp_tempo_main->proc~calc_rsif proc~calc_rslf calc_rslf proc~mp_tempo_main->proc~calc_rslf sngl sngl proc~mp_tempo_main->sngl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mp_tempo_main~~CalledByGraph proc~mp_tempo_main mp_tempo_main proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~mp_tempo_main Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/mp_tempo_main.html"},{"title":"tempo_init – TEMPO Microphysics","text":"public  subroutine tempo_init(aerosolaware_flag, hailaware_flag, restart_flag) Uses module_mp_tempo_params proc~~tempo_init~~UsesGraph proc~tempo_init tempo_init module~module_mp_tempo_params module_mp_tempo_params proc~tempo_init->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. public procedure called to initialize tempo microphysics Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: aerosolaware_flag logical, intent(in), optional :: hailaware_flag logical, intent(in), optional :: restart_flag Calls proc~~tempo_init~~CallsGraph proc~tempo_init tempo_init proc~calc_gamma_p calc_gamma_p proc~tempo_init->proc~calc_gamma_p proc~compute_efrw compute_efrw proc~tempo_init->proc~compute_efrw proc~compute_efsw compute_efsw proc~tempo_init->proc~compute_efsw proc~get_nuc get_nuc proc~tempo_init->proc~get_nuc proc~initialize_array_efrw initialize_array_efrw proc~tempo_init->proc~initialize_array_efrw proc~initialize_array_efsw initialize_array_efsw proc~tempo_init->proc~initialize_array_efsw proc~initialize_arrays_ccn initialize_arrays_ccn proc~tempo_init->proc~initialize_arrays_ccn proc~initialize_arrays_drop_evap initialize_arrays_drop_evap proc~tempo_init->proc~initialize_arrays_drop_evap proc~initialize_arrays_freezewater initialize_arrays_freezewater proc~tempo_init->proc~initialize_arrays_freezewater proc~initialize_arrays_qi_aut_qs initialize_arrays_qi_aut_qs proc~tempo_init->proc~initialize_arrays_qi_aut_qs proc~initialize_arrays_qr_acr_qg initialize_arrays_qr_acr_qg proc~tempo_init->proc~initialize_arrays_qr_acr_qg proc~initialize_arrays_qr_acr_qs initialize_arrays_qr_acr_qs proc~tempo_init->proc~initialize_arrays_qr_acr_qs proc~initialize_bins_for_tables initialize_bins_for_tables proc~tempo_init->proc~initialize_bins_for_tables proc~initialize_graupel_vars initialize_graupel_vars proc~tempo_init->proc~initialize_graupel_vars proc~initialize_parameters initialize_parameters proc~tempo_init->proc~initialize_parameters proc~create_bins create_bins proc~initialize_bins_for_tables->proc~create_bins Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/tempo_init.html"},{"title":"tempo_build_tables – TEMPO Microphysics","text":"public  subroutine tempo_build_tables(build_tables_rank, build_tables_num_proc) Uses module_mp_tempo_params proc~~tempo_build_tables~~UsesGraph proc~tempo_build_tables tempo_build_tables module~module_mp_tempo_params module_mp_tempo_params proc~tempo_build_tables->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. public procedure to build 3 lookup tables for tempo microphysics Arguments Type Intent Optional Attributes Name integer, intent(in) :: build_tables_rank integer, intent(in) :: build_tables_num_proc Calls proc~~tempo_build_tables~~CallsGraph proc~tempo_build_tables tempo_build_tables mpi_allgather mpi_allgather proc~tempo_build_tables->mpi_allgather mpi_barrier mpi_barrier proc~tempo_build_tables->mpi_barrier mpi_gatherv mpi_gatherv proc~tempo_build_tables->mpi_gatherv mpi_wtime mpi_wtime proc~tempo_build_tables->mpi_wtime proc~initialize_arrays_freezewater initialize_arrays_freezewater proc~tempo_build_tables->proc~initialize_arrays_freezewater proc~initialize_arrays_qr_acr_qg initialize_arrays_qr_acr_qg proc~tempo_build_tables->proc~initialize_arrays_qr_acr_qg proc~initialize_arrays_qr_acr_qs initialize_arrays_qr_acr_qs proc~tempo_build_tables->proc~initialize_arrays_qr_acr_qs proc~initialize_bins_for_tables initialize_bins_for_tables proc~tempo_build_tables->proc~initialize_bins_for_tables proc~initialize_graupel_vars initialize_graupel_vars proc~tempo_build_tables->proc~initialize_graupel_vars proc~initialize_parameters initialize_parameters proc~tempo_build_tables->proc~initialize_parameters proc~snow_moments snow_moments proc~tempo_build_tables->proc~snow_moments proc~create_bins create_bins proc~initialize_bins_for_tables->proc~create_bins Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/tempo_build_tables.html"},{"title":"compute_efrw – TEMPO Microphysics","text":"public  subroutine compute_efrw() Uses module_mp_tempo_params proc~~compute_efrw~~UsesGraph proc~compute_efrw compute_efrw module~module_mp_tempo_params module_mp_tempo_params proc~compute_efrw->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. collision efficiency for rain collecting cloud water from Beard and Grover (1974)\nif a/A < 0.25, otherwise uses polynomials to get close match of Pruppacher & Klett Fig. 14-9 Arguments None Called by proc~~compute_efrw~~CalledByGraph proc~compute_efrw compute_efrw proc~tempo_init tempo_init proc~tempo_init->proc~compute_efrw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/compute_efrw.html"},{"title":"compute_efsw – TEMPO Microphysics","text":"public  subroutine compute_efsw() Uses module_mp_tempo_params proc~~compute_efsw~~UsesGraph proc~compute_efsw compute_efsw module~module_mp_tempo_params module_mp_tempo_params proc~compute_efsw->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. collision efficiency for snow collecting cloud water from Wang and Ji (2000) except\nequate melted snow diameter to their \"effective collision cross-section.\" Arguments None Called by proc~~compute_efsw~~CalledByGraph proc~compute_efsw compute_efsw proc~tempo_init tempo_init proc~tempo_init->proc~compute_efsw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/compute_efsw.html"},{"title":"calc_effectRad – TEMPO Microphysics","text":"public  subroutine calc_effectRad(t1d, p1d, qv1d, qc1d, nc1d, qi1d, ni1d, qs1d, re_qc1d, re_qi1d, re_qs1d, kts, kte, lsml) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(kts:kte) :: t1d real, intent(in), DIMENSION(kts:kte) :: p1d real, intent(in), DIMENSION(kts:kte) :: qv1d real, intent(in), DIMENSION(kts:kte) :: qc1d real, intent(in), DIMENSION(kts:kte) :: nc1d real, intent(in), DIMENSION(kts:kte) :: qi1d real, intent(in), DIMENSION(kts:kte) :: ni1d real, intent(in), DIMENSION(kts:kte) :: qs1d real, intent(inout), DIMENSION(kts:kte) :: re_qc1d real, intent(inout), DIMENSION(kts:kte) :: re_qi1d real, intent(inout), DIMENSION(kts:kte) :: re_qs1d integer, intent(in) :: kts integer, intent(in) :: kte integer, intent(in), optional :: lsml Calls proc~~calc_effectrad~~CallsGraph proc~calc_effectrad calc_effectRad sngl sngl proc~calc_effectrad->sngl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_effectrad~~CalledByGraph proc~calc_effectrad calc_effectRad proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~calc_effectrad Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calc_effectrad.html"},{"title":"calc_refl10cm – TEMPO Microphysics","text":"public  subroutine calc_refl10cm(qv1d, qc1d, qr1d, nr1d, qs1d, qg1d, ng1d, qb1d, t1d, p1d, dBZ, kts, kte, ii, jj, rand1, melti, vt_dBZ, first_time_step) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(kts:kte) :: qv1d real, intent(in), DIMENSION(kts:kte) :: qc1d real, intent(in), DIMENSION(kts:kte) :: qr1d real, intent(in), DIMENSION(kts:kte) :: nr1d real, intent(in), DIMENSION(kts:kte) :: qs1d real, intent(in), DIMENSION(kts:kte) :: qg1d real, intent(in), DIMENSION(kts:kte) :: ng1d real, intent(in), DIMENSION(kts:kte) :: qb1d real, intent(in), DIMENSION(kts:kte) :: t1d real, intent(in), DIMENSION(kts:kte) :: p1d real, intent(inout), DIMENSION(kts:kte) :: dBZ integer, intent(in) :: kts integer, intent(in) :: kte integer, intent(in) :: ii integer, intent(in) :: jj real, intent(in), optional :: rand1 logical, intent(in), optional :: melti real, intent(inout), optional, DIMENSION(kts:kte) :: vt_dBZ logical, intent(in), optional :: first_time_step Calls proc~~calc_refl10cm~~CallsGraph proc~calc_refl10cm calc_refl10cm dexp dexp proc~calc_refl10cm->dexp proc~rayleigh_soak_wetgraupel rayleigh_soak_wetgraupel proc~calc_refl10cm->proc~rayleigh_soak_wetgraupel sngl sngl proc~calc_refl10cm->sngl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calc_refl10cm~~CalledByGraph proc~calc_refl10cm calc_refl10cm proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~calc_refl10cm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calc_refl10cm.html"},{"title":"hail_size_diagnostics – TEMPO Microphysics","text":"public  subroutine hail_size_diagnostics(kts, kte, qg1d, ng1d, qb1d, t1d, p1d, qv1d, qg_max_diam1d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: kts integer, intent(in) :: kte real(kind=wp), intent(in), dimension(kts:kte) :: qg1d real(kind=wp), intent(in), dimension(kts:kte) :: ng1d real(kind=wp), intent(in), dimension(kts:kte) :: qb1d real(kind=wp), intent(in), dimension(kts:kte) :: t1d real(kind=wp), intent(in), dimension(kts:kte) :: p1d real(kind=wp), intent(in), dimension(kts:kte) :: qv1d real(kind=wp), intent(out), dimension(kts:kte) :: qg_max_diam1d Calls proc~~hail_size_diagnostics~~CallsGraph proc~hail_size_diagnostics hail_size_diagnostics proc~create_bins create_bins proc~hail_size_diagnostics->proc~create_bins Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hail_size_diagnostics~~CalledByGraph proc~hail_size_diagnostics hail_size_diagnostics proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~hail_size_diagnostics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/hail_size_diagnostics.html"},{"title":"initialize_graupel_vars – TEMPO Microphysics","text":"public  subroutine initialize_graupel_vars(hail_flag) initialize graupel variables based on hail-aware configuration flag Arguments Type Intent Optional Attributes Name logical, intent(in) :: hail_flag Called by proc~~initialize_graupel_vars~~CalledByGraph proc~initialize_graupel_vars initialize_graupel_vars proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_graupel_vars proc~tempo_init tempo_init proc~tempo_init->proc~initialize_graupel_vars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_graupel_vars.html"},{"title":"initialize_parameters – TEMPO Microphysics","text":"public  subroutine initialize_parameters() initialize tempo parameters and variables Arguments None Called by proc~~initialize_parameters~~CalledByGraph proc~initialize_parameters initialize_parameters proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_parameters proc~tempo_init tempo_init proc~tempo_init->proc~initialize_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_parameters.html"},{"title":"initialize_bins_for_tables – TEMPO Microphysics","text":"public  subroutine initialize_bins_for_tables() initialize log-spaced bins of hydrometer quantities used for lookup tables Arguments None Calls proc~~initialize_bins_for_tables~~CallsGraph proc~initialize_bins_for_tables initialize_bins_for_tables proc~create_bins create_bins proc~initialize_bins_for_tables->proc~create_bins Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_bins_for_tables~~CalledByGraph proc~initialize_bins_for_tables initialize_bins_for_tables proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_bins_for_tables proc~tempo_init tempo_init proc~tempo_init->proc~initialize_bins_for_tables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_bins_for_tables.html"},{"title":"create_bins – TEMPO Microphysics","text":"public  subroutine create_bins(numbins, lowbin, highbin, bins, deltabins) calculates log-spaced bins of hydrometer sizes to simplify calculations later Arguments Type Intent Optional Attributes Name integer, intent(in) :: numbins real(kind=dp), intent(in) :: lowbin real(kind=dp), intent(in) :: highbin real(kind=dp), intent(out), dimension(:) :: bins real(kind=dp), intent(out), optional, dimension(:) :: deltabins Called by proc~~create_bins~~CalledByGraph proc~create_bins create_bins proc~hail_size_diagnostics hail_size_diagnostics proc~hail_size_diagnostics->proc~create_bins proc~initialize_bins_for_tables initialize_bins_for_tables proc~initialize_bins_for_tables->proc~create_bins proc~tempo_3d_to_1d_driver tempo_3d_to_1d_driver proc~tempo_3d_to_1d_driver->proc~hail_size_diagnostics proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_bins_for_tables proc~tempo_init tempo_init proc~tempo_init->proc~initialize_bins_for_tables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/create_bins.html"},{"title":"initialize_arrays_freezewater – TEMPO Microphysics","text":"public  subroutine initialize_arrays_freezewater(table_size) initialize data arrays for Bigg (1953) freezing of cloud water and rain Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size Called by proc~~initialize_arrays_freezewater~~CalledByGraph proc~initialize_arrays_freezewater initialize_arrays_freezewater proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_arrays_freezewater proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_freezewater Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_freezewater.html"},{"title":"initialize_arrays_qr_acr_qs – TEMPO Microphysics","text":"public  subroutine initialize_arrays_qr_acr_qs(table_size) initialize data arrays for rain-snow collection Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size Called by proc~~initialize_arrays_qr_acr_qs~~CalledByGraph proc~initialize_arrays_qr_acr_qs initialize_arrays_qr_acr_qs proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_arrays_qr_acr_qs proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_qr_acr_qs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_qr_acr_qs.html"},{"title":"initialize_arrays_qr_acr_qg – TEMPO Microphysics","text":"public  subroutine initialize_arrays_qr_acr_qg(table_size) initialize data arrays for rain-graupel collection Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size Called by proc~~initialize_arrays_qr_acr_qg~~CalledByGraph proc~initialize_arrays_qr_acr_qg initialize_arrays_qr_acr_qg proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->proc~initialize_arrays_qr_acr_qg proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_qr_acr_qg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_qr_acr_qg.html"},{"title":"initialize_arrays_ccn – TEMPO Microphysics","text":"public  subroutine initialize_arrays_ccn(table_size) initialize data arrays for ccn lookup table Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size Called by proc~~initialize_arrays_ccn~~CalledByGraph proc~initialize_arrays_ccn initialize_arrays_ccn proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_ccn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_ccn.html"},{"title":"initialize_arrays_drop_evap – TEMPO Microphysics","text":"public  subroutine initialize_arrays_drop_evap() initialize data arrays for drop evaporation data Arguments None Called by proc~~initialize_arrays_drop_evap~~CalledByGraph proc~initialize_arrays_drop_evap initialize_arrays_drop_evap proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_drop_evap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_drop_evap.html"},{"title":"initialize_array_efsw – TEMPO Microphysics","text":"public  subroutine initialize_array_efsw() initializes the collision efficiency data array for snow collecting cloud water Arguments None Called by proc~~initialize_array_efsw~~CalledByGraph proc~initialize_array_efsw initialize_array_efsw proc~tempo_init tempo_init proc~tempo_init->proc~initialize_array_efsw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_array_efsw.html"},{"title":"initialize_array_efrw – TEMPO Microphysics","text":"public  subroutine initialize_array_efrw() initializes the collision efficiency data array for rain collecting cloud water Arguments None Called by proc~~initialize_array_efrw~~CalledByGraph proc~initialize_array_efrw initialize_array_efrw proc~tempo_init tempo_init proc~tempo_init->proc~initialize_array_efrw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_array_efrw.html"},{"title":"initialize_arrays_qi_aut_qs – TEMPO Microphysics","text":"public  subroutine initialize_arrays_qi_aut_qs() initializes data arrays for cloud ice to snow conversion and growth Arguments None Called by proc~~initialize_arrays_qi_aut_qs~~CalledByGraph proc~initialize_arrays_qi_aut_qs initialize_arrays_qi_aut_qs proc~tempo_init tempo_init proc~tempo_init->proc~initialize_arrays_qi_aut_qs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initialize_arrays_qi_aut_qs.html"},{"title":"module_mp_tempo_utils – TEMPO Microphysics","text":"utilities for tempo microphysics Uses module_mp_tempo_params module~~module_mp_tempo_utils~~UsesGraph module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_utils->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_mp_tempo_utils~~UsedByGraph module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_init module_mp_tempo_init module~module_mp_tempo_init->module~module_mp_tempo_utils module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_main->module~module_mp_tempo_utils module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function calc_gamma_p (a, x) result(gamma_p) normalized lower gamma function calculated either with a \nseries expansion or continued fraction method\ninput: a = gamma function argument, x = upper limit of integration\noutput: gamma_p = Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function calc_rslf (p, t) result(rslf) calculates liquid saturation vapor mixing ratio Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: p real(kind=wp), intent(in) :: t Return Value real(kind=wp) public  function calc_rsif (p, t) result(rsif) calculates liquid saturation vapor mixing ratio Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: p real(kind=wp), intent(in) :: t Return Value real(kind=wp) public  function get_nuc (nc) result(nu_c) returns nu_c for cloud water (values from 2-15) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: nc Return Value integer Subroutines public  subroutine snow_moments (rs, tc, smob, smoc, ns, smo0, smo1, smo2, smoe, smof, smog) Compute snow moments Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: rs real(kind=wp), intent(in) :: tc real(kind=dp), intent(out) :: smob real(kind=dp), intent(out) :: smoc real(kind=dp), intent(out), optional :: ns real(kind=dp), intent(out), optional :: smo0 real(kind=dp), intent(out), optional :: smo1 real(kind=dp), intent(out), optional :: smo2 real(kind=dp), intent(out), optional :: smoe real(kind=dp), intent(out), optional :: smof real(kind=dp), intent(out), optional :: smog","tags":"","url":"module/module_mp_tempo_utils.html"},{"title":"module_mp_tempo_ml – TEMPO Microphysics","text":"Uses module_mp_tempo_params module~~module_mp_tempo_ml~~UsesGraph module~module_mp_tempo_ml module_mp_tempo_ml module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_ml->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_mp_tempo_ml~~UsedByGraph module~module_mp_tempo_ml module_mp_tempo_ml module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_ml Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: MLdata Components Type Visibility Attributes Name Initial integer, public :: input_size integer, public :: output_size integer, public :: node_size real, public, allocatable, dimension(:) :: transform_mean real, public, allocatable, dimension(:) :: transform_var real, public, allocatable, dimension(:,:) :: weights00 real, public, allocatable, dimension(:) :: bias00 real, public, allocatable, dimension(:,:) :: weights01 real, public, allocatable, dimension(:) :: bias01 Functions public  function predict_number (qc, qr, qi, qs, pres, temp, w, predict_nc) Arguments Type Intent Optional Attributes Name real, intent(in) :: qc real, intent(in) :: qr real, intent(in) :: qi real, intent(in) :: qs real, intent(in) :: pres real, intent(in) :: temp real, intent(in) :: w logical, intent(in) :: predict_nc Return Value real Subroutines public  subroutine tempo_save_or_read_ml_data (ml_data_in, ml_data_out) Arguments Type Intent Optional Attributes Name type( MLdata ), intent(in), optional, dimension(2) :: ml_data_in type( MLdata ), intent(out), optional, dimension(2) :: ml_data_out public  subroutine predict_number_sub (kts, kte, qc, qr, qi, qs, pres, temp, w, predict_number, predict_nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: kts integer, intent(in) :: kte real, intent(in), dimension(kts:kte) :: qc real, intent(in), dimension(kts:kte) :: qr real, intent(in), dimension(kts:kte) :: qi real, intent(in), dimension(kts:kte) :: qs real, intent(in), dimension(kts:kte) :: pres real, intent(in), dimension(kts:kte) :: temp real, intent(in), dimension(kts:kte) :: w double precision, intent(inout), dimension(kts:kte) :: predict_number logical, intent(in) :: predict_nc","tags":"","url":"module/module_mp_tempo_ml.html"},{"title":"module_mp_radar – TEMPO Microphysics","text":"\\file module_mp_radar.F90\n This set of routines facilitates computing radar reflectivity.\n\\ingroup aathompson\n This module is more library code whereas the individual microphysics\n schemes contains specific details needed for the final computation,\n so refer to location within each schemes calling the routine named\n rayleigh_soak_wetgraupel. The bulk of this code originated from Ulrich Blahak (Germany) and\n was adapted to WRF by G. Thompson.  This version of code is only\n intended for use when Rayleigh scattering principles dominate and\n is not intended for wavelengths in which Mie scattering is a\n significant portion.  Therefore, it is well-suited to use with\n 5 or 10 cm wavelength like USA NEXRAD radars.\n This code makes some rather simple assumptions about water\n coating on outside of frozen species (snow/graupel).  Fraction of\n meltwater is simply the ratio of mixing ratio below melting level\n divided by mixing ratio at level just above highest T>0C.  Also,\n immediately 90% of the melted water exists on the ice's surface\n and 10% is embedded within ice.  No water is \"shed\" at all in these\n assumptions. The code is quite slow because it does the reflectivity\n calculations based on 50 individual size bins of the distributions. Used by module~~module_mp_radar~~UsedByGraph module~module_mp_radar module_mp_radar module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_tempo_diags->module~module_mp_radar module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_diags Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: nrbins = 50 double precision, public, DIMENSION(nrbins+1) :: xxDx double precision, public, DIMENSION(nrbins) :: xxDs double precision, public, DIMENSION(nrbins) :: xdts double precision, public, DIMENSION(nrbins) :: xxDg double precision, public, DIMENSION(nrbins) :: xdtg double precision, public, parameter :: lamda_radar = 0.10 double precision, public :: K_w double precision, public :: PI5 double precision, public :: lamda4 complex(kind=16), public :: m_w_0 complex(kind=16), public :: m_i_0 double precision, public, DIMENSION(nrbins+1) :: simpson double precision, public, parameter,               DIMENSION(3) :: basis = (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/) real, public, DIMENSION(4) :: xcre real, public, DIMENSION(4) :: xcse real, public, DIMENSION(4) :: xcge real, public, DIMENSION(4) :: xcrg real, public, DIMENSION(4) :: xcsg real, public, DIMENSION(4) :: xcgg real, public :: xam_r real, public :: xbm_r real, public :: xmu_r real, public :: xobmr real, public :: xam_s real, public :: xbm_s real, public :: xmu_s real, public :: xoams real, public :: xobms real, public :: xocms real, public :: xam_g real, public :: xbm_g real, public :: xmu_g real, public :: xoamg real, public :: xobmg real, public :: xocmg real, public :: xorg2 real, public :: xosg2 real, public :: xogg2 integer, public, parameter :: slen = 20 character(len=slen), public :: mixingrulestring_s character(len=slen), public :: matrixstring_s character(len=slen), public :: inclusionstring_s character(len=slen), public :: hoststring_s character(len=slen), public :: hostmatrixstring_s character(len=slen), public :: hostinclusionstring_s character(len=slen), public :: mixingrulestring_g character(len=slen), public :: matrixstring_g character(len=slen), public :: inclusionstring_g character(len=slen), public :: hoststring_g character(len=slen), public :: hostmatrixstring_g character(len=slen), public :: hostinclusionstring_g double precision, public, parameter :: melt_outside_s = 0.9d0 Single melting snow/graupel particle 90% meltwater on external sfc double precision, public, parameter :: melt_outside_g = 0.9d0 Subroutines public  subroutine radar_init () \\ingroup thompson_radar Arguments None public  subroutine rayleigh_soak_wetgraupel (x_g, a_geo, b_geo, fmelt, meltratio_outside, m_w, m_i, lambda, C_back, mixingrule, matrix, inclusion, host, hostmatrix, hostinclusion) ingroup thompson_radar Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x_g double precision, intent(in) :: a_geo double precision, intent(in) :: b_geo double precision, intent(in) :: fmelt double precision, intent(in) :: meltratio_outside complex(kind=16), intent(in) :: m_w complex(kind=16), intent(in) :: m_i double precision, intent(in) :: lambda double precision, intent(out) :: C_back character(len=*), intent(in) :: mixingrule character(len=*), intent(in) :: matrix character(len=*), intent(in) :: inclusion character(len=*), intent(in) :: host character(len=*), intent(in) :: hostmatrix character(len=*), intent(in) :: hostinclusion","tags":"","url":"module/module_mp_radar.html"},{"title":"machine – TEMPO Microphysics","text":"This module sets the precision used for TEMPO microphysics Used by module~~machine~~UsedByGraph module~machine machine module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_params->module~machine module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_tempo_diags->module~module_mp_tempo_params module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_params module~module_mp_tempo_driver->module~module_mp_tempo_diags module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_driver->module~module_mp_tempo_main module~module_mp_tempo_ml module_mp_tempo_ml module~module_mp_tempo_driver->module~module_mp_tempo_ml module~module_mp_tempo_init module_mp_tempo_init module~module_mp_tempo_init->module~module_mp_tempo_params module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_init->module~module_mp_tempo_utils module~module_mp_tempo_main->module~module_mp_tempo_params module~module_mp_tempo_main->module~module_mp_tempo_utils module~module_mp_tempo_ml->module~module_mp_tempo_params module~module_mp_tempo_utils->module~module_mp_tempo_params proc~compute_efrw compute_efrw proc~compute_efrw->module~module_mp_tempo_params proc~compute_efsw compute_efsw proc~compute_efsw->module~module_mp_tempo_params proc~get_nuc get_nuc proc~get_nuc->module~module_mp_tempo_params proc~snow_moments snow_moments proc~snow_moments->module~module_mp_tempo_params proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->module~module_mp_tempo_params proc~tempo_init tempo_init proc~tempo_init->module~module_mp_tempo_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: kind_sngl_prec = 4 integer, public, parameter :: kind_dbl_prec = 8 integer, public, parameter :: kind_phys = kind_dbl_prec integer, public, parameter :: kind_io8 = kind_phys","tags":"","url":"module/machine.html"},{"title":"module_mp_tempo_driver – TEMPO Microphysics","text":"Uses module_mp_tempo_diags module_mp_tempo_ml module_mp_tempo_params module_mp_tempo_main module~~module_mp_tempo_driver~~UsesGraph module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_tempo_driver->module~module_mp_tempo_diags module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_driver->module~module_mp_tempo_main module~module_mp_tempo_ml module_mp_tempo_ml module~module_mp_tempo_driver->module~module_mp_tempo_ml module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_driver->module~module_mp_tempo_params module~module_mp_tempo_diags->module~module_mp_tempo_params module~module_mp_radar module_mp_radar module~module_mp_tempo_diags->module~module_mp_radar module~module_mp_tempo_main->module~module_mp_tempo_params module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_main->module~module_mp_tempo_utils module~module_mp_tempo_ml->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types module~module_mp_tempo_utils->module~module_mp_tempo_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine tempo_3d_to_1d_driver (qv, qc, qr, qi, qs, qg, qb, ni, nr, nc, ng, nwfa, nifa, nwfa2d, nifa2d, th, pii, p, w, dz, dt_in, itimestep, rainnc, rainncv, snownc, snowncv, graupelnc, graupelncv, sr, frainnc, refl_10cm, diagflag, do_radar_ref, re_cloud, re_ice, re_snow, qcbl, cldfrac, has_reqc, has_reqi, has_reqs, ntc, muc, rainprod, evapprod, max_hail_diameter_column, max_hail_diameter_sfc, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte) ! K LOOP                enddo Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qv real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qc real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qr real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qi real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qs real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: qg real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: qb real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: ni real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: nr real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nc real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: ng real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nwfa real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: nifa real, intent(in), optional, dimension(ims:ime, jms:jme) :: nwfa2d real, intent(in), optional, dimension(ims:ime, jms:jme) :: nifa2d real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: th real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: pii real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: p real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: w real, intent(in), dimension(ims:ime, kms:kme, jms:jme) :: dz real, intent(in) :: dt_in integer, intent(in) :: itimestep real, intent(inout), dimension(ims:ime, jms:jme) :: rainnc real, intent(inout), dimension(ims:ime, jms:jme) :: rainncv real, intent(inout), optional, dimension(ims:ime, jms:jme) :: snownc real, intent(inout), optional, dimension(ims:ime, jms:jme) :: snowncv real, intent(inout), optional, dimension(ims:ime, jms:jme) :: graupelnc real, intent(inout), optional, dimension(ims:ime, jms:jme) :: graupelncv real, intent(inout), dimension(ims:ime, jms:jme) :: sr real, intent(inout), optional, dimension(ims:ime,jms:jme) :: frainnc real, intent(inout), optional, dimension(ims:ime, kms:kme, jms:jme) :: refl_10cm logical, intent(in), optional :: diagflag integer, intent(in), optional :: do_radar_ref real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_cloud real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_ice real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: re_snow real, intent(in), optional, dimension(ims:ime, kms:kme, jms:jme) :: qcbl real, intent(in), optional, dimension(ims:ime, kms:kme, jms:jme) :: cldfrac integer, intent(in) :: has_reqc integer, intent(in) :: has_reqi integer, intent(in) :: has_reqs real, intent(in), optional, dimension(ims:ime, jms:jme) :: ntc real, intent(in), optional, dimension(ims:ime, jms:jme) :: muc real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: rainprod real, intent(inout), dimension(ims:ime, kms:kme, jms:jme) :: evapprod real, intent(inout), optional, dimension(ims:ime,jms:jme) :: max_hail_diameter_column real, intent(inout), optional, dimension(ims:ime,jms:jme) :: max_hail_diameter_sfc integer, intent(in) :: ids integer, intent(in) :: ide integer, intent(in) :: jds integer, intent(in) :: jde integer, intent(in) :: kds integer, intent(in) :: kde integer, intent(in) :: ims integer, intent(in) :: ime integer, intent(in) :: jms integer, intent(in) :: jme integer, intent(in) :: kms integer, intent(in) :: kme integer, intent(in) :: its integer, intent(in) :: ite integer, intent(in) :: jts integer, intent(in) :: jte integer, intent(in) :: kts integer, intent(in) :: kte","tags":"","url":"module/module_mp_tempo_driver.html"},{"title":"module_mp_tempo_main – TEMPO Microphysics","text":"Uses module_mp_tempo_params module_mp_tempo_utils module~~module_mp_tempo_main~~UsesGraph module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_main->module~module_mp_tempo_params module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_main->module~module_mp_tempo_utils iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types module~module_mp_tempo_utils->module~module_mp_tempo_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_mp_tempo_main~~UsedByGraph module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mp_tempo_main (qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, qb1d, ni1d, nr1d, nc1d, ng1d, nwfa1d, nifa1d, t1d, p1d, w1d, dzq, pptrain, pptsnow, pptgraul, pptice, ext_diag, sedi_semi, prw_vcdc1, prw_vcde1, tpri_inu1, tpri_ide1_d, tpri_ide1_s, tprs_ide1, tprs_sde1_d, tprs_sde1_s, tprg_gde1_d, tprg_gde1_s, tpri_iha1, tpri_wfz1, tpri_rfz1, tprg_rfz1, tprs_scw1, tprg_scw1, tprg_rcs1, tprs_rcs1, tprr_rci1, tprg_rcg1, tprw_vcd1_c, tprw_vcd1_e, tprr_sml1, tprr_gml1, tprr_rcg1, tprr_rcs1, tprv_rev1, tten1, qvten1, qrten1, qsten1, qgten1, qiten1, niten1, nrten1, ncten1, qcten1, decfl, pfil1, pfll1, lsml, rand1, rand2, rand3, kts, kte, dt, ii, jj) ! #if defined(mpas)\n configs) Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(kts:kte) :: qv1d real(kind=wp), intent(inout), dimension(kts:kte) :: qc1d real(kind=wp), intent(inout), dimension(kts:kte) :: qi1d real(kind=wp), intent(inout), dimension(kts:kte) :: qr1d real(kind=wp), intent(inout), dimension(kts:kte) :: qs1d real(kind=wp), intent(inout), dimension(kts:kte) :: qg1d real(kind=wp), intent(inout), dimension(kts:kte) :: qb1d real(kind=wp), intent(inout), dimension(kts:kte) :: ni1d real(kind=wp), intent(inout), dimension(kts:kte) :: nr1d real(kind=wp), intent(inout), dimension(kts:kte) :: nc1d real(kind=wp), intent(inout), dimension(kts:kte) :: ng1d real(kind=wp), intent(inout), dimension(kts:kte) :: nwfa1d real(kind=wp), intent(inout), dimension(kts:kte) :: nifa1d real(kind=wp), intent(inout), dimension(kts:kte) :: t1d real(kind=wp), intent(in), dimension(kts:kte) :: p1d real(kind=wp), intent(in), dimension(kts:kte) :: w1d real(kind=wp), intent(in), dimension(kts:kte) :: dzq real(kind=wp), intent(inout) :: pptrain real(kind=wp), intent(inout) :: pptsnow real(kind=wp), intent(inout) :: pptgraul real(kind=wp), intent(inout) :: pptice logical, intent(in) :: ext_diag logical, intent(in) :: sedi_semi real(kind=wp), intent(out), optional, dimension(:) :: prw_vcdc1 real(kind=wp), intent(out), optional, dimension(:) :: prw_vcde1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_inu1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_ide1_d real(kind=wp), intent(out), optional, dimension(:) :: tpri_ide1_s real(kind=wp), intent(out), optional, dimension(:) :: tprs_ide1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_sde1_d real(kind=wp), intent(out), optional, dimension(:) :: tprs_sde1_s real(kind=wp), intent(out), optional, dimension(:) :: tprg_gde1_d real(kind=wp), intent(out), optional, dimension(:) :: tprg_gde1_s real(kind=wp), intent(out), optional, dimension(:) :: tpri_iha1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_wfz1 real(kind=wp), intent(out), optional, dimension(:) :: tpri_rfz1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rfz1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_scw1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_scw1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprs_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rci1 real(kind=wp), intent(out), optional, dimension(:) :: tprg_rcg1 real(kind=wp), intent(out), optional, dimension(:) :: tprw_vcd1_c real(kind=wp), intent(out), optional, dimension(:) :: tprw_vcd1_e real(kind=wp), intent(out), optional, dimension(:) :: tprr_sml1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_gml1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rcg1 real(kind=wp), intent(out), optional, dimension(:) :: tprr_rcs1 real(kind=wp), intent(out), optional, dimension(:) :: tprv_rev1 real(kind=wp), intent(out), optional, dimension(:) :: tten1 real(kind=wp), intent(out), optional, dimension(:) :: qvten1 real(kind=wp), intent(out), optional, dimension(:) :: qrten1 real(kind=wp), intent(out), optional, dimension(:) :: qsten1 real(kind=wp), intent(out), optional, dimension(:) :: qgten1 real(kind=wp), intent(out), optional, dimension(:) :: qiten1 real(kind=wp), intent(out), optional, dimension(:) :: niten1 real(kind=wp), intent(out), optional, dimension(:) :: nrten1 real(kind=wp), intent(out), optional, dimension(:) :: ncten1 real(kind=wp), intent(out), optional, dimension(:) :: qcten1 integer, intent(in), optional :: decfl real(kind=wp), intent(out), optional, dimension(kts:kte) :: pfil1 real(kind=wp), intent(out), optional, dimension(kts:kte) :: pfll1 integer, intent(in), optional :: lsml real(kind=wp), intent(in), optional :: rand1 real(kind=wp), intent(in), optional :: rand2 real(kind=wp), intent(in), optional :: rand3 integer, intent(in) :: kts integer, intent(in) :: kte real(kind=wp), intent(in) :: dt type(ty_tempo_cfg), intent(in) :: configs integer, intent(in) :: ii integer, intent(in) :: jj","tags":"","url":"module/module_mp_tempo_main.html"},{"title":"module_mp_tempo_init – TEMPO Microphysics","text":"initialize variables for tempo microphysics\nincludes a procedure to build and save lookup tables Uses mpi_f08 module_mp_tempo_params module_mp_tempo_utils module~~module_mp_tempo_init~~UsesGraph module~module_mp_tempo_init module_mp_tempo_init module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_init->module~module_mp_tempo_params module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_init->module~module_mp_tempo_utils mpi_f08 mpi_f08 module~module_mp_tempo_init->mpi_f08 iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types module~module_mp_tempo_utils->module~module_mp_tempo_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine tempo_init (aerosolaware_flag, hailaware_flag, restart_flag) public procedure called to initialize tempo microphysics Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: aerosolaware_flag logical, intent(in), optional :: hailaware_flag logical, intent(in), optional :: restart_flag public  subroutine tempo_build_tables (build_tables_rank, build_tables_num_proc) public procedure to build 3 lookup tables for tempo microphysics Arguments Type Intent Optional Attributes Name integer, intent(in) :: build_tables_rank integer, intent(in) :: build_tables_num_proc public  subroutine compute_efrw () collision efficiency for rain collecting cloud water from Beard and Grover (1974)\nif a/A < 0.25, otherwise uses polynomials to get close match of Pruppacher & Klett Fig. 14-9 Arguments None public  subroutine compute_efsw () collision efficiency for snow collecting cloud water from Wang and Ji (2000) except\nequate melted snow diameter to their \"effective collision cross-section.\" Arguments None","tags":"","url":"module/module_mp_tempo_init.html"},{"title":"module_mp_tempo_diags – TEMPO Microphysics","text":"utilities for tempo microphysics Uses module_mp_radar module_mp_tempo_params module~~module_mp_tempo_diags~~UsesGraph module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_radar module_mp_radar module~module_mp_tempo_diags->module~module_mp_radar module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_diags->module~module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_mp_tempo_diags~~UsedByGraph module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_diags Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine calc_effectRad (t1d, p1d, qv1d, qc1d, nc1d, qi1d, ni1d, qs1d, re_qc1d, re_qi1d, re_qs1d, kts, kte, lsml) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(kts:kte) :: t1d real, intent(in), DIMENSION(kts:kte) :: p1d real, intent(in), DIMENSION(kts:kte) :: qv1d real, intent(in), DIMENSION(kts:kte) :: qc1d real, intent(in), DIMENSION(kts:kte) :: nc1d real, intent(in), DIMENSION(kts:kte) :: qi1d real, intent(in), DIMENSION(kts:kte) :: ni1d real, intent(in), DIMENSION(kts:kte) :: qs1d real, intent(inout), DIMENSION(kts:kte) :: re_qc1d real, intent(inout), DIMENSION(kts:kte) :: re_qi1d real, intent(inout), DIMENSION(kts:kte) :: re_qs1d integer, intent(in) :: kts integer, intent(in) :: kte integer, intent(in), optional :: lsml public  subroutine calc_refl10cm (qv1d, qc1d, qr1d, nr1d, qs1d, qg1d, ng1d, qb1d, t1d, p1d, dBZ, kts, kte, ii, jj, rand1, melti, vt_dBZ, first_time_step) Arguments Type Intent Optional Attributes Name real, intent(in), DIMENSION(kts:kte) :: qv1d real, intent(in), DIMENSION(kts:kte) :: qc1d real, intent(in), DIMENSION(kts:kte) :: qr1d real, intent(in), DIMENSION(kts:kte) :: nr1d real, intent(in), DIMENSION(kts:kte) :: qs1d real, intent(in), DIMENSION(kts:kte) :: qg1d real, intent(in), DIMENSION(kts:kte) :: ng1d real, intent(in), DIMENSION(kts:kte) :: qb1d real, intent(in), DIMENSION(kts:kte) :: t1d real, intent(in), DIMENSION(kts:kte) :: p1d real, intent(inout), DIMENSION(kts:kte) :: dBZ integer, intent(in) :: kts integer, intent(in) :: kte integer, intent(in) :: ii integer, intent(in) :: jj real, intent(in), optional :: rand1 logical, intent(in), optional :: melti real, intent(inout), optional, DIMENSION(kts:kte) :: vt_dBZ logical, intent(in), optional :: first_time_step public  subroutine hail_size_diagnostics (kts, kte, qg1d, ng1d, qb1d, t1d, p1d, qv1d, qg_max_diam1d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: kts integer, intent(in) :: kte real(kind=wp), intent(in), dimension(kts:kte) :: qg1d real(kind=wp), intent(in), dimension(kts:kte) :: ng1d real(kind=wp), intent(in), dimension(kts:kte) :: qb1d real(kind=wp), intent(in), dimension(kts:kte) :: t1d real(kind=wp), intent(in), dimension(kts:kte) :: p1d real(kind=wp), intent(in), dimension(kts:kte) :: qv1d real(kind=wp), intent(out), dimension(kts:kte) :: qg_max_diam1d","tags":"","url":"module/module_mp_tempo_diags.html"},{"title":"module_mp_tempo_params – TEMPO Microphysics","text":"parameters and variables used in tempo microphysics Uses machine iso_fortran_env mpas_kind_types module~~module_mp_tempo_params~~UsesGraph module~module_mp_tempo_params module_mp_tempo_params iso_fortran_env iso_fortran_env module~module_mp_tempo_params->iso_fortran_env module~machine machine module~module_mp_tempo_params->module~machine mpas_kind_types mpas_kind_types module~module_mp_tempo_params->mpas_kind_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_mp_tempo_params~~UsedByGraph module~module_mp_tempo_params module_mp_tempo_params module~module_mp_tempo_diags module_mp_tempo_diags module~module_mp_tempo_diags->module~module_mp_tempo_params module~module_mp_tempo_driver module_mp_tempo_driver module~module_mp_tempo_driver->module~module_mp_tempo_params module~module_mp_tempo_driver->module~module_mp_tempo_diags module~module_mp_tempo_main module_mp_tempo_main module~module_mp_tempo_driver->module~module_mp_tempo_main module~module_mp_tempo_ml module_mp_tempo_ml module~module_mp_tempo_driver->module~module_mp_tempo_ml module~module_mp_tempo_init module_mp_tempo_init module~module_mp_tempo_init->module~module_mp_tempo_params module~module_mp_tempo_utils module_mp_tempo_utils module~module_mp_tempo_init->module~module_mp_tempo_utils module~module_mp_tempo_main->module~module_mp_tempo_params module~module_mp_tempo_main->module~module_mp_tempo_utils module~module_mp_tempo_ml->module~module_mp_tempo_params module~module_mp_tempo_utils->module~module_mp_tempo_params proc~compute_efrw compute_efrw proc~compute_efrw->module~module_mp_tempo_params proc~compute_efsw compute_efsw proc~compute_efsw->module~module_mp_tempo_params proc~get_nuc get_nuc proc~get_nuc->module~module_mp_tempo_params proc~snow_moments snow_moments proc~snow_moments->module~module_mp_tempo_params proc~tempo_build_tables tempo_build_tables proc~tempo_build_tables->module~module_mp_tempo_params proc~tempo_init tempo_init proc~tempo_init->module~module_mp_tempo_params Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=11), public :: tempo_version tempo version string (max is xxx.xxx.xxx) type( ty_tempo_init_cfgs ), public :: tempo_init_cfgs type( ty_tempo_driver_cfgs ), public :: tempo_driver_cfgs type( ty_tempo_table_cfgs ), public :: tempo_table_cfgs integer, public, parameter :: idx_bg1 = 6 index from rho_g when hail_aware = false: density = 500 real(kind=wp), public, parameter :: av_r = 4854._wp rain fallspeed power-law coefficient real(kind=wp), public, parameter :: bv_r = 1.0_wp rain fallspeed power-law coefficient Note fallspeed power law relations are and coefficients are from from Ferrier (1994) for rain and \nThompson et al. (2008) for ice, snow, and graupel real(kind=wp), public, parameter :: av_s = 40._wp snow fallspeed power-law coefficient real(kind=wp), public, parameter :: bv_s = 0.55_wp snow fallspeed power-law coefficient real(kind=wp), public, parameter :: fv_s = 100._wp snow fallspeed power-law coefficient real(kind=wp), public, parameter :: bv_c = 2.0_wp cloud fallspeed power-law coefficient real(kind=wp), public, parameter :: bv_i = 1.0_wp ice fallspeed power-law coefficient real(kind=wp), public, parameter :: av_g_old = 442._wp graupel fallspeed power-law coefficient (hail_aware = false) real(kind=wp), public, parameter :: bv_g_old = 0.89_wp graupel fallspeed power-law coefficient (hail_aware = false) real(kind=wp), public, parameter :: am_s = 0.069_wp snow mass power-law coefficient real(kind=wp), public, parameter :: bm_s = 2.0_wp snow mass power-law coefficient Note mass power law relations are and coefficients for snow are from Field et al. (2005) and \nothers assume a spherical form real(kind=wp), public, parameter :: bm_g = 3.0_wp graupel mass power-law coefficient real(kind=wp), public, parameter :: bm_i = 3.0_wp ice mass power-law coefficient real(kind=wp), public, parameter :: bm_r = 3.0_wp rain mass power-law coefficient real(kind=wp), public, parameter :: rho_i = 890._wp density of cloud ice real(kind=wp), public, parameter :: xm0i = 1.e-12_wp ice initiates with this mass real(kind=wp), public, parameter :: d0c = 1.e-6_wp minimum diameter of cloud droplets real(kind=wp), public, parameter :: d0r = 50.e-6_wp minimum diameter of raindrops real(kind=wp), public, parameter :: d0s = 300.e-6_wp minimum diameter of snow real(kind=wp), public, parameter :: d0g = 350.e-6_wp minimum diameter of graupel real(kind=wp), public, parameter :: c_cube = 0.5_wp capacitance of a sphere real(kind=wp), public, parameter :: c_sqrd = 0.15_wp capacitance of plates/aggregates real(kind=wp), public, parameter :: mu_r = 0.0_wp shape parameter for rain real(kind=wp), public, parameter :: mu_s = 0.6357_wp shape parameter for snow real(kind=wp), public, parameter :: mu_g = 0.0_wp shape parameter for graupel real(kind=wp), public, parameter :: mu_i = 0.0_wp shape parameter for cloud ice Note generalized gamma distributions for rain, graupel and cloud ice have the form real(kind=wp), public, parameter :: nu_c_scale = 1000.e6_wp scaling parameter for nu_c integer, public, parameter :: nu_c_max = 15 maximum value for nu_c integer, public, parameter :: nu_c_min = 2 minimum value for nu_c integer, public, parameter :: table_sp = real32 precision for lookup tables (machine independent) integer, public, parameter :: table_dp = real64 precision for lookup tables (machine independent) integer, public, parameter :: nrhg = 9 graupel density array size when hail_aware = true integer, public, parameter :: nrhg1 = 1 graupel density array size when hail_aware = false real(kind=wp), public, parameter :: rho_w = 1000._wp density of liquid water real(kind=wp), public, parameter,               dimension(nrhg) :: rho_g = [50._wp, 100._wp, 200._wp, 300._wp, 400._wp, 500._wp, 600._wp, 700._wp, 800._wp] !! densities of graupel when hail_aware = true real(kind=wp), public, parameter :: sc = 0.632_wp schmidt number real(kind=wp), public :: pi = 3.1415926536_wp pi is approximately 355/113 real(kind=wp), public :: lsub = 2.834e6_wp enthalpy of sublimation real(kind=wp), public :: lvap0 = 2.5e6_wp enthalpy of vaporization real(kind=wp), public :: rv = 461.5_wp gas constant for water vapor real(kind=wp), public :: r = 287.04_wp gas constant for dry air integer, public, parameter :: nbins = 100 lookup table dimension (number of bins) integer, public, parameter :: nbc = nbins lookup table dimension for cloud water integer, public, parameter :: nbr = nbins lookup table dimension for rain integer, public, parameter :: nbs = nbins lookup table dimension for snow integer, public, parameter :: nbi = nbins lookup table dimension integer, public, parameter :: nbg = nbins lookup table dimension integer, public, parameter :: ntb_i = 64 lookup table dimension for cloud ice integer, public, parameter :: ntb_i1 = 55 lookup table dimension for cloud ice integer, public, parameter :: ntb_c = 37 lookup table dimension for cloud water integer, public, parameter :: ntb_t = 9 lookup table dimension for temperature integer, public, parameter :: ntb_g1 = 37 lookup table dimension for graupel integer, public, parameter :: ntb_s = 37 lookup table dimension for snow integer, public, parameter :: ntb_g = 37 lookup table dimension for graupel integer, public, parameter :: ntb_r = 37 lookup table dimension for rain integer, public, parameter :: ntb_r1 = 37 lookup table dimension for rain integer, public, parameter :: ntb_t1 = 45 lookup table dimension for temperature integer, public, parameter :: ntb_in = 55 lookup table dimension for IN integer, public, parameter :: ntb_arc = 7 lookup table dimension for CCN activation integer, public, parameter :: ntb_arw = 9 lookup table dimension for CCN activation integer, public, parameter :: ntb_art = 7 lookup table dimension for CCN activation integer, public, parameter :: ntb_arr = 5 lookup table dimension for CCN activation integer, public, parameter :: ntb_ark = 4 lookup table dimension for CCN activation real(kind=wp), public, parameter,               dimension(ntb_c) :: r_c = [1.e-6_wp, 2.e-6_wp, 3.e-6_wp, 4.e-6_wp, 5.e-6_wp, 6.e-6_wp, 7.e-6_wp, 8.e-6_wp, 9.e-6_wp, 1.e-5_wp, 2.e-5_wp, 3.e-5_wp, 4.e-5_wp, 5.e-5_wp, 6.e-5_wp, 7.e-5_wp, 8.e-5_wp, 9.e-5_wp, 1.e-4_wp, 2.e-4_wp, 3.e-4_wp, 4.e-4_wp, 5.e-4_wp, 6.e-4_wp, 7.e-4_wp, 8.e-4_wp, 9.e-4_wp, 1.e-3_wp, 2.e-3_wp, 3.e-3_wp, 4.e-3_wp, 5.e-3_wp, 6.e-3_wp, 7.e-3_wp, 8.e-3_wp, 9.e-3_wp, 1.e-2_wp] mass bins for cloud water real(kind=wp), public, parameter,               dimension(ntb_i) :: r_i = [1.e-10_wp, 2.e-10_wp, 3.e-10_wp, 4.e-10_wp, 5.e-10_wp, 6.e-10_wp, 7.e-10_wp, 8.e-10_wp, 9.e-10_wp, 1.e-9_wp, 2.e-9_wp, 3.e-9_wp, 4.e-9_wp, 5.e-9_wp, 6.e-9_wp, 7.e-9_wp, 8.e-9_wp, 9.e-9_wp, 1.e-8_wp, 2.e-8_wp, 3.e-8_wp, 4.e-8_wp, 5.e-8_wp, 6.e-8_wp, 7.e-8_wp, 8.e-8_wp, 9.e-8_wp, 1.e-7_wp, 2.e-7_wp, 3.e-7_wp, 4.e-7_wp, 5.e-7_wp, 6.e-7_wp, 7.e-7_wp, 8.e-7_wp, 9.e-7_wp, 1.e-6_wp, 2.e-6_wp, 3.e-6_wp, 4.e-6_wp, 5.e-6_wp, 6.e-6_wp, 7.e-6_wp, 8.e-6_wp, 9.e-6_wp, 1.e-5_wp, 2.e-5_wp, 3.e-5_wp, 4.e-5_wp, 5.e-5_wp, 6.e-5_wp, 7.e-5_wp, 8.e-5_wp, 9.e-5_wp, 1.e-4_wp, 2.e-4_wp, 3.e-4_wp, 4.e-4_wp, 5.e-4_wp, 6.e-4_wp, 7.e-4_wp, 8.e-4_wp, 9.e-4_wp, 1.e-3_wp] mass bins for ice water real(kind=wp), public, parameter,               dimension(ntb_r) :: r_r = [1.e-6_wp, 2.e-6_wp, 3.e-6_wp, 4.e-6_wp, 5.e-6_wp, 6.e-6_wp, 7.e-6_wp, 8.e-6_wp, 9.e-6_wp, 1.e-5_wp, 2.e-5_wp, 3.e-5_wp, 4.e-5_wp, 5.e-5_wp, 6.e-5_wp, 7.e-5_wp, 8.e-5_wp, 9.e-5_wp, 1.e-4_wp, 2.e-4_wp, 3.e-4_wp, 4.e-4_wp, 5.e-4_wp, 6.e-4_wp, 7.e-4_wp, 8.e-4_wp, 9.e-4_wp, 1.e-3_wp, 2.e-3_wp, 3.e-3_wp, 4.e-3_wp, 5.e-3_wp, 6.e-3_wp, 7.e-3_wp, 8.e-3_wp, 9.e-3_wp, 1.e-2_wp] mass bins for rain real(kind=wp), public, parameter,               dimension(ntb_s) :: r_s = [1.e-6_wp, 2.e-6_wp, 3.e-6_wp, 4.e-6_wp, 5.e-6_wp, 6.e-6_wp, 7.e-6_wp, 8.e-6_wp, 9.e-6_wp, 1.e-5_wp, 2.e-5_wp, 3.e-5_wp, 4.e-5_wp, 5.e-5_wp, 6.e-5_wp, 7.e-5_wp, 8.e-5_wp, 9.e-5_wp, 1.e-4_wp, 2.e-4_wp, 3.e-4_wp, 4.e-4_wp, 5.e-4_wp, 6.e-4_wp, 7.e-4_wp, 8.e-4_wp, 9.e-4_wp, 1.e-3_wp, 2.e-3_wp, 3.e-3_wp, 4.e-3_wp, 5.e-3_wp, 6.e-3_wp, 7.e-3_wp, 8.e-3_wp, 9.e-3_wp, 1.e-2_wp] mass bins for snow real(kind=wp), public, parameter,               dimension(ntb_g) :: r_g = [1.e-6_wp, 2.e-6_wp, 3.e-6_wp, 4.e-6_wp, 5.e-6_wp, 6.e-6_wp, 7.e-6_wp, 8.e-6_wp, 9.e-6_wp, 1.e-5_wp, 2.e-5_wp, 3.e-5_wp, 4.e-5_wp, 5.e-5_wp, 6.e-5_wp, 7.e-5_wp, 8.e-5_wp, 9.e-5_wp, 1.e-4_wp, 2.e-4_wp, 3.e-4_wp, 4.e-4_wp, 5.e-4_wp, 6.e-4_wp, 7.e-4_wp, 8.e-4_wp, 9.e-4_wp, 1.e-3_wp, 2.e-3_wp, 3.e-3_wp, 4.e-3_wp, 5.e-3_wp, 6.e-3_wp, 7.e-3_wp, 8.e-3_wp, 9.e-3_wp, 1.e-2_wp] mass bins for graupel real(kind=wp), public, parameter,               dimension(ntb_r1) :: n0r_exp = [1.e6_wp, 2.e6_wp, 3.e6_wp, 4.e6_wp, 5.e6_wp, 6.e6_wp, 7.e6_wp, 8.e6_wp, 9.e6_wp, 1.e7_wp, 2.e7_wp, 3.e7_wp, 4.e7_wp, 5.e7_wp, 6.e7_wp, 7.e7_wp, 8.e7_wp, 9.e7_wp, 1.e8_wp, 2.e8_wp, 3.e8_wp, 4.e8_wp, 5.e8_wp, 6.e8_wp, 7.e8_wp, 8.e8_wp, 9.e8_wp, 1.e9_wp, 2.e9_wp, 3.e9_wp, 4.e9_wp, 5.e9_wp, 6.e9_wp, 7.e9_wp, 8.e9_wp, 9.e9_wp, 1.e10_wp] y-intercept bins for rain real(kind=wp), public, parameter,               dimension(ntb_g1) :: n0g_exp = [1.e2_wp, 2.e2_wp, 3.e2_wp, 4.e2_wp, 5.e2_wp, 6.e2_wp, 7.e2_wp, 8.e2_wp, 9.e2_wp, 1.e3_wp, 2.e3_wp, 3.e3_wp, 4.e3_wp, 5.e3_wp, 6.e3_wp, 7.e3_wp, 8.e3_wp, 9.e3_wp, 1.e4_wp, 2.e4_wp, 3.e4_wp, 4.e4_wp, 5.e4_wp, 6.e4_wp, 7.e4_wp, 8.e4_wp, 9.e4_wp, 1.e5_wp, 2.e5_wp, 3.e5_wp, 4.e5_wp, 5.e5_wp, 6.e5_wp, 7.e5_wp, 8.e5_wp, 9.e5_wp, 1.e6_wp] y-intercept bins for graupel real(kind=wp), public, parameter,               dimension(ntb_i1) :: nt_i = [1.0_wp, 2.0_wp, 3.0_wp, 4.0_wp, 5.0_wp, 6.0_wp, 7.0_wp, 8.0_wp, 9.0_wp, 1.e1_wp, 2.e1_wp, 3.e1_wp, 4.e1_wp, 5.e1_wp, 6.e1_wp, 7.e1_wp, 8.e1_wp, 9.e1_wp, 1.e2_wp, 2.e2_wp, 3.e2_wp, 4.e2_wp, 5.e2_wp, 6.e2_wp, 7.e2_wp, 8.e2_wp, 9.e2_wp, 1.e3_wp, 2.e3_wp, 3.e3_wp, 4.e3_wp, 5.e3_wp, 6.e3_wp, 7.e3_wp, 8.e3_wp, 9.e3_wp, 1.e4_wp, 2.e4_wp, 3.e4_wp, 4.e4_wp, 5.e4_wp, 6.e4_wp, 7.e4_wp, 8.e4_wp, 9.e4_wp, 1.e5_wp, 2.e5_wp, 3.e5_wp, 4.e5_wp, 5.e5_wp, 6.e5_wp, 7.e5_wp, 8.e5_wp, 9.e5_wp, 1.e6_wp] number bins for ice real(kind=wp), public, parameter,               dimension(ntb_in) :: nt_in = [1.0_wp, 2.0_wp, 3.0_wp, 4.0_wp, 5.0_wp, 6.0_wp, 7.0_wp, 8.0_wp, 9.0_wp, 1.e1_wp, 2.e1_wp, 3.e1_wp, 4.e1_wp, 5.e1_wp, 6.e1_wp, 7.e1_wp, 8.e1_wp, 9.e1_wp, 1.e2_wp, 2.e2_wp, 3.e2_wp, 4.e2_wp, 5.e2_wp, 6.e2_wp, 7.e2_wp, 8.e2_wp, 9.e2_wp, 1.e3_wp, 2.e3_wp, 3.e3_wp, 4.e3_wp, 5.e3_wp, 6.e3_wp, 7.e3_wp, 8.e3_wp, 9.e3_wp, 1.e4_wp, 2.e4_wp, 3.e4_wp, 4.e4_wp, 5.e4_wp, 6.e4_wp, 7.e4_wp, 8.e4_wp, 9.e4_wp, 1.e5_wp, 2.e5_wp, 3.e5_wp, 4.e5_wp, 5.e5_wp, 6.e5_wp, 7.e5_wp, 8.e5_wp, 9.e5_wp, 1.e6_wp] number bins for IN concentration from integer, public :: dim_nrhg number of dimensions for graupel density real(kind=wp), public, dimension(nrhg) :: av_g = [45.9173813_wp, 67.0867386_wp, 98.0158463_wp, 122.353378_wp, 143.204224_wp, 161.794724_wp, 178.762115_wp, 194.488785_wp, 209.225876_wp] graupel fallspeed power-law coefficients (hail_aware = true) real(kind=wp), public, dimension(nrhg) :: bv_g = [0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp, 0.640961647_wp] graupel fallspeed power-law coefficients (hail_aware = true) Note av_g and bv_g values from A. Heymsfield: Best - Reynolds relationship real(kind=wp), public :: am_i ice mass-diameter power-law coefficient real(kind=wp), public :: am_r rain mass-diameter power-law coefficient real(kind=wp), public, dimension (nrhg) :: am_g graupel mass-diameter power-law coefficient real(kind=wp), public :: lfus enthalpy of fusion real(kind=wp), public :: olfus 1 / lfus real(kind=wp), public :: orv 1 / rv real(kind=wp), public :: sc3 schmidt number to the 1/3 power real(kind=wp), public :: d0i minimum diameter of cloud ice real(kind=wp), public :: xm0s minimum mass of snow real(kind=wp), public :: xm0g minimum mass of graupel real(kind=wp), public :: obmi 1 / bm_i real(kind=wp), public :: obmr 1 / bm_r real(kind=wp), public :: oams 1 / am_s real(kind=wp), public :: obms 1 / bm_s real(kind=wp), public :: ocms oams &#94; obms real(kind=wp), public, dimension(nrhg) :: oamg 1 / am_g real(kind=wp), public, dimension(nrhg) :: ocmg oamg &#94; obmg real(kind=wp), public :: obmg 1 / bm_g real(kind=wp), public, dimension(5,15) :: cce for , cce is x for cloud water real(kind=wp), public, dimension(5,15) :: ccg for , cce is x for cloud water real(kind=wp), public, dimension(15) :: ocg1 inverse of specific ccg values real(kind=wp), public, dimension(15) :: ocg2 inverse of specific ccg values real(kind=wp), public, dimension(7) :: cie for , cie is x for cloud ice real(kind=wp), public, dimension(7) :: cig for , cie is x for cloud ice real(kind=wp), public :: oig1 inverse of specific cig values real(kind=wp), public :: oig2 inverse of specific cig values real(kind=wp), public, dimension(13) :: cre for , cre is x for rain real(kind=wp), public, dimension(13) :: crg for , cre is x for rain real(kind=wp), public :: ore1 inverse of specific cre and crg values real(kind=wp), public :: org1 inverse of specific cre and crg values real(kind=wp), public :: org2 inverse of specific cre and crg values real(kind=wp), public :: org3 inverse of specific cre and crg values real(kind=wp), public, dimension(17) :: cse for , cse is x for snow real(kind=wp), public, dimension(17) :: csg for , cse is x for snow real(kind=wp), public, dimension(12,nrhg) :: cge for , cge is x for graupel real(kind=wp), public, dimension(12,nrhg) :: cgg for , cge is x for graupel real(kind=wp), public :: oge1 inverse of specific cge and cgg values real(kind=wp), public :: ogg1 inverse of specific cge and cgg values real(kind=wp), public :: ogg2 inverse of specific cge and cgg values real(kind=wp), public :: ogg3 inverse of specific cge and cgg values real(kind=wp), public :: t1_qr_qc terms for rain collecting cloud water and cloud ice equations real(kind=wp), public :: t1_qr_qi terms for rain collecting cloud water and cloud ice equations real(kind=wp), public :: t2_qr_qi terms for rain collecting cloud water and cloud ice equations real(kind=wp), public :: t1_qs_qc terms for snow collecting cloud water and cloud ice equations real(kind=wp), public :: t1_qs_qi terms for snow collecting cloud water and cloud ice equations real(kind=wp), public :: t1_qr_ev terms for rain evaporation equation real(kind=wp), public :: t2_qr_ev terms for rain evaporation equation real(kind=wp), public :: t1_qs_sd terms for deposition/sublimation of snow equation real(kind=wp), public :: t2_qs_sd terms for deposition/sublimation of snow equation real(kind=wp), public :: t1_qs_me terms for melting snow equation real(kind=wp), public :: t2_qs_me terms for melting snow equation real(kind=wp), public :: t1_qg_sd term for deposition/sublimation of graupel equation real(kind=wp), public :: t1_qg_me term for melting graupel equation integer, public :: nic2 lookup table indexes integer, public :: nii2 lookup table indexes integer, public :: nii3 lookup table indexes integer, public :: nir2 lookup table indexes integer, public :: nir3 lookup table indexes integer, public :: nis2 lookup table indexes integer, public :: nig2 lookup table indexes integer, public :: nig3 lookup table indexes integer, public :: niin2 lookup table indexes integer, public :: nic1 used for cloud droplet number concentration lookup table Bug nic1 should be real(dp) real(kind=dp), public, dimension(nbc) :: dc diameter and bin space for cloud water bins real(kind=dp), public, dimension(nbc) :: dtc diameter and bin space for cloud water bins real(kind=dp), public, dimension(nbi) :: di diameter and bin space for ice bins real(kind=dp), public, dimension(nbi) :: dti diameter and bin space for ice bins real(kind=dp), public, dimension(nbr) :: dr diameter and bin space for rain bins real(kind=dp), public, dimension(nbr) :: dtr diameter and bin space for rain bins real(kind=dp), public, dimension(nbs) :: ds diameter and bin space for snow bins real(kind=dp), public, dimension(nbs) :: dts diameter and bin space for snow bins real(kind=dp), public, dimension(nbg) :: dg diameter and bin space for graupel bins real(kind=dp), public, dimension(nbg) :: dtg diameter and bin space for graupel bins real(kind=dp), public, dimension(nbc) :: t_nc cloud droplet number concentration bins real(kind=dp), public, allocatable, dimension(:,:) :: t_efrw collection efficiency data arrays real(kind=dp), public, allocatable, dimension(:,:) :: t_efsw collection efficiency data arrays real(kind=dp), public, allocatable, dimension(:,:,:) :: tpc_wev evaporation data arrays real(kind=dp), public, allocatable, dimension(:,:,:) :: tnc_wev evaporation data arrays real(kind=table_sp), public, allocatable, dimension(:,:,:,:,:) :: tnccn_act cloud condensation nuclei data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:,:) :: tcg_racg rain-graupel collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:,:) :: tmr_racg rain-graupel collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:,:) :: tcr_gacr rain-graupel collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:,:) :: tnr_racg rain-graupel collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:,:) :: tnr_gacr rain-graupel collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tcs_racs1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tmr_racs1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tcs_racs2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tmr_racs2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tcr_sacr1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tms_sacr1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tcr_sacr2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tms_sacr2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tnr_racs1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tnr_racs2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tnr_sacr1 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tnr_sacr2 rain-snow collection data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tpi_qcfz cloud droplet freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tni_qcfz cloud droplet freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tpi_qrfz rain freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tpg_qrfz rain freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tni_qrfz rain freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:,:,:) :: tnr_qrfz rain freezing data arrays real(kind=table_dp), public, allocatable, dimension(:,:) :: tps_iaus cloud ice depositional growth and conversion to snow data arrays real(kind=table_dp), public, allocatable, dimension(:,:) :: tni_iaus cloud ice depositional growth and conversion to snow data arrays real(kind=table_dp), public, allocatable, dimension(:,:) :: tpi_ide cloud ice depositional growth and conversion to snow data arrays real(kind=wp), public :: RoverRv = 0.622 real(kind=wp), public :: Cp2 = 1004.0 real(kind=wp), public, parameter :: R1 = 1.e-12 real(kind=wp), public, parameter :: R2 = 1.e-6 real(kind=wp), public, parameter :: eps = 1.e-15 logical, public :: merra2_aerosol_aware = .false. logical, public :: sedi_semi = .false. integer, public :: dimNRHG real(kind=wp), public, parameter :: rho_w2 = 1000.0 real(kind=wp), public :: t1_qg_qc real(kind=wp), public :: t2_qg_sd real(kind=wp), public :: t2_qg_me real(kind=wp), public, parameter :: Nt_c_o = 50.e6 real(kind=wp), public, parameter :: Nt_c_l = 100.e6 real(kind=wp), public, parameter :: Nt_c_max = 1999.e6 real(kind=wp), public :: Nt_c real(kind=wp), public :: mu_c real(kind=wp), public :: mu_c_o real(kind=wp), public :: mu_c_l real(kind=wp), public :: min_qv = 1.e-10 real(kind=wp), public, parameter :: demott_nuc_ssati = 0.15 real(kind=wp), public, parameter :: demott_nuc_ssati = 0.25 real(kind=wp), public, parameter :: nwfa_default = 11.1e6 real(kind=wp), public, parameter :: naIN1 = 0.5e6 real(kind=wp), public, parameter :: nifa_default = naIN1*0.01 real(kind=wp), public, parameter :: aero_max = 9999.e6 real(kind=dp), public, parameter :: max_ni = 4999.e3 real(kind=wp), public, parameter :: icenuc_max = 1000.e3 real(kind=wp), public, parameter :: rime_threshold = 2.0 real(kind=wp), public, parameter :: rime_conversion = 0.95 real(kind=wp), public, parameter :: fv_r = 195.0 real(kind=wp), public :: rho_s2 = 100.0 real(kind=wp), public, parameter :: av_c = 0.316946e8 logical, public, parameter :: iiwarm = .false. logical, public, parameter :: dustyIce = .true. logical, public, parameter :: homogIce = .true. integer, public, parameter :: IFDRY = 0 real(kind=wp), public :: T_0 = 273.15 real(kind=wp), public, parameter :: naIN0 = 1.5e6 real(kind=wp), public, parameter :: naCCN0 = 300.0e6 real(kind=wp), public, parameter :: naCCN1 = 50.0e6 real(kind=wp), public, parameter :: Kap0 = 490.6 real(kind=wp), public, parameter :: Kap1 = 17.46 real(kind=wp), public, parameter :: Lam0 = 20.78 real(kind=wp), public, parameter :: Lam1 = 3.29 real(kind=dp), public, parameter :: gonv_min = 1.e2 real(kind=dp), public, parameter :: gonv_max = 1.e6 real(kind=wp), public, parameter :: a_coeff = 0.47244157 real(kind=wp), public, parameter :: b_coeff = 0.54698726 real(kind=wp), public :: av_i real(kind=wp), public, parameter :: av_i = 1493.9 real(kind=wp), public, parameter :: Ef_si = 0.05 real(kind=wp), public, parameter :: Ef_rs = 0.95 real(kind=wp), public, parameter :: Ef_rg = 0.75 real(kind=wp), public, parameter :: Ef_ri = 0.95 real(kind=wp), public, parameter :: TNO = 5.0 real(kind=wp), public, parameter :: ATO = 0.304 real(kind=wp), public, parameter :: rho_not = 101325.0/(287.05*298.0) real(kind=wp), public, parameter :: HGFR = 235.16 real(kind=wp), public :: R_uni = 8.314 real(kind=dp), public :: k_b = 1.38065e-23 real(kind=dp), public :: M_w = 18.01528e-3 real(kind=dp), public :: M_a = 28.96e-3 real(kind=dp), public :: N_avo = 6.022e23 real(kind=dp), public :: ma_w real(kind=wp), public :: ar_volume real(kind=wp), public, parameter,               dimension(ntb_arc) :: ta_Na = (/10.0, 31.6, 100.0, 316.0, 1000.0, 3160.0, 10000.0/) real(kind=wp), public, parameter,               dimension(ntb_arw) :: ta_Ww = (/0.01, 0.0316, 0.1, 0.316, 1.0, 3.16, 10.0, 31.6, 100.0/) real(kind=wp), public, parameter,               dimension(ntb_art) :: ta_Tk = (/243.15, 253.15, 263.15, 273.15, 283.15, 293.15, 303.15/) real(kind=wp), public, parameter,               dimension(ntb_arr) :: ta_Ra = (/0.01, 0.02, 0.04, 0.08, 0.16/) real(kind=wp), public, parameter,               dimension(ntb_ark) :: ta_Ka = (/0.2, 0.4, 0.6, 0.8/) real(kind=wp), public, parameter,               dimension(10) :: sa = (/5.065339, -0.062659, -3.032362, 0.029469, -0.000285, 0.31255, 0.000204, 0.003199, 0.0, -0.015952/) real(kind=wp), public, parameter,               dimension(10) :: sb = (/0.476221, -0.015896, 0.165977, 0.007468, -0.000141, 0.060366, 0.000079, 0.000594, 0.0, -0.003577/) real(kind=wp), public, parameter,               dimension(ntb_t) :: Tc = (/-0.01, -5., -10., -15., -20., -25., -30., -35., -40./) character(len=*), public, parameter :: thomp_table_file = 'thompson_tables_precomp_v2.sl' character(len=*), public, parameter :: qr_acr_qg_file = 'MP_TEMPO_QRacrQG.dat' character(len=*), public, parameter :: qr_acr_qg_hailaware_file = 'MP_TEMPO_HAILAWARE_QRacrQG.dat' character(len=*), public, parameter :: qr_acr_qs_file = 'MP_TEMPO_QRacrQS.dat' character(len=*), public, parameter :: freeze_h2o_file = 'MP_TEMPO_freezeH2O.dat' real(kind=wp), public, parameter :: re_qc_min = 2.50e-6 real(kind=wp), public, parameter :: re_qc_max = 50.0e-6 real(kind=wp), public, parameter :: re_qi_min = 2.50e-6 real(kind=wp), public, parameter :: re_qi_max = 125.0e-6 real(kind=wp), public, parameter :: re_qs_min = 5.00e-6 real(kind=wp), public, parameter :: re_qs_max = 999.0e-6 logical, public :: thompson_table_writer integer, public, parameter :: nc_ml_input = 7 integer, public, parameter :: nc_ml_nodes = 24 integer, public, parameter :: nc_ml_output = 1 integer, public, parameter :: nr_ml_input = 7 integer, public, parameter :: nr_ml_nodes = 24 integer, public, parameter :: nr_ml_output = 1 real(kind=wp), public, parameter,               dimension(nc_ml_input) :: nc_ml_trans_mean = (/0.000191556196486247, 3.58145042772654e-05, 3.12611085359273e-07, 5.74303078738579e-05, 84191.2092225319, 279.070551773565, 0.123679354084004/) real(kind=wp), public, parameter,               dimension(nc_ml_input) :: nc_ml_trans_var = (/5.78143564171777e-08, 3.22834309750552e-08, 6.45745893307455e-11, 4.16625579383794e-08, 215694631.771185, 94.6576255386858, 0.384841247662964/) real(kind=wp), public, parameter,               dimension(nc_ml_input * nc_ml_nodes) :: nc_ml_w00 = (/-2.006957, -0.2812008, -0.339073, 1.596426, 2.395225, 1.76315, -0.0626798, 1.267002, -0.02234177, -6.522605e-33, 0.4792154, -0.1253034, -3.217191, -3.092887, -0.0863651, 1.071625, 0.09741028, 0.2255831, -0.6929023, -0.02693799, -3.432344e-33, -0.8791879, -0.9359049, 1.083484, -0.07909214, -0.0122418, -0.02815927, 0.1676407, 0.08252326, 0.6697816, -0.4019359, 0.4687141, 0.001813132, -9.792186e-33, 0.0409322, 0.0113192, -0.01354596, 0.00307771, -0.4635534, 0.03835761, -0.1015553, 0.7316446, -0.05791711, -0.0002690362, -7.920147e-33, -0.1216918, -0.3190572, 0.09809405, -0.16476, -0.03387314, 0.005422261, 0.04043967, 0.03901243, 0.07444729, 0.01954299, 0.06918761, 0.04823543, -8.637957e-33, 0.06371575, -0.09250915, -1.109653, -1.373999, -0.2412623, -0.04482195, 0.1584691, 0.06353725, 0.0006248798, 0.04593191, -8.878673e-33, -0.4988684, 0.01110262, 0.04623203, 0.006581791, 0.03536217, -0.1890567, -0.08839592, 0.1327181, 0.03478973, -0.1565902, -0.100401, -0.1179777, -8.879818e-33, -0.1383738, 0.02847495, -0.005902881, 0.005615512, -0.6308192, -0.02431803, -0.141971, -0.3490018, -0.9850957, -0.1449479, -8.059166e-33, -0.1186465, -1.165381, 0.069015, 0.003388841, -0.04041302, 0.1638467, 0.1147008, -0.04833491, -0.07755993, -0.5137688, 0.04546477, 0.04101883, 6.752353e-33, 0.3541977, 0.04880851, -0.00102834, -0.01280629, -0.1116254, -0.02204754, 0.07100908, 0.2354002, 0.07129629, 0.2489657, 8.080785e-33, -0.03449865, 0.06037927, -0.02023619, 0.7779589, 0.04680278, 0.7492616, 0.6545208, -1.09497, -1.176524, -0.451585, 0.881124, -0.4551499, -8.708624e-33, 1.006558, -0.04979523, -0.0006915367, -0.002993054, 0.01654614, -0.07141764, -0.2216591, 0.8637336, 0.8358089, -0.7576646, 8.186339e-33, 0.1161914, 0.7121871, -1.146734, 0.03925339, 0.9975697, -0.06953461, -0.07598846, -0.06418022, -0.01897495, -0.03612464, -0.06703389, -0.103049, 9.364858e-33, -0.03949085, 1.005938, 0.0001625419, -0.01027657, 0.03823901, 0.3197246, -0.1160718, 0.04449431, 0.009831783, 0.6551342, -8.470687e-33, 0.1374123, -0.01782138, 0.01719949/) real(kind=wp), public, parameter,               dimension(nc_ml_nodes) :: nc_ml_w01 = (/-4.045869, 0.558111, -1.567351, -1.64972, 2.748608, -1.909901, 0.3955558, 1.507247, 0.3599722, -0.0001173223, -0.9398569, -0.6867028, -61.72853, -63.13766, 1.165811, -0.6848684, 0.1931683, 1.1208, 2.63087, 0.740169, -21.62499, 1.545568, 3.575141, -1.299604/) real(kind=wp), public, parameter,               dimension(nc_ml_nodes) :: nc_ml_b00 = (/-0.9842531, 0.3064759, -0.4500185, 1.28336, 1.384105, 0.528031, 0.8453538, 1.579872, 2.245679, -0.008679952, 0.4549862, -0.136581, -2.576741, -2.483647, -0.2089484, 0.7607977, 1.847745, 0.7316047, -0.287945, 2.227298, -2.314714, -0.2561245, -0.6993448, -0.1359731/) real(kind=wp), public, parameter,               dimension(nc_ml_output) :: nc_ml_b01 = (/1.572826/) Derived Types type, public :: ty_tempo_init_cfgs Components Type Visibility Attributes Name Initial logical, public :: aerosolaware_flag = .true. flag to run aerosol-aware microphysics logical, public :: hailaware_flag = .true. flag to run hail-aware microphysics logical, public :: restart_flag = .false. flag for restart or DA cycling character(len=4), public :: model_flag flag for model type, public :: ty_tempo_driver_cfgs Components Type Visibility Attributes Name Initial logical, public :: semi_sedi = .false. flag for semi-lagrangian sedimentation type, public :: ty_tempo_table_cfgs Components Type Visibility Attributes Name Initial character(len=100), public :: ccn_table_name = 'ccn_activate.bin' ccn table name character(len=100), public :: qrqg_table_name = 'qr_acr_qg_data_tempo_v3' rain-graupel collection table name character(len=100), public :: qrqs_table_name = 'qr_acr_qs_data_tempo_v3' rain-snow collection table name character(len=100), public :: freezewater_table_name = 'freeze_water_data_tempo_v3' freeze water collection table name Subroutines public  subroutine initialize_graupel_vars (hail_flag) initialize graupel variables based on hail-aware configuration flag Arguments Type Intent Optional Attributes Name logical, intent(in) :: hail_flag public  subroutine initialize_parameters () initialize tempo parameters and variables Arguments None public  subroutine initialize_bins_for_tables () initialize log-spaced bins of hydrometer quantities used for lookup tables Arguments None public  subroutine create_bins (numbins, lowbin, highbin, bins, deltabins) calculates log-spaced bins of hydrometer sizes to simplify calculations later Arguments Type Intent Optional Attributes Name integer, intent(in) :: numbins real(kind=dp), intent(in) :: lowbin real(kind=dp), intent(in) :: highbin real(kind=dp), intent(out), dimension(:) :: bins real(kind=dp), intent(out), optional, dimension(:) :: deltabins public  subroutine initialize_arrays_freezewater (table_size) initialize data arrays for Bigg (1953) freezing of cloud water and rain Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size public  subroutine initialize_arrays_qr_acr_qs (table_size) initialize data arrays for rain-snow collection Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size public  subroutine initialize_arrays_qr_acr_qg (table_size) initialize data arrays for rain-graupel collection Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size public  subroutine initialize_arrays_ccn (table_size) initialize data arrays for ccn lookup table Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: table_size public  subroutine initialize_arrays_drop_evap () initialize data arrays for drop evaporation data Arguments None public  subroutine initialize_array_efsw () initializes the collision efficiency data array for snow collecting cloud water Arguments None public  subroutine initialize_array_efrw () initializes the collision efficiency data array for rain collecting cloud water Arguments None public  subroutine initialize_arrays_qi_aut_qs () initializes data arrays for cloud ice to snow conversion and growth Arguments None","tags":"","url":"module/module_mp_tempo_params.html"},{"title":"module_mp_tempo_utils.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_utils.f90~~EfferentGraph sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~module_mp_tempo_utils.f90~~AfferentGraph sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_init.f90 module_mp_tempo_init.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module module_mp_tempo_utils !! utilities for tempo microphysics use module_mp_tempo_params !, only : wp, sp, dp implicit none private public :: snow_moments , calc_gamma_p , get_nuc , calc_rslf , calc_rsif contains function calc_gamma_p ( a , x ) result ( gamma_p ) !! normalized lower gamma function calculated either with a !! series expansion or continued fraction method !! input: a = gamma function argument, x = upper limit of integration !! output: gamma_p = \\gamma(a, x) / \\Gamma(a) real ( wp ), intent ( in ) :: a , x real ( wp ) :: gamma_p if (( x < 0.0_wp ) . or . ( a <= 0.0_wp )) stop \"Invalid arguments for function gamma_p\" if ( x < ( a + 1.0_wp )) then gamma_p = calc_gamma_series ( a , x ) else ! gammma_cf computes the upper series gamma_p = 1.0_wp - calc_gamma_cf ( a , x ) endif end function calc_gamma_p function calc_gamma_series ( a , x ) result ( gamma_series ) !! Solves the normalized lower gamma function: gamma(a,x) / Gamma(a) = x**a * gamma*(a,x) ! https://dlmf.nist.gov/8.7 (Equation 8.7.1) ! Where gamma*(a,x) = exp(-x) * sum (x**k / Gamma(a+k+1)) ! Input: !   a = gamma function argument, x = upper limit of integration ! Output: !   Normalized LOWER gamma function: gamma(a, x) / Gamma(a) real ( wp ), intent ( in ) :: a , x integer :: k integer , parameter :: it_max = 100 real ( wp ), parameter :: smallvalue = 1.e-7_wp real ( wp ) :: ap1 , sum_term , sum real ( wp ) :: gamma_series if ( x <= 0.0_wp ) stop \"Invalid arguments for function gamma_series\" ! k = 0 summation term is 1 / Gamma(a+1) ap1 = a sum_term = 1.0_wp / gamma ( ap1 + 1.0_wp ) sum = sum_term do k = 1 , it_max ap1 = ap1 + 1.0_wp sum_term = sum_term * x / ap1 sum = sum + sum_term if ( abs ( sum_term ) < ( abs ( sum ) * smallvalue )) exit enddo if ( k == it_max ) stop \"gamma_series solution did not converge\" gamma_series = sum * x ** a * exp ( - x ) end function calc_gamma_series function calc_gamma_cf ( a , x ) result ( gamma_cf ) !! Solves the normalized upper gamma function: gamma(a,x) / Gamma(a) !! using a continued fractions method (modifed Lentz Algorithm) ! http://functions.wolfram.com/06.06.10.0003.01 ! Input: !   a = gamma function argument, x = lower limit of integration ! Output: !   Normalized UPPER gamma function: gamma(a, x) / Gamma(a) real ( wp ), intent ( in ) :: a , x integer :: k integer , parameter :: it_max = 100 real ( wp ), parameter :: smallvalue = 1.e-7_wp real ( wp ), parameter :: offset = 1.e-30_wp real ( wp ) :: b , d , h0 , c , delta , h , aj real ( wp ) :: gamma_cf b = 1.0_wp - a + x d = 1.0_wp / b h0 = offset c = b + ( 1.0_wp / offset ) delta = c * d h = h0 * delta do k = 1 , it_max aj = k * ( a - k ) b = b + 2.0_wp d = b + aj * d if ( abs ( d ) < offset ) d = offset c = b + aj / c if ( abs ( c ) < offset ) c = offset d = 1.0_wp / d delta = c * d h = h * delta if ( abs ( delta - 1.0_wp ) < smallvalue ) exit enddo if ( k == it_max ) stop \"gamma_cf solution did not converge\" gamma_cf = exp ( - x + a * log ( x )) * h / gamma ( a ) end function calc_gamma_cf subroutine snow_moments ( rs , tc , smob , smoc , ns , smo0 , smo1 , smo2 , smoe , smof , smog ) !! Compute snow moments ! smo0 = 0th moment ! smo1 = 1st moment ! smo2 = 2nd moment ! ns   = total number concentration (not smo0) ! smob = rs*oams (2nd moment when bm_s=2) ! smoc = (bm_s+1)th moment ! smoe = (bv_s+2)th moment ! smof = (1+(bv_s+1)/2)th moment ! smog = (bm_s+bv_s+2)th moment use module_mp_tempo_params , only : bm_s , sa , sb , & oams , cse , csg , lam0 , lam1 , kap0 , kap1 , mu_s real ( wp ), intent ( in ) :: rs , tc real ( dp ) :: loga_ , a_ , b_ , smo2_ , m0 , mrat , slam1 , slam2 real ( dp ), intent ( out ) :: smob , smoc real ( dp ), intent ( out ), optional :: ns , smo0 , smo1 , smo2 , smoe , smof , smog ! Second moment and smob smob = real ( rs * oams , kind = dp ) if ( bm_s > 2.0_wp - 1.e-3_wp . and . bm_s < 2.0_wp + 1.e-3_wp ) then loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) * bm_s & + sa ( 4 ) * tc * bm_s + sa ( 5 ) * tc * tc & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc * tc * bm_s & + sa ( 8 ) * tc * bm_s * bm_s + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0_wp ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) * bm_s & + sb ( 4 ) * tc * bm_s + sb ( 5 ) * tc * tc & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc * tc * bm_s & + sb ( 8 ) * tc * bm_s * bm_s + sb ( 9 ) * tc * tc * tc & + sb ( 10 ) * bm_s * bm_s * bm_s smo2_ = ( smob / a_ ) ** ( 1._wp / b_ ) else smo2_ = smob endif if ( present ( smo2 )) smo2 = smo2_ ! bm+1 moment. Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc * cse ( 1 ) + sa ( 5 ) * tc * tc & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc * tc * cse ( 1 ) & + sa ( 8 ) * tc * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0_dp ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc * cse ( 1 ) & + sb ( 5 ) * tc * tc + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc * tc * cse ( 1 ) + sb ( 8 ) * tc * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc * tc * tc + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc = a_ * smo2_ ** b_ ! 0th moment. Represents snow number concentration. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 5 ) * tc * tc + sa ( 9 ) * tc * tc * tc a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 5 ) * tc * tc + sb ( 9 ) * tc * tc * tc if ( present ( smo0 )) smo0 = a_ * smo2_ ** b_ ! 1st moment. Useful for depositional growth and melting. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) & + sa ( 4 ) * tc + sa ( 5 ) * tc * tc & + sa ( 6 ) + sa ( 7 ) * tc * tc & + sa ( 8 ) * tc + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) + sb ( 4 ) * tc & + sb ( 5 ) * tc * tc + sb ( 6 ) & + sb ( 7 ) * tc * tc + sb ( 8 ) * tc & + sb ( 9 ) * tc * tc * tc + sb ( 10 ) if ( present ( smo1 )) smo1 = a_ * smo2_ ** b_ ! snow number concentration (explicit integral, not smo0) m0 = smob / smoc mrat = smob * m0 * m0 * m0 slam1 = m0 * lam0 slam2 = m0 * lam1 if ( present ( ns )) then ns = mrat * kap0 / slam1 + mrat * kap1 * m0 ** mu_s * csg ( 15 ) / slam2 ** cse ( 15 ) endif ! bv_s+2 (th) moment. Useful for riming. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) * cse ( 13 ) & + sa ( 4 ) * tc * cse ( 13 ) + sa ( 5 ) * tc * tc & + sa ( 6 ) * cse ( 13 ) * cse ( 13 ) + sa ( 7 ) * tc * tc * cse ( 13 ) & + sa ( 8 ) * tc * cse ( 13 ) * cse ( 13 ) + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) * cse ( 13 ) + sb ( 4 ) * tc * cse ( 13 ) & + sb ( 5 ) * tc * tc + sb ( 6 ) * cse ( 13 ) * cse ( 13 ) & + sb ( 7 ) * tc * tc * cse ( 13 ) + sb ( 8 ) * tc * cse ( 13 ) * cse ( 13 ) & + sb ( 9 ) * tc * tc * tc + sb ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) if ( present ( smoe )) smoe = a_ * smo2_ ** b_ ! 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) * cse ( 16 ) & + sa ( 4 ) * tc * cse ( 16 ) + sa ( 5 ) * tc * tc & + sa ( 6 ) * cse ( 16 ) * cse ( 16 ) + sa ( 7 ) * tc * tc * cse ( 16 ) & + sa ( 8 ) * tc * cse ( 16 ) * cse ( 16 ) + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) * cse ( 16 ) + sb ( 4 ) * tc * cse ( 16 ) & + sb ( 5 ) * tc * tc + sb ( 6 ) * cse ( 16 ) * cse ( 16 ) & + sb ( 7 ) * tc * tc * cse ( 16 ) + sb ( 8 ) * tc * cse ( 16 ) * cse ( 16 ) & + sb ( 9 ) * tc * tc * tc + sb ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) if ( present ( smof )) smof = a_ * smo2_ ** b_ ! bm_s + bv_s+2 (th) moment.  Useful for riming into graupel. loga_ = sa ( 1 ) + sa ( 2 ) * tc + sa ( 3 ) * cse ( 17 ) & + sa ( 4 ) * tc * cse ( 17 ) + sa ( 5 ) * tc * tc & + sa ( 6 ) * cse ( 17 ) * cse ( 17 ) + sa ( 7 ) * tc * tc * cse ( 17 ) & + sa ( 8 ) * tc * cse ( 17 ) * cse ( 17 ) + sa ( 9 ) * tc * tc * tc & + sa ( 10 ) * cse ( 17 ) * cse ( 17 ) * cse ( 17 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc + sb ( 3 ) * cse ( 17 ) + sb ( 4 ) * tc * cse ( 17 ) & + sb ( 5 ) * tc * tc + sb ( 6 ) * cse ( 17 ) * cse ( 17 ) & + sb ( 7 ) * tc * tc * cse ( 17 ) + sb ( 8 ) * tc * cse ( 17 ) * cse ( 17 ) & + sb ( 9 ) * tc * tc * tc + sb ( 10 ) * cse ( 17 ) * cse ( 17 ) * cse ( 17 ) if ( present ( smog )) smog = a_ * smo2_ ** b_ end subroutine snow_moments !================================================================================================================= elemental subroutine make_hydrometeor_number_concentrations ( qc , qr , qi , nwfa , temp , rhoa , nc , nr , ni ) implicit none real , intent ( in ) :: qc , qr , qi , nwfa , temp , rhoa real , intent ( inout ) :: nc , nr , ni end subroutine make_hydrometeor_number_concentrations !================================================================================================================= !>\\ingroup aathompson !!Table of lookup values of radiative effective radius of ice crystals !! as a function of Temperature from -94C to 0C.  Taken from WRF RRTMG !! radiation code where it is attributed to Jon Egill Kristjansson !! and coauthors. elemental real function make_IceNumber ( Q_ice , temp ) !IMPLICIT NONE REAL , PARAMETER :: Ice_density = 89 0.0 REAL , PARAMETER :: PI = 3.1415926536 real , intent ( in ) :: Q_ice , temp integer idx_rei real corr , reice , deice double precision lambda !+---+-----------------------------------------------------------------+ !..Table of lookup values of radiative effective radius of ice crystals !.. as a function of Temperature from -94C to 0C.  Taken from WRF RRTMG !.. radiation code where it is attributed to Jon Egill Kristjansson !.. and coauthors. !+---+-----------------------------------------------------------------+ !real retab(95) !data retab /                                                      & !   5.92779, 6.26422, 6.61973, 6.99539, 7.39234,                   & !   7.81177, 8.25496, 8.72323, 9.21800, 9.74075, 10.2930,          & !   10.8765, 11.4929, 12.1440, 12.8317, 13.5581, 14.2319,          & !   15.0351, 15.8799, 16.7674, 17.6986, 18.6744, 19.6955,          & !   20.7623, 21.8757, 23.0364, 24.2452, 25.5034, 26.8125,          & !   27.7895, 28.6450, 29.4167, 30.1088, 30.7306, 31.2943,          & !   31.8151, 32.3077, 32.7870, 33.2657, 33.7540, 34.2601,          & !   34.7892, 35.3442, 35.9255, 36.5316, 37.1602, 37.8078,          & !   38.4720, 39.1508, 39.8442, 40.5552, 41.2912, 42.0635,          & !   42.8876, 43.7863, 44.7853, 45.9170, 47.2165, 48.7221,          & !   50.4710, 52.4980, 54.8315, 57.4898, 60.4785, 63.7898,          & !   65.5604, 71.2885, 75.4113, 79.7368, 84.2351, 88.8833,          & !   93.6658, 98.5739, 103.603, 108.752, 114.025, 119.424,          & !   124.954, 130.630, 136.457, 142.446, 148.608, 154.956,          & !   161.503, 168.262, 175.248, 182.473, 189.952, 197.699,          & !   205.728, 214.055, 222.694, 231.661, 240.971, 250.639/ real , dimension ( 95 ), parameter :: retab = ( / & 5.92779 , 6.26422 , 6.61973 , 6.99539 , 7.39234 , & 7.81177 , 8.25496 , 8.72323 , 9.21800 , 9.74075 , 1 0.2930 , & 1 0.8765 , 1 1.4929 , 1 2.1440 , 1 2.8317 , 1 3.5581 , 1 4.2319 , & 1 5.0351 , 1 5.8799 , 1 6.7674 , 1 7.6986 , 1 8.6744 , 1 9.6955 , & 2 0.7623 , 2 1.8757 , 2 3.0364 , 2 4.2452 , 2 5.5034 , 2 6.8125 , & 2 7.7895 , 2 8.6450 , 2 9.4167 , 3 0.1088 , 3 0.7306 , 3 1.2943 , & 3 1.8151 , 3 2.3077 , 3 2.7870 , 3 3.2657 , 3 3.7540 , 3 4.2601 , & 3 4.7892 , 3 5.3442 , 3 5.9255 , 3 6.5316 , 3 7.1602 , 3 7.8078 , & 3 8.4720 , 3 9.1508 , 3 9.8442 , 4 0.5552 , 4 1.2912 , 4 2.0635 , & 4 2.8876 , 4 3.7863 , 4 4.7853 , 4 5.9170 , 4 7.2165 , 4 8.7221 , & 5 0.4710 , 5 2.4980 , 5 4.8315 , 5 7.4898 , 6 0.4785 , 6 3.7898 , & 6 5.5604 , 7 1.2885 , 7 5.4113 , 7 9.7368 , 8 4.2351 , 8 8.8833 , & 9 3.6658 , 9 8.5739 , 10 3.603 , 10 8.752 , 11 4.025 , 11 9.424 , & 12 4.954 , 13 0.630 , 13 6.457 , 14 2.446 , 14 8.608 , 15 4.956 , & 16 1.503 , 16 8.262 , 17 5.248 , 18 2.473 , 18 9.952 , 19 7.699 , & 20 5.728 , 21 4.055 , 22 2.694 , 23 1.661 , 24 0.971 , 25 0.639 / ) if ( Q_ice == 0 ) then make_IceNumber = 0 return end if !+---+-----------------------------------------------------------------+ !..From the model 3D temperature field, subtract 179K for which !.. index value of retab as a start.  Value of corr is for !.. interpolating between neighboring values in the table. !+---+-----------------------------------------------------------------+ idx_rei = int ( temp - 17 9. ) idx_rei = min ( max ( idx_rei , 1 ), 94 ) corr = temp - int ( temp ) reice = retab ( idx_rei ) * ( 1. - corr ) + retab ( idx_rei + 1 ) * corr deice = 2. * reice * 1.E-6 !+---+-----------------------------------------------------------------+ !..Now we have the final radiative effective size of ice (as function !.. of temperature only).  This size represents 3rd moment divided by !.. second moment of the ice size distribution, so we can compute a !.. number concentration from the mean size and mass mixing ratio. !.. The mean (radiative effective) diameter is 3./Slope for an inverse !.. exponential size distribution.  So, starting with slope, work !.. backwords to get number concentration. !+---+-----------------------------------------------------------------+ lambda = 3.0 / deice make_IceNumber = Q_ice * lambda * lambda * lambda / ( PI * Ice_density ) !+---+-----------------------------------------------------------------+ !..Example1: Common ice size coming from Thompson scheme is about 30 microns. !.. An example ice mixing ratio could be 0.001 g/kg for a temperature of -50C. !.. Remember to convert both into MKS units.  This gives N_ice=357652 per kg. !..Example2: Lower in atmosphere at T=-10C matching ~162 microns in retab, !.. and assuming we have 0.1 g/kg mixing ratio, then N_ice=28122 per kg, !.. which is 28 crystals per liter of air if the air density is 1.0. !+---+-----------------------------------------------------------------+ return end function make_IceNumber !================================================================================================================= elemental real function make_DropletNumber ( Q_cloud , qnwfa ) !IMPLICIT NONE real , intent ( in ) :: Q_cloud , qnwfa real , parameter :: PI = 3.1415926536 real , parameter :: am_r = PI * 100 0. / 6. real , dimension ( 15 ), parameter :: g_ratio = ( / 24 , 60 , 120 , 210 , 336 , & & 504 , 720 , 990 , 1320 , 1716 , 2184 , 2730 , 3360 , 4080 , 4896 / ) double precision :: lambda , qnc real :: q_nwfa , x1 , xDc integer :: nu_c if ( Q_cloud == 0 ) then make_DropletNumber = 0 return end if !+---+ q_nwfa = MAX ( 9 9.E6 , MIN ( qnwfa , 5.E10 )) nu_c = MAX ( 2 , MIN ( NINT ( 2.5E10 / q_nwfa ), 15 )) x1 = MAX ( 1. , MIN ( q_nwfa * 1.E-9 , 1 0. )) - 1. xDc = ( 3 0. - x1 * 2 0. / 9. ) * 1.E-6 lambda = ( 4.0D0 + nu_c ) / xDc qnc = Q_cloud / g_ratio ( nu_c ) * lambda * lambda * lambda / am_r make_DropletNumber = SNGL ( qnc ) return end function make_DropletNumber !================================================================================================================= elemental real function make_RainNumber ( Q_rain , temp ) IMPLICIT NONE real , intent ( in ) :: Q_rain , temp double precision :: lambda , N0 , qnr real , parameter :: PI = 3.1415926536 real , parameter :: am_r = PI * 100 0. / 6. if ( Q_rain == 0 ) then make_RainNumber = 0 return end if !+---+-----------------------------------------------------------------+ !.. Not thrilled with it, but set Y-intercept parameter to Marshal-Palmer value !.. that basically assumes melting snow becomes typical rain. However, for !.. -2C < T < 0C, make linear increase in exponent to attempt to keep !.. supercooled collision-coalescence (warm-rain) similar to drizzle rather !.. than bigger rain drops.  While this could also exist at T>0C, it is !.. more difficult to assume it directly from having mass and not number. !+---+-----------------------------------------------------------------+ N0 = 8.E6 if ( temp . le . 27 1.15 ) then N0 = 8.E8 elseif ( temp . gt . 27 1.15 . and . temp . lt . 27 3.15 ) then N0 = 8. * 10 ** ( 27 9.15 - temp ) endif lambda = SQRT ( SQRT ( N0 * am_r * 6.0 / Q_rain )) qnr = Q_rain / 6.0 * lambda * lambda * lambda / am_r make_RainNumber = SNGL ( qnr ) return end function make_RainNumber function calc_rslf ( p , t ) result ( rslf ) !! calculates liquid saturation vapor mixing ratio real ( wp ), intent ( in ) :: p , t real ( wp ) :: esl , x real ( wp ), parameter :: c0 = . 61158369 9E03_wp real ( wp ), parameter :: c1 = . 44460689 6E02_wp real ( wp ), parameter :: c2 = . 14317715 7e01_wp real ( wp ), parameter :: c3 = . 26422432 1e-1_wp real ( wp ), parameter :: c4 = . 29929108 1e-3_wp real ( wp ), parameter :: c5 = . 20315418 2e-5_wp real ( wp ), parameter :: c6 = . 70262069 8e-8_wp real ( wp ), parameter :: c7 = . 37953431 0e-11_wp real ( wp ), parameter :: c8 = - . 32158239 3e-13_wp real ( wp ) :: rslf x = max ( - 8 0._wp , t - 27 3.16 ) esl = c0 + x * ( c1 + x * ( c2 + x * ( c3 + x * ( c4 + x * ( c5 + x * ( c6 + x * ( c7 + x * c8 ))))))) esl = min ( esl , p * 0.15 ) !! @note !! Even with P=1050mb and T=55C, the saturation vapor !! pressure only contributes to ~15% of the total pressure !! @endnote rslf = . 622 * esl / ( p - esl ) end function calc_rslf function calc_rsif ( p , t ) result ( rsif ) !! calculates liquid saturation vapor mixing ratio real ( wp ), intent ( in ) :: p , t real ( wp ) :: esi , x real ( wp ), parameter :: c0 = . 60986899 3e03_wp real ( wp ), parameter :: c1 = . 49932023 3e02_wp real ( wp ), parameter :: c2 = . 18467263 1e01_wp real ( wp ), parameter :: c3 = . 40273718 4e-1_wp real ( wp ), parameter :: c4 = . 56539298 7e-3_wp real ( wp ), parameter :: c5 = . 52169393 3e-5_wp real ( wp ), parameter :: c6 = . 30783958 3e-7_wp real ( wp ), parameter :: c7 = . 10578516 0e-9_wp real ( wp ), parameter :: c8 = . 16144444 4e-12_wp real ( wp ) :: rsif x = max ( - 8 0._wp , t - 27 3.16 ) esi = c0 + x * ( c1 + x * ( c2 + x * ( c3 + x * ( c4 + x * ( c5 + x * ( c6 + x * ( c7 + x * c8 ))))))) esi = min ( esi , p * 0.15 ) rsif = . 622 * esi / max ( 1.e-4_wp ,( p - esi )) end function calc_rsif function get_nuc ( nc ) result ( nu_c ) !! returns nu_c for cloud water (values from 2-15) use module_mp_tempo_params , only : nu_c_scale real ( wp ), intent ( in ) :: nc integer :: nu_c nu_c = min ( 15 , nint ( nu_c_scale / nc ) + 2 ) end function get_nuc end module module_mp_tempo_utils","tags":"","url":"sourcefile/module_mp_tempo_utils.f90.html"},{"title":"module_mp_tempo_ml.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_ml.f90~~EfferentGraph sourcefile~module_mp_tempo_ml.f90 module_mp_tempo_ml.F90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_ml.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~module_mp_tempo_ml.f90~~AfferentGraph sourcefile~module_mp_tempo_ml.f90 module_mp_tempo_ml.F90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_ml.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! TEMPO neural network module designed for cloud droplet number concentration prediction ! A big thanks to David John Gagne (NCAR) for very useful discussions ! Please see https://github.com/NCAR/mlmicrophysics for a more detailed way to connect ! ML models in python to Fortran microphysics code module module_mp_tempo_ml use module_mp_tempo_params implicit none private public :: MLdata , tempo_save_or_read_ml_data , predict_number , predict_number_sub type MLdata integer :: input_size integer :: output_size integer :: node_size real , allocatable , dimension (:) :: transform_mean real , allocatable , dimension (:) :: transform_var real , allocatable , dimension (:,:) :: weights00 real , allocatable , dimension (:) :: bias00 real , allocatable , dimension (:,:) :: weights01 real , allocatable , dimension (:) :: bias01 end type MLdata contains !---------------------------------------------------------------------------------- ! Initializes or returns neural network information. ! Saves nueral network data information if a neural network is not ! initialized. If output data is requested, the initialized and saved ! neural network will be used. subroutine tempo_save_or_read_ml_data ( ml_data_in , ml_data_out ) logical , save :: not_initialized = . true . type ( MLdata ), dimension ( 2 ), intent ( in ), optional :: ml_data_in type ( MLdata ), dimension ( 2 ), intent ( out ), optional :: ml_data_out type ( MLdata ), dimension ( 2 ), save :: tempo_ml_data_save if ( not_initialized ) then if ( present ( ml_data_in )) tempo_ml_data_save = ml_data_in not_initialized = . false . endif if ( present ( ml_data_out )) then ml_data_out = tempo_ml_data_save endif end subroutine tempo_save_or_read_ml_data !------------------------------------------------------------------------------------------------------ ! Predicts number concentration real function predict_number ( qc , qr , qi , qs , pres , temp , w , predict_nc ) real , intent ( in ) :: qc , qr , qi , qs , pres , temp , w logical , intent ( in ) :: predict_nc type ( MLdata ), dimension ( 2 ) :: get_ml_data type ( MLdata ) :: ml_data integer , parameter :: input_rows = 1 real , allocatable , dimension (:,:) :: input , input_transformed real , allocatable , dimension (:,:) :: output00 , output00Activ real , allocatable , dimension (:,:) :: output01 , output01Activ real , parameter :: logMin = - 6.0 ! R2 real , parameter :: logMax = 9.3010299957 ! 2000 cm&#94;-3 double precision :: predictExp ! Get neural network data call tempo_save_or_read_ml_data ( ml_data_out = get_ml_data ) if ( predict_nc ) then ml_data = get_ml_data ( 1 ) else ml_data = get_ml_data ( 2 ) endif ! Allocate arrays for input data and transformation if (. not . allocated ( input )) then allocate ( input ( input_rows , ml_data % input_size )) endif if (. not . allocated ( input_transformed )) then allocate ( input_transformed ( input_rows , ml_data % input_size )) endif ! Collect input data input ( 1 , 1 ) = qc input ( 1 , 2 ) = qr input ( 1 , 3 ) = qi input ( 1 , 4 ) = qs input ( 1 , 5 ) = pres input ( 1 , 6 ) = temp input ( 1 , 7 ) = w ! Transform input data call standard_scaler_transform ( mean = ml_data % transform_mean , var = ml_data % transform_var , & raw_data = input , transformed_data = input_transformed ) ! Allocate arrays if (. not . allocated ( output00 )) then allocate ( output00 ( ml_data % node_size , ml_data % output_size )) endif if (. not . allocated ( output00Activ )) then allocate ( output00Activ ( ml_data % node_size , ml_data % output_size )) endif if (. not . allocated ( output01 )) then allocate ( output01 ( ml_data % output_size , ml_data % output_size )) endif if (. not . allocated ( output01Activ )) then allocate ( output01Activ ( ml_data % output_size , ml_data % output_size )) endif ! Reconstruct neural network ! First layer output00 = matmul ( transpose ( ml_data % weights00 ), transpose ( input_transformed )) + & reshape ( ml_data % bias00 , ( / size ( ml_data % bias00 ), ml_data % output_size / )) call relu_activation ( input = output00 , output = output00Activ ) ! Second layer output01 = matmul ( transpose ( ml_data % weights01 ), output00Activ ) + & reshape ( ml_data % bias01 , ( / size ( ml_data % bias01 ), ml_data % output_size / )) call relu_activation ( input = output01 , output = output01Activ ) ! Prediction predictExp = min ( logMax , max ( logMin , output01Activ ( 1 , 1 ))) predict_number = 1 0. ** predictExp end function predict_number !------------------------------------------------------------------------------------------------------ ! Predicts number concentration subroutine predict_number_sub ( kts , kte , qc , qr , qi , qs , pres , temp , w , predict_number , predict_nc ) integer , intent ( in ) :: kts , kte real , dimension ( kts : kte ), intent ( in ) :: qc , qr , qi , qs , pres , temp , w double precision , dimension ( kts : kte ), intent ( inout ) :: predict_number logical , intent ( in ) :: predict_nc type ( MLdata ), dimension ( 2 ) :: get_ml_data type ( MLdata ) :: ml_data integer , parameter :: input_rows = 1 real , allocatable , dimension (:,:) :: input , input_transformed real , allocatable , dimension (:,:) :: output00 , output00Activ , reshaped_bias00 real , allocatable , dimension (:,:) :: output01 , output01Activ , reshaped_bias01 real , parameter :: logMin = - 6.0 ! R2 real , parameter :: logMax = 9.3010299957 ! 2000 cm&#94;-3 double precision :: predictExp , bias_corr integer :: k ! Get neural network data call tempo_save_or_read_ml_data ( ml_data_out = get_ml_data ) if ( predict_nc ) then ml_data = get_ml_data ( 1 ) else ml_data = get_ml_data ( 2 ) endif ! Allocate arrays for input data and transformation if (. not . allocated ( input )) then allocate ( input ( ml_data % input_size , kte )) endif if (. not . allocated ( input_transformed )) then allocate ( input_transformed ( ml_data % input_size , kte )) endif ! Collect input data input ( 1 ,:) = qc input ( 2 ,:) = qr input ( 3 ,:) = qi input ( 4 ,:) = qs input ( 5 ,:) = pres input ( 6 ,:) = temp input ( 7 ,:) = w ! Transform input data call standard_scaler_transform ( mean = ml_data % transform_mean , var = ml_data % transform_var , & raw_data = input , transformed_data = input_transformed ) ! Allocate arrays if (. not . allocated ( output00 )) then allocate ( output00 ( ml_data % node_size , kte )) endif if (. not . allocated ( output00Activ )) then allocate ( output00Activ ( ml_data % node_size , kte )) endif if (. not . allocated ( reshaped_bias00 )) then allocate ( reshaped_bias00 ( ml_data % node_size , kte )) endif if (. not . allocated ( output01 )) then allocate ( output01 ( ml_data % output_size , kte )) endif if (. not . allocated ( output01Activ )) then allocate ( output01Activ ( ml_data % output_size , kte )) endif if (. not . allocated ( reshaped_bias01 )) then allocate ( reshaped_bias01 ( ml_data % output_size , kte )) endif do k = kts , kte reshaped_bias00 (:, k ) = ml_data % bias00 reshaped_bias01 ( 1 , k ) = ml_data % bias01 ( 1 ) enddo ! Reconstruct neural network ! First layer output00 = matmul ( ml_data % weights00 , input_transformed ) + reshaped_bias00 call relu_activation ( input = output00 , output = output00Activ ) ! Second layer output01 = matmul ( ml_data % weights01 , output00Activ ) + reshaped_bias01 call relu_activation ( input = output01 , output = output01Activ ) do k = kts , kte ! Prediction predictExp = min ( logMax , max ( logMin , output01Activ ( 1 , k ))) ! Bias correction bias_corr = 1.0 if (( predictExp >= 0. ) . and . ( predictExp < 3. )) then bias_corr = - 0.2704 * predictExp ** 5 + 1.838 * predictExp ** 4 - 5.127 * predictExp ** 3 + & 8.547 * predictExp ** 2 - 8.439 * predictExp + 4.297 endif predict_number ( k ) = bias_corr * ( 1 0. ** predictExp ) enddo end subroutine predict_number_sub !------------------------------------------------------------------------------------------------------ ! Standard transformer subroutine standard_scaler_transform ( mean , var , raw_data , transformed_data ) real , dimension (:,:), intent ( in ) :: raw_data real , dimension (:), intent ( in ) :: mean , var real , intent ( out ) :: transformed_data ( size ( raw_data , 1 ), size ( raw_data , 2 )) integer :: i do i = 1 , size ( raw_data , 1 ) transformed_data ( i ,:) = ( raw_data ( i ,:) - mean ( i )) / sqrt ( var ( i )) end do end subroutine standard_scaler_transform !---------------------------------------------------------------------------------- ! Activation function subroutine relu_activation ( input , output ) real , dimension (:,:), intent ( in ) :: input real , dimension ( size ( input , 1 ), size ( input , 2 )), intent ( out ) :: output integer :: i , j do i = 1 , size ( input , 1 ) do j = 1 , size ( input , 2 ) output ( i , j ) = max ( input ( i , j ), 0. ) end do end do end subroutine relu_activation !---------------------------------------------------------------------------------- end module module_mp_tempo_ml","tags":"","url":"sourcefile/module_mp_tempo_ml.f90.html"},{"title":"module_mp_radar.F90 – TEMPO Microphysics","text":"Files dependent on this one sourcefile~~module_mp_radar.f90~~AfferentGraph sourcefile~module_mp_radar.f90 module_mp_radar.F90 sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_radar.f90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_diags.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !>\\file module_mp_radar.F90 !! This set of routines facilitates computing radar reflectivity. !>\\ingroup aathompson !! This module is more library code whereas the individual microphysics !! schemes contains specific details needed for the final computation, !! so refer to location within each schemes calling the routine named !! rayleigh_soak_wetgraupel. !! !! The bulk of this code originated from Ulrich Blahak (Germany) and !! was adapted to WRF by G. Thompson.  This version of code is only !! intended for use when Rayleigh scattering principles dominate and !! is not intended for wavelengths in which Mie scattering is a !! significant portion.  Therefore, it is well-suited to use with !! 5 or 10 cm wavelength like USA NEXRAD radars. !! This code makes some rather simple assumptions about water !! coating on outside of frozen species (snow/graupel).  Fraction of !! meltwater is simply the ratio of mixing ratio below melting level !! divided by mixing ratio at level just above highest T>0C.  Also, !! immediately 90% of the melted water exists on the ice's surface !! and 10% is embedded within ice.  No water is \"shed\" at all in these !! assumptions. The code is quite slow because it does the reflectivity !! calculations based on 50 individual size bins of the distributions. !+---+-----------------------------------------------------------------+ MODULE module_mp_radar PUBLIC :: rayleigh_soak_wetgraupel PUBLIC :: radar_init PRIVATE :: m_complex_water_ray PRIVATE :: m_complex_ice_maetzler PRIVATE :: m_complex_maxwellgarnett PRIVATE :: get_m_mix_nested PRIVATE :: get_m_mix PRIVATE :: WGAMMA PRIVATE :: GAMMLN INTEGER , PARAMETER , PUBLIC :: nrbins = 50 DOUBLE PRECISION , DIMENSION ( nrbins + 1 ), PUBLIC :: xxDx DOUBLE PRECISION , DIMENSION ( nrbins ), PUBLIC :: xxDs , xdts , xxDg , xdtg DOUBLE PRECISION , PARAMETER , PUBLIC :: lamda_radar = 0.10 ! in meters DOUBLE PRECISION , PUBLIC :: K_w , PI5 , lamda4 COMPLEX * 16 , PUBLIC :: m_w_0 , m_i_0 DOUBLE PRECISION , DIMENSION ( nrbins + 1 ), PUBLIC :: simpson DOUBLE PRECISION , DIMENSION ( 3 ), PARAMETER , PUBLIC :: basis = & ( / 1.d0 / 3.d0 , 4.d0 / 3.d0 , 1.d0 / 3.d0 / ) REAL , DIMENSION ( 4 ), PUBLIC :: xcre , xcse , xcge , xcrg , xcsg , xcgg REAL , PUBLIC :: xam_r , xbm_r , xmu_r , xobmr REAL , PUBLIC :: xam_s , xbm_s , xmu_s , xoams , xobms , xocms REAL , PUBLIC :: xam_g , xbm_g , xmu_g , xoamg , xobmg , xocmg REAL , PUBLIC :: xorg2 , xosg2 , xogg2 INTEGER , PARAMETER , PUBLIC :: slen = 20 CHARACTER ( len = slen ), PUBLIC :: & mixingrulestring_s , matrixstring_s , inclusionstring_s , & hoststring_s , hostmatrixstring_s , hostinclusionstring_s , & mixingrulestring_g , matrixstring_g , inclusionstring_g , & hoststring_g , hostmatrixstring_g , hostinclusionstring_g !> Single melting snow/graupel particle 90% meltwater on external sfc DOUBLE PRECISION , PARAMETER :: melt_outside_s = 0.9d0 DOUBLE PRECISION , PARAMETER :: melt_outside_g = 0.9d0 CONTAINS !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar !! subroutine radar_init IMPLICIT NONE INTEGER :: n PI5 = 3.14159 * 3.14159 * 3.14159 * 3.14159 * 3.14159 lamda4 = lamda_radar * lamda_radar * lamda_radar * lamda_radar m_w_0 = m_complex_water_ray ( lamda_radar , 0.0d0 ) m_i_0 = m_complex_ice_maetzler ( lamda_radar , 0.0d0 ) K_w = ( ABS ( ( m_w_0 * m_w_0 - 1.0 ) / ( m_w_0 * m_w_0 + 2.0 ) )) ** 2 do n = 1 , nrbins + 1 simpson ( n ) = 0.0d0 enddo do n = 1 , nrbins - 1 , 2 simpson ( n ) = simpson ( n ) + basis ( 1 ) simpson ( n + 1 ) = simpson ( n + 1 ) + basis ( 2 ) simpson ( n + 2 ) = simpson ( n + 2 ) + basis ( 3 ) enddo do n = 1 , slen mixingrulestring_s ( n : n ) = char ( 0 ) matrixstring_s ( n : n ) = char ( 0 ) inclusionstring_s ( n : n ) = char ( 0 ) hoststring_s ( n : n ) = char ( 0 ) hostmatrixstring_s ( n : n ) = char ( 0 ) hostinclusionstring_s ( n : n ) = char ( 0 ) mixingrulestring_g ( n : n ) = char ( 0 ) matrixstring_g ( n : n ) = char ( 0 ) inclusionstring_g ( n : n ) = char ( 0 ) hoststring_g ( n : n ) = char ( 0 ) hostmatrixstring_g ( n : n ) = char ( 0 ) hostinclusionstring_g ( n : n ) = char ( 0 ) enddo mixingrulestring_s = 'maxwellgarnett' hoststring_s = 'air' matrixstring_s = 'water' inclusionstring_s = 'spheroidal' hostmatrixstring_s = 'icewater' hostinclusionstring_s = 'spheroidal' mixingrulestring_g = 'maxwellgarnett' hoststring_g = 'air' matrixstring_g = 'water' inclusionstring_g = 'spheroidal' hostmatrixstring_g = 'icewater' hostinclusionstring_g = 'spheroidal' !..Create bins of snow (from 100 microns up to 2 cm). xxDx ( 1 ) = 10 0.D-6 xxDx ( nrbins + 1 ) = 0.02d0 do n = 2 , nrbins xxDx ( n ) = DEXP ( DFLOAT ( n - 1 ) / DFLOAT ( nrbins ) & * DLOG ( xxDx ( nrbins + 1 ) / xxDx ( 1 )) + DLOG ( xxDx ( 1 ))) enddo do n = 1 , nrbins xxDs ( n ) = DSQRT ( xxDx ( n ) * xxDx ( n + 1 )) xdts ( n ) = xxDx ( n + 1 ) - xxDx ( n ) enddo !..Create bins of graupel (from 100 microns up to 5 cm). xxDx ( 1 ) = 10 0.D-6 xxDx ( nrbins + 1 ) = 0.05d0 do n = 2 , nrbins xxDx ( n ) = DEXP ( DFLOAT ( n - 1 ) / DFLOAT ( nrbins ) & * DLOG ( xxDx ( nrbins + 1 ) / xxDx ( 1 )) + DLOG ( xxDx ( 1 ))) enddo do n = 1 , nrbins xxDg ( n ) = DSQRT ( xxDx ( n ) * xxDx ( n + 1 )) xdtg ( n ) = xxDx ( n + 1 ) - xxDx ( n ) enddo !..The calling program must set the m(D) relations and gamma shape !.. parameter mu for rain, snow, and graupel.  Easily add other types !.. based on the template here.  For majority of schemes with simpler !.. exponential number distribution, mu=0. xcre ( 1 ) = 1. + xbm_r xcre ( 2 ) = 1. + xmu_r xcre ( 3 ) = 1. + xbm_r + xmu_r xcre ( 4 ) = 1. + 2. * xbm_r + xmu_r do n = 1 , 4 xcrg ( n ) = WGAMMA ( xcre ( n )) enddo xorg2 = 1. / xcrg ( 2 ) xcse ( 1 ) = 1. + xbm_s xcse ( 2 ) = 1. + xmu_s xcse ( 3 ) = 1. + xbm_s + xmu_s xcse ( 4 ) = 1. + 2. * xbm_s + xmu_s do n = 1 , 4 xcsg ( n ) = WGAMMA ( xcse ( n )) enddo xosg2 = 1. / xcsg ( 2 ) xcge ( 1 ) = 1. + xbm_g xcge ( 2 ) = 1. + xmu_g xcge ( 3 ) = 1. + xbm_g + xmu_g xcge ( 4 ) = 1. + 2. * xbm_g + xmu_g do n = 1 , 4 xcgg ( n ) = WGAMMA ( xcge ( n )) enddo xogg2 = 1. / xcgg ( 2 ) xobmr = 1. / xbm_r xoams = 1. / xam_s xobms = 1. / xbm_s xocms = xoams ** xobms xoamg = 1. / xam_g xobmg = 1. / xbm_g xocmg = xoamg ** xobmg end subroutine radar_init !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar COMPLEX * 16 FUNCTION m_complex_water_ray ( lambda , T ) !>      Complex refractive Index of Water as function of Temperature T !!      [deg C] and radar wavelength lambda [m]; valid for !!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C !!      after Ray (1972) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: T , lambda DOUBLE PRECISION :: epsinf , epss , epsr , epsi DOUBLE PRECISION :: alpha , lambdas , sigma , nenner COMPLEX * 16 , PARAMETER :: i = ( 0 d0 , 1 d0 ) DOUBLE PRECISION , PARAMETER :: PIx = 3.1415926535897932384626434d0 epsinf = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T * T epss = 7 8.54d+0 * ( 1.0 - 4.579d-3 * ( T - 2 5.0 ) & + 1.190d-5 * ( T - 2 5.0 ) * ( T - 2 5.0 ) & - 2.800d-8 * ( T - 2 5.0 ) * ( T - 2 5.0 ) * ( T - 2 5.0 )) alpha = - 1 6.8129d0 / ( T + 27 3.16 ) + 0.0609265d0 lambdas = 0.00033836d0 * exp ( 251 3.98d0 / ( T + 27 3.16 )) * 1e-2 nenner = 1.d0 + 2.d0 * ( lambdas / lambda ) ** ( 1 d0 - alpha ) * sin ( alpha * PIx * 0.5 ) & + ( lambdas / lambda ) ** ( 2 d0 - 2 d0 * alpha ) epsr = epsinf + (( epss - epsinf ) * (( lambdas / lambda ) ** ( 1 d0 - alpha ) & * sin ( alpha * PIx * 0.5 ) + 1 d0 )) / nenner epsi = (( epss - epsinf ) * (( lambdas / lambda ) ** ( 1 d0 - alpha ) & * cos ( alpha * PIx * 0.5 ) + 0 d0 )) / nenner & + lambda * 1.25664 / 1.88496 m_complex_water_ray = SQRT ( CMPLX ( epsr , - epsi )) END FUNCTION m_complex_water_ray !+---+-----------------------------------------------------------------+ COMPLEX * 16 FUNCTION m_complex_ice_maetzler ( lambda , T ) !      complex refractive index of ice as function of Temperature T !      [deg C] and radar wavelength lambda [m]; valid for !      lambda in [0.0001,30] m; T in [-250.0,0.0] C !      Original comment from the Matlab-routine of Prof. Maetzler: !      Function for calculating the relative permittivity of pure ice in !      the microwave region, according to C. Maetzler, \"Microwave !      properties of ice and snow\", in B. Schmitt et al. (eds.) Solar !      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer !      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input: !      TK = temperature (K), range 20 to 273.15 !      f = frequency in GHz, range 0.01 to 3000 IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: T , lambda DOUBLE PRECISION :: f , c , TK , B1 , B2 , b , deltabeta , betam , beta , theta , alfa c = 2.99d8 TK = T + 27 3.16 f = c / lambda * 1 d - 9 B1 = 0.0207 B2 = 1.16d-11 b = 33 5.0d0 deltabeta = EXP ( - 1 0.02 + 0.0364 * ( TK - 27 3.16 )) betam = ( B1 / TK ) * ( EXP ( b / TK ) / (( EXP ( b / TK ) - 1 ) ** 2 ) ) + B2 * f * f beta = betam + deltabeta theta = 30 0. / TK - 1. alfa = ( 0.00504d0 + 0.0062d0 * theta ) * EXP ( - 2 2.1d0 * theta ) m_complex_ice_maetzler = 3.1884 + 9.1e-4 * ( TK - 27 3.16 ) m_complex_ice_maetzler = m_complex_ice_maetzler & + CMPLX ( 0.0d0 , ( alfa / f + beta * f )) m_complex_ice_maetzler = SQRT ( CONJG ( m_complex_ice_maetzler )) END FUNCTION m_complex_ice_maetzler !+---+-----------------------------------------------------------------+ !>ingroup thompson_radar !! subroutine rayleigh_soak_wetgraupel ( x_g , a_geo , b_geo , fmelt , & meltratio_outside , m_w , m_i , lambda , C_back , & mixingrule , matrix , inclusion , & host , hostmatrix , hostinclusion ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( in ) :: x_g , a_geo , b_geo , fmelt , lambda , & meltratio_outside DOUBLE PRECISION , INTENT ( out ) :: C_back COMPLEX * 16 , INTENT ( in ) :: m_w , m_i CHARACTER ( len =* ), INTENT ( in ) :: mixingrule , matrix , inclusion , & host , hostmatrix , hostinclusion COMPLEX * 16 :: m_core , m_air DOUBLE PRECISION :: D_large , D_g , rhog , x_w , xw_a , fm , fmgrenz , & volg , vg , volair , volice , volwater , & meltratio_outside_grenz , mra INTEGER :: error DOUBLE PRECISION , PARAMETER :: PIx = 3.1415926535897932384626434d0 !     refractive index of air: m_air = ( 1.0d0 , 0.0d0 ) !     Limiting the degree of melting --- for safety: fm = DMAX1 ( DMIN1 ( fmelt , 1.0d0 ), 0.0d0 ) !     Limiting the ratio of (melting on outside)/(melting on inside): mra = DMAX1 ( DMIN1 ( meltratio_outside , 1.0d0 ), 0.0d0 ) !    ! The relative portion of meltwater melting at outside should increase !    ! from the given input value (between 0 and 1) !    ! to 1 as the degree of melting approaches 1, !    ! so that the melting particle \"converges\" to a water drop. !    ! Simplest assumption is linear: mra = mra + ( 1.0d0 - mra ) * fm x_w = x_g * fm D_g = a_geo * x_g ** b_geo if ( D_g . ge . 1 d - 12 ) then vg = PIx / 6. * D_g ** 3 rhog = DMAX1 ( DMIN1 ( x_g / vg , 90 0.0d0 ), 1 0.0d0 ) vg = x_g / rhog meltratio_outside_grenz = 1.0d0 - rhog / 100 0. if ( mra . le . meltratio_outside_grenz ) then !..In this case, it cannot happen that, during melting, all the !.. air inclusions within the ice particle get filled with !.. meltwater. This only happens at the end of all melting. volg = vg * ( 1.0d0 - mra * fm ) else !..In this case, at some melting degree fm, all the air !.. inclusions get filled with meltwater. fmgrenz = ( 90 0.0 - rhog ) / ( mra * 90 0.0 - rhog + 90 0.0 * rhog / 100 0. ) if ( fm . le . fmgrenz ) then !.. not all air pockets are filled: volg = ( 1.0 - mra * fm ) * vg else !..all air pockets are filled with meltwater, now the !.. entire ice sceleton melts homogeneously: volg = ( x_g - x_w ) / 90 0.0 + x_w / 100 0. endif endif D_large = ( 6.0 / PIx * volg ) ** ( 1. / 3. ) volice = ( x_g - x_w ) / ( volg * 90 0.0 ) volwater = x_w / ( 100 0. * volg ) volair = 1.0 - volice - volwater !..complex index of refraction for the ice-air-water mixture !.. of the particle: m_core = get_m_mix_nested ( m_air , m_i , m_w , volair , volice , & volwater , mixingrule , host , matrix , inclusion , & hostmatrix , hostinclusion , error ) if ( error . ne . 0 ) then C_back = 0.0d0 return endif !..Rayleigh-backscattering coefficient of melting particle: C_back = ( ABS (( m_core ** 2 - 1.0d0 ) / ( m_core ** 2 + 2.0d0 ))) ** 2 & * PI5 * D_large ** 6 / lamda4 else C_back = 0.0d0 endif end subroutine rayleigh_soak_wetgraupel !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar !! complex * 16 function get_m_mix_nested ( m_a , m_i , m_w , volair , & volice , volwater , mixingrule , host , matrix , & inclusion , hostmatrix , hostinclusion , cumulerror ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( in ) :: volice , volair , volwater COMPLEX * 16 , INTENT ( in ) :: m_a , m_i , m_w CHARACTER ( len =* ), INTENT ( in ) :: mixingrule , host , matrix , & inclusion , hostmatrix , hostinclusion INTEGER , INTENT ( out ) :: cumulerror DOUBLE PRECISION :: vol1 , vol2 COMPLEX * 16 :: mtmp INTEGER :: error !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be !.. air, ice, or water cumulerror = 0 get_m_mix_nested = CMPLX ( 1.0d0 , 0.0d0 ) if ( host . eq . 'air' ) then if ( matrix . eq . 'air' ) then write ( * , * ) 'GET_M_MIX_NESTED: bad matrix: ' , matrix cumulerror = cumulerror + 1 else vol1 = volice / MAX ( volice + volwater , 1 d - 10 ) vol2 = 1.0d0 - vol1 mtmp = get_m_mix ( m_a , m_i , m_w , 0.0d0 , vol1 , vol2 , & mixingrule , matrix , inclusion , error ) cumulerror = cumulerror + error if ( hostmatrix . eq . 'air' ) then get_m_mix_nested = get_m_mix ( m_a , mtmp , 2.0 * m_a , & volair , ( 1.0d0 - volair ), 0.0d0 , mixingrule , & hostmatrix , hostinclusion , error ) cumulerror = cumulerror + error elseif ( hostmatrix . eq . 'icewater' ) then get_m_mix_nested = get_m_mix ( m_a , mtmp , 2.0 * m_a , & volair , ( 1.0d0 - volair ), 0.0d0 , mixingrule , & 'ice' , hostinclusion , error ) cumulerror = cumulerror + error else write ( * , * ) 'GET_M_MIX_NESTED: bad hostmatrix: ' , & hostmatrix cumulerror = cumulerror + 1 endif endif elseif ( host . eq . 'ice' ) then if ( matrix . eq . 'ice' ) then write ( * , * ) 'GET_M_MIX_NESTED: bad matrix: ' , matrix cumulerror = cumulerror + 1 else vol1 = volair / MAX ( volair + volwater , 1 d - 10 ) vol2 = 1.0d0 - vol1 mtmp = get_m_mix ( m_a , m_i , m_w , vol1 , 0.0d0 , vol2 , & mixingrule , matrix , inclusion , error ) cumulerror = cumulerror + error if ( hostmatrix . eq . 'ice' ) then get_m_mix_nested = get_m_mix ( mtmp , m_i , 2.0 * m_a , & ( 1.0d0 - volice ), volice , 0.0d0 , mixingrule , & hostmatrix , hostinclusion , error ) cumulerror = cumulerror + error elseif ( hostmatrix . eq . 'airwater' ) then get_m_mix_nested = get_m_mix ( mtmp , m_i , 2.0 * m_a , & ( 1.0d0 - volice ), volice , 0.0d0 , mixingrule , & 'air' , hostinclusion , error ) cumulerror = cumulerror + error else write ( * , * ) 'GET_M_MIX_NESTED: bad hostmatrix: ' , & hostmatrix cumulerror = cumulerror + 1 endif endif elseif ( host . eq . 'water' ) then if ( matrix . eq . 'water' ) then write ( * , * ) 'GET_M_MIX_NESTED: bad matrix: ' , matrix cumulerror = cumulerror + 1 else vol1 = volair / MAX ( volice + volair , 1 d - 10 ) vol2 = 1.0d0 - vol1 mtmp = get_m_mix ( m_a , m_i , m_w , vol1 , vol2 , 0.0d0 , & mixingrule , matrix , inclusion , error ) cumulerror = cumulerror + error if ( hostmatrix . eq . 'water' ) then get_m_mix_nested = get_m_mix ( 2 * m_a , mtmp , m_w , & 0.0d0 , ( 1.0d0 - volwater ), volwater , mixingrule , & hostmatrix , hostinclusion , error ) cumulerror = cumulerror + error elseif ( hostmatrix . eq . 'airice' ) then get_m_mix_nested = get_m_mix ( 2 * m_a , mtmp , m_w , & 0.0d0 , ( 1.0d0 - volwater ), volwater , mixingrule , & 'ice' , hostinclusion , error ) cumulerror = cumulerror + error else write ( * , * ) 'GET_M_MIX_NESTED: bad hostmatrix: ' , & hostmatrix cumulerror = cumulerror + 1 endif endif elseif ( host . eq . 'none' ) then get_m_mix_nested = get_m_mix ( m_a , m_i , m_w , & volair , volice , volwater , mixingrule , & matrix , inclusion , error ) cumulerror = cumulerror + error else write ( * , * ) 'GET_M_MIX_NESTED: unknown matrix: ' , host cumulerror = cumulerror + 1 endif IF ( cumulerror . ne . 0 ) THEN write ( * , * ) 'GET_M_MIX_NESTED: error encountered' get_m_mix_nested = CMPLX ( 1.0d0 , 0.0d0 ) endif end function get_m_mix_nested !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar !! COMPLEX * 16 FUNCTION get_m_mix ( m_a , m_i , m_w , volair , volice , & volwater , mixingrule , matrix , inclusion , error ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( in ) :: volice , volair , volwater COMPLEX * 16 , INTENT ( in ) :: m_a , m_i , m_w CHARACTER ( len =* ), INTENT ( in ) :: mixingrule , matrix , inclusion INTEGER , INTENT ( out ) :: error error = 0 get_m_mix = CMPLX ( 1.0d0 , 0.0d0 ) if ( mixingrule . eq . 'maxwellgarnett' ) then if ( matrix . eq . 'ice' ) then get_m_mix = m_complex_maxwellgarnett ( volice , volair , volwater , & m_i , m_a , m_w , inclusion , error ) elseif ( matrix . eq . 'water' ) then get_m_mix = m_complex_maxwellgarnett ( volwater , volair , volice , & m_w , m_a , m_i , inclusion , error ) elseif ( matrix . eq . 'air' ) then get_m_mix = m_complex_maxwellgarnett ( volair , volwater , volice , & m_a , m_w , m_i , inclusion , error ) else write ( * , * ) 'GET_M_MIX: unknown matrix: ' , matrix error = 1 endif else write ( * , * ) 'GET_M_MIX: unknown mixingrule: ' , mixingrule error = 2 endif if ( error . ne . 0 ) then write ( * , * ) 'GET_M_MIX: error encountered' endif END FUNCTION get_m_mix !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar !! COMPLEX * 16 FUNCTION m_complex_maxwellgarnett ( vol1 , vol2 , vol3 , & m1 , m2 , m3 , inclusion , error ) IMPLICIT NONE COMPLEX * 16 :: m1 , m2 , m3 DOUBLE PRECISION :: vol1 , vol2 , vol3 CHARACTER ( len =* ) :: inclusion COMPLEX * 16 :: beta2 , beta3 , m1t , m2t , m3t INTEGER , INTENT ( out ) :: error error = 0 if ( DABS ( vol1 + vol2 + vol3 - 1.0d0 ) . gt . 1 d - 6 ) then write ( * , * ) 'M_COMPLEX_MAXWELLGARNETT: sum of the ' , & 'partial volume fractions is not 1...ERROR' m_complex_maxwellgarnett = CMPLX ( - 99 9.99d0 , - 99 9.99d0 ) error = 1 return endif m1t = m1 ** 2 m2t = m2 ** 2 m3t = m3 ** 2 if ( inclusion . eq . 'spherical' ) then beta2 = 3.0d0 * m1t / ( m2t + 2.0d0 * m1t ) beta3 = 3.0d0 * m1t / ( m3t + 2.0d0 * m1t ) elseif ( inclusion . eq . 'spheroidal' ) then beta2 = 2.0d0 * m1t / ( m2t - m1t ) * ( m2t / ( m2t - m1t ) * LOG ( m2t / m1t ) - 1.0d0 ) beta3 = 2.0d0 * m1t / ( m3t - m1t ) * ( m3t / ( m3t - m1t ) * LOG ( m3t / m1t ) - 1.0d0 ) else write ( * , * ) 'M_COMPLEX_MAXWELLGARNETT: ' , & 'unknown inclusion: ' , inclusion m_complex_maxwellgarnett = DCMPLX ( - 99 9.99d0 , - 99 9.99d0 ) error = 1 return endif m_complex_maxwellgarnett = & SQRT ((( 1.0d0 - vol2 - vol3 ) * m1t + vol2 * beta2 * m2t + vol3 * beta3 * m3t ) / & ( 1.0d0 - vol2 - vol3 + vol2 * beta2 + vol3 * beta3 )) END FUNCTION m_complex_maxwellgarnett !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar REAL FUNCTION GAMMLN ( XX ) !     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0. IMPLICIT NONE REAL , INTENT ( IN ) :: XX DOUBLE PRECISION , PARAMETER :: STP = 2.5066282746310005D0 DOUBLE PRECISION , DIMENSION ( 6 ), PARAMETER :: & COF = ( / 7 6.18009172947146D0 , - 8 6.50532032941677D0 , & 2 4.01409824083091D0 , - 1.231739572450155D0 , & . 1208650973866179 D - 2 , - . 5395239384953 D - 5 / ) DOUBLE PRECISION :: SER , TMP , X , Y INTEGER :: J X = XX Y = X TMP = X + 5.5D0 TMP = ( X + 0.5D0 ) * LOG ( TMP ) - TMP SER = 1.000000000190015D0 DO 11 J = 1 , 6 Y = Y + 1.D0 SER = SER + COF ( J ) / Y 11 CONTINUE GAMMLN = TMP + LOG ( STP * SER / X ) END FUNCTION GAMMLN !  (C) Copr. 1986-92 Numerical Recipes Software 2.02 !+---+-----------------------------------------------------------------+ !>\\ingroup thompson_radar REAL FUNCTION WGAMMA ( y ) IMPLICIT NONE REAL , INTENT ( IN ) :: y WGAMMA = EXP ( GAMMLN ( y )) END FUNCTION WGAMMA !+---+-----------------------------------------------------------------+ END MODULE module_mp_radar !+---+-----------------------------------------------------------------+","tags":"","url":"sourcefile/module_mp_radar.f90.html"},{"title":"machine.F90 – TEMPO Microphysics","text":"Files dependent on this one sourcefile~~machine.f90~~AfferentGraph sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_diags.f90 sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_main.f90 sourcefile~module_mp_tempo_ml.f90 module_mp_tempo_ml.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_ml.f90 sourcefile~module_mp_tempo_init.f90 module_mp_tempo_init.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_ml.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module machine !! This module sets the precision used for TEMPO microphysics implicit none private public :: kind_phys , kind_sngl_prec , kind_dbl_prec , kind_io8 integer , parameter :: kind_sngl_prec = 4 , & kind_dbl_prec = 8 ! Physics single precision flag #ifndef SINGLE_PREC integer , parameter :: kind_phys = kind_dbl_prec #else integer , parameter :: kind_phys = kind_sngl_prec #endif integer , parameter :: kind_io8 = kind_phys end module machine","tags":"","url":"sourcefile/machine.f90.html"},{"title":"module_mp_tempo_driver.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_driver.f90~~EfferentGraph sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_diags.f90 sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_main.f90 sourcefile~module_mp_tempo_ml.f90 module_mp_tempo_ml.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_ml.f90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_radar.f90 module_mp_radar.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_radar.f90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_ml.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! 3D TEMPO Driver for MPAS !================================================================================================================= module module_mp_tempo_driver ! use mpas_kind_types, only: wp => RKIND, sp => R4KIND, dp => R8KIND use module_mp_tempo_params ! use module_mp_tempo_utils use module_mp_tempo_diags , only : calc_effectRad , calc_refl10cm , hail_size_diagnostics use module_mp_tempo_main , only : mp_tempo_main use module_mp_tempo_ml , only : predict_number_sub ! use module_mp_tempo_init, only : tempo_init_cfgs !use mpas_atmphys_utilities, only : physics_message, physics_error_fatal !use mpas_io_units, only : mpas_new_unit, mpas_release_unit !use mp_radar implicit none contains !================================================================================================================= ! This is a wrapper routine designed to transfer values from 3D to 1D. ! Required microphysics variables are qv, qc, qr, nr, qi, ni, qs, qg ! Optional microphysics variables are aerosol aware (nc, nwfa, nifa, nwfa2d, nifa2d), and hail aware (ng, qg) subroutine tempo_3d_to_1d_driver ( qv , qc , qr , qi , qs , qg , qb , ni , nr , nc , ng , & nwfa , nifa , nwfa2d , nifa2d , th , pii , p , w , dz , dt_in , itimestep , & rainnc , rainncv , snownc , snowncv , graupelnc , graupelncv , sr , frainnc , & refl_10cm , diagflag , do_radar_ref , re_cloud , re_ice , re_snow , qcbl , cldfrac , & has_reqc , has_reqi , has_reqs , ntc , muc , rainprod , evapprod , & max_hail_diameter_column , max_hail_diameter_sfc , & ids , ide , jds , jde , kds , kde , ims , ime , jms , jme , kms , kme , its , ite , jts , jte , kts , kte ) ! Subroutine (3D) arguments integer , intent ( in ) :: ids , ide , jds , jde , kds , kde , ims , ime , jms , jme , kms , kme , its , ite , jts , jte , kts , kte real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( inout ) :: qv , qc , qr , qi , qs , qg , ni , nr , th real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( inout ) :: re_cloud , re_ice , re_snow integer , intent ( in ) :: has_reqc , has_reqi , has_reqs real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( in ) :: pii , p , w , dz real , dimension ( ims : ime , jms : jme ), intent ( inout ) :: rainnc , rainncv , sr real , optional , dimension ( ims : ime , jms : jme ), intent ( inout ) :: frainnc , max_hail_diameter_column , max_hail_diameter_sfc real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( inout ) :: rainprod , evapprod real , dimension ( ims : ime , jms : jme ), intent ( in ), optional :: ntc , muc real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( inout ), optional :: nc , nwfa , nifa , qb , ng real , dimension ( ims : ime , jms : jme ), intent ( in ), optional :: nwfa2d , nifa2d real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( inout ), optional :: refl_10cm real , dimension ( ims : ime , kms : kme , jms : jme ), intent ( in ), optional :: qcbl , cldfrac real , dimension ( ims : ime , jms : jme ), intent ( inout ), optional :: snownc , snowncv , graupelnc , graupelncv real , intent ( in ) :: dt_in integer , intent ( in ) :: itimestep ! Local (1d) variables real , dimension ( kts : kte ) :: qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , qb1d , ni1d , nr1d , nc1d , ng1d , & nwfa1d , nifa1d , t1d , p1d , w1d , dz1d , rho , dbz , qcbl1d , cldfrac1d , qg_max_diam1d real , dimension ( kts : kte ) :: re_qc1d , re_qi1d , re_qs1d real , dimension ( kts : kte ) :: rainprod1d , evapprod1d double precision , dimension ( kts : kte ) :: ncbl1d real , dimension ( its : ite , jts : jte ) :: pcp_ra , pcp_sn , pcp_gr , pcp_ic , frain real :: dt , pptrain , pptsnow , pptgraul , pptice real :: qc_max , qr_max , qs_max , qi_max , qg_max , ni_max , nr_max real :: nwfa1 real :: ygra1 , zans1 real :: graupel_vol real :: tmprc , tmpnc , xDc integer :: nu_c logical , dimension ( kts : kte ) :: sgs_clouds double precision :: lamg , lam_exp , lamr , n0_min , n0_exp , lamc integer :: i , j , k integer :: imax_qc , imax_qr , imax_qi , imax_qs , imax_qg , imax_ni , imax_nr integer :: jmax_qc , jmax_qr , jmax_qi , jmax_qs , jmax_qg , jmax_ni , jmax_nr integer :: kmax_qc , kmax_qr , kmax_qi , kmax_qs , kmax_qg , kmax_ni , kmax_nr integer :: i_start , j_start , i_end , j_end logical , optional , intent ( in ) :: diagflag integer , optional , intent ( in ) :: do_radar_ref character ( len = 132 ) :: message !================================================================================================================= i_start = its j_start = jts i_end = min ( ite , ide - 1 ) j_end = min ( jte , jde - 1 ) dt = dt_in qc_max = 0.0 qr_max = 0.0 qs_max = 0.0 qi_max = 0.0 qg_max = 0.0 ni_max = 0.0 nr_max = 0.0 imax_qc = 0 imax_qr = 0 imax_qi = 0 imax_qs = 0 imax_qg = 0 imax_ni = 0 imax_nr = 0 jmax_qc = 0 jmax_qr = 0 jmax_qi = 0 jmax_qs = 0 jmax_qg = 0 jmax_ni = 0 jmax_nr = 0 kmax_qc = 0 kmax_qr = 0 kmax_qi = 0 kmax_qs = 0 kmax_qg = 0 kmax_ni = 0 kmax_nr = 0 !================================================================================================================= j_loop : do j = j_start , j_end i_loop : do i = i_start , i_end pptrain = 0.0 pptsnow = 0.0 pptgraul = 0.0 pptice = 0.0 rainncv ( i , j ) = 0.0 if ( present ( snowncv )) then snowncv ( i , j ) = 0.0 endif if ( present ( graupelncv )) then graupelncv ( i , j ) = 0.0 endif sr ( i , j ) = 0.0 ! ntc and muc are defined in mpas submodule based on landmask if ( present ( ntc )) then Nt_c = ntc ( i , j ) mu_c = muc ( i , j ) else Nt_c = Nt_c_o mu_c = 4 endif !================================================================================================================= ! Begin k loop do k = kts , kte t1d ( k ) = th ( i , k , j ) * pii ( i , k , j ) p1d ( k ) = p ( i , k , j ) w1d ( k ) = w ( i , k , j ) dz1d ( k ) = dz ( i , k , j ) qv1d ( k ) = qv ( i , k , j ) qc1d ( k ) = qc ( i , k , j ) qi1d ( k ) = qi ( i , k , j ) qr1d ( k ) = qr ( i , k , j ) qs1d ( k ) = qs ( i , k , j ) qg1d ( k ) = qg ( i , k , j ) ni1d ( k ) = ni ( i , k , j ) nr1d ( k ) = nr ( i , k , j ) rho ( k ) = RoverRv * p1d ( k ) / ( R * t1d ( k ) * ( qv1d ( k ) + RoverRv )) sgs_clouds ( k ) = . false . if ( present ( qcbl ) . and . present ( cldfrac )) then qcbl1d ( k ) = qcbl ( i , k , j ) cldfrac1d ( k ) = cldfrac ( i , k , j ) ncbl1d ( k ) = 0. endif ! nwfa, nifa, and nc are optional aerosol-aware variables if ( present ( nwfa )) then if ( present ( nwfa2d )) then if ( k == kts ) then nwfa ( i , k , j ) = nwfa ( i , k , j ) + nwfa2d ( i , j ) * dt endif endif nwfa ( i , k , j ) = max ( nwfa_default , min ( aero_max , nwfa ( i , k , j ))) nwfa1d ( k ) = nwfa ( i , k , j ) else nwfa1d ( k ) = nwfa_default / rho ( k ) !configs%aerosol_aware = .false. endif if ( present ( nifa )) then nifa1d ( k ) = nifa ( i , k , j ) else nifa1d ( k ) = nifa_default / rho ( k ) !configs%aerosol_aware = .false. endif if ( present ( nc )) then nc1d ( k ) = nc ( i , k , j ) else nc1d ( k ) = Nt_c / rho ( k ) !configs%aerosol_aware = .false. endif enddo ! ng and qb are optional hail-aware variables if (( present ( ng )) . and . ( present ( qb ))) then !configs%hail_aware = .true. do k = kts , kte ng1d ( k ) = ng ( i , k , j ) qb1d ( k ) = qb ( i , k , j ) enddo else do k = kte , kts , - 1 ! This is the one-moment graupel formulation if ( qg1d ( k ) > R1 ) then ygra1 = log10 ( max ( 1.e-9 , qg1d ( k ) * rho ( k ))) zans1 = 3.0 + 2.0 / 7.0 * ( ygra1 + 8.0 ) zans1 = max ( 2.0 , min ( zans1 , 6.0 )) n0_exp = 1 0.0 ** ( zans1 ) lam_exp = ( n0_exp * am_g ( idx_bg1 ) * cgg ( 1 , 1 ) / ( rho ( k ) * qg1d ( k ))) ** oge1 lamg = lam_exp * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** obmg ng1d ( k ) = cgg ( 2 , 1 ) * ogg3 * rho ( k ) * qg1d ( k ) * lamg ** bm_g / am_g ( idx_bg1 ) ng1d ( k ) = max ( R2 , ( ng1d ( k ) / rho ( k ))) qb1d ( k ) = qg1d ( k ) / rho_g ( idx_bg1 ) else ng1d ( k ) = 0. qb1d ( k ) = 0. endif enddo endif !if (itimestep == 1) then !   call physics_message('--- tempo_3d_to_1d_driver() configuration...') !   write(message, '(L1)') configs%hail_aware !   call physics_message('       hail_aware_flag = ' // trim(message)) !   write(message, '(L1)') configs%aerosol_aware !   call physics_message('       aerosol_aware_flag = ' // trim(message)) !   call physics_message('calling mp_tempo_main() at itimestep = 1') !endif !================================================================================================================= ! Main call to the 1D microphysics call mp_tempo_main ( qv1d = qv1d , qc1d = qc1d , qi1d = qi1d , qr1d = qr1d , qs1d = qs1d , qg1d = qg1d , qb1d = qb1d , & ni1d = ni1d , nr1d = nr1d , nc1d = nc1d , ng1d = ng1d , nwfa1d = nwfa1d , nifa1d = nifa1d , t1d = t1d , p1d = p1d , & w1d = w1d , dzq = dz1d , pptrain = pptrain , pptsnow = pptsnow , pptgraul = pptgraul , pptice = pptice , & kts = kts , kte = kte , dt = dt , ii = i , jj = j ) !, configs=configs) !================================================================================================================= ! Compute diagnostics and return output to 3D pcp_ra ( i , j ) = pptrain pcp_sn ( i , j ) = pptsnow pcp_gr ( i , j ) = pptgraul pcp_ic ( i , j ) = pptice rainncv ( i , j ) = pptrain + pptsnow + pptgraul + pptice rainnc ( i , j ) = rainnc ( i , j ) + pptrain + pptsnow + pptgraul + pptice if ( present ( snowncv ) . and . present ( snownc )) then snowncv ( i , j ) = pptsnow + pptice snownc ( i , j ) = snownc ( i , j ) + pptsnow + pptice endif if ( present ( graupelncv ) . and . present ( graupelnc )) then graupelncv ( i , j ) = pptgraul graupelnc ( i , j ) = graupelnc ( i , j ) + pptgraul endif if ( present ( frainnc )) then frain ( i , j ) = 0. if ( t1d ( 1 ) <= 27 3. ) then frain ( i , j ) = pcp_ra ( i , j ) endif frainnc ( i , j ) = frainnc ( i , j ) + frain ( i , j ) endif sr ( i , j ) = ( pptsnow + pptgraul + pptice ) / ( rainncv ( i , j ) + R1 ) ! ng and qb are optional hail-aware variables if (( present ( ng )) . and . ( present ( qb ))) then do k = kts , kte ng ( i , k , j ) = ng1d ( k ) qb ( i , k , j ) = qb1d ( k ) enddo else do k = kte , kts , - 1 ! This is the one-moment graupel formulation if ( qg1d ( k ) > R1 ) then rho ( k ) = RoverRv * p1d ( k ) / ( R * t1d ( k ) * ( qv1d ( k ) + RoverRv )) ygra1 = log10 ( max ( 1.e-9 , qg1d ( k ) * rho ( k ))) zans1 = 3.0 + 2.0 / 7.0 * ( ygra1 + 8.0 ) zans1 = max ( 2.0 , min ( zans1 , 6.0 )) n0_exp = 1 0.0 ** ( zans1 ) lam_exp = ( n0_exp * am_g ( idx_bg1 ) * cgg ( 1 , 1 ) / ( rho ( k ) * qg1d ( k ))) ** oge1 lamg = lam_exp * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** obmg ng1d ( k ) = cgg ( 2 , 1 ) * ogg3 * rho ( k ) * qg1d ( k ) * lamg ** bm_g / am_g ( idx_bg1 ) ng1d ( k ) = max ( R2 , ( ng1d ( k ) / rho ( k ))) qb1d ( k ) = qg1d ( k ) / rho_g ( idx_bg1 ) else ng1d ( k ) = 0. qb1d ( k ) = 0. endif enddo endif do k = kts , kte if ( present ( nc )) nc ( i , k , j ) = nc1d ( k ) if ( present ( nwfa )) nwfa ( i , k , j ) = nwfa1d ( k ) if ( present ( nifa )) nifa ( i , k , j ) = nifa1d ( k ) qv ( i , k , j ) = qv1d ( k ) qc ( i , k , j ) = qc1d ( k ) qi ( i , k , j ) = qi1d ( k ) qr ( i , k , j ) = qr1d ( k ) qs ( i , k , j ) = qs1d ( k ) qg ( i , k , j ) = qg1d ( k ) ni ( i , k , j ) = ni1d ( k ) nr ( i , k , j ) = nr1d ( k ) th ( i , k , j ) = t1d ( k ) / pii ( i , k , j ) rainprod ( i , k , j ) = rainprod1d ( k ) evapprod ( i , k , j ) = evapprod1d ( k ) if ( present ( qcbl ) . and . present ( cldfrac )) then if (( qc1d ( k ) <= R1 ) . and . ( qcbl1d ( k ) > 1.e-9 ) . and . ( cldfrac1d ( k ) > 0. )) then qc1d ( k ) = qc1d ( k ) + qcbl1d ( k ) / cldfrac1d ( k ) ! Uses in-cloud PBL mass sgs_clouds ( k ) = . true . else sgs_clouds ( k ) = . false . endif else sgs_clouds ( k ) = . false . endif enddo if ( any ( sgs_clouds )) then ! return array of ncbl1d call predict_number_sub ( kts , kte , qc1d , qr1d , qi1d , qs1d , p1d , t1d , w1d , & ncbl1d , predict_nc = . true .) do k = kts , kte if ( sgs_clouds ( k )) then nc1d ( k ) = nc1d ( k ) + real ( ncbl1d ( k )) rho ( k ) = RoverRv * p1d ( k ) / ( R * t1d ( k ) * ( qv1d ( k ) + RoverRv )) tmprc = qc1d ( k ) * rho ( k ) tmpnc = max ( 2. , min ( nc1d ( k ) * rho ( k ), nt_c_max )) if ( tmpnc . gt . 1000 0.e6 ) then nu_c = 2 elseif ( tmpnc . lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / tmpnc ) + 2 nu_c = max ( 2 , min ( nu_c , 15 )) endif lamc = ( tmpnc * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / tmprc ) ** obmr xDc = ( bm_r + nu_c + 1. ) / lamc if ( xDc . lt . D0c ) then lamc = cce ( 2 , nu_c ) / D0c elseif ( xDc . gt . D0r * 2. ) then lamc = cce ( 2 , nu_c ) / ( D0r * 2. ) endif tmpnc = min ( real ( nt_c_max , kind = dp ), ccg ( 1 , nu_c ) * ocg2 ( nu_c ) * tmprc / am_r * lamc ** bm_r ) nc1d ( k ) = tmpnc / rho ( k ) ! Update nc1d for calc_effectRad endif enddo endif ! if (present(qcbl) .and. present(cldfrac)) then !    if ((qc1d(k) <= R1) .and. (qcbl(i,k,j) > 1.e-9) .and. (cldfrac(i,k,j) > 0.)) then !       qc1d(k) = qc1d(k) + qcbl(i,k,j)/cldfrac(i,k,j) ! Uses in-cloud PBL mass !       ! ML prediction of number concentration (Don't add in qibl for now) !       ! COULD BE DLOW FROM CALLING CALLING SUBROUTINE FOR EACH i,k,j !       ncbl(k) = predict_number(qc1d(k), qr1d(k), qi1d(k), qs1d(k), & !            p1d(k), t1d(k), w1d(k), predict_nc=.true.) !       nc1d(k) = nc1d(k) + ncbl(k) !       rho(k) = RoverRv * p1d(k) / (R * t1d(k) * (qv1d(k)+RoverRv)) !       tmprc = qc1d(k)*rho(k) !       tmpnc = max(2., min(nc1d(k)*rho(k), nt_c_max)) !       if (tmpnc.gt.10000.e6) then !          nu_c = 2 !       elseif (tmpnc.lt.100.) then !          nu_c = 15 !       else !          nu_c = nint(nu_c_scale/tmpnc) + 2 !          nu_c = max(2, min(nu_c, 15)) !       endif !       lamc = (tmpnc*am_r*ccg(2,nu_c)*ocg1(nu_c)/tmprc)**obmr !       xDc = (bm_r + nu_c + 1.) / lamc !       if (xDc .lt. D0c) then !          lamc = cce(2,nu_c)/D0c !       elseif (xDc.gt. D0r*2.) then !          lamc = cce(2,nu_c)/(D0r*2.) !       endif !       tmpnc = min(real(nt_c_max, kind=dp), ccg(1,nu_c)*ocg2(nu_c)*tmprc / am_r*lamc**bm_r) !       nc1d(k) = tmpnc/rho(k) ! Update nc1d for calc_effectRad !    endif ! endif !!! K LOOP                enddo !================================================================================================================= ! Reflectivity call calc_refl10cm ( qv1d = qv1d , qc1d = qc1d , qr1d = qr1d , nr1d = nr1d , qs1d = qs1d , qg1d = qg1d , ng1d = ng1d , qb1d = qb1d , & t1d = t1d , p1d = p1d , dBZ = dBZ , kts = kts , kte = kte , ii = i , jj = j ) !, configs=configs) do k = kts , kte refl_10cm ( i , k , j ) = max ( - 3 5.0_wp , dBZ ( k )) enddo if (( present ( max_hail_diameter_sfc )) . and . ( present ( max_hail_diameter_column ))) then ! Maximium hail size call hail_size_diagnostics ( kts = kts , kte = kte , qg1d = qg1d , ng1d = ng1d , qb1d = qb1d , t1d = t1d , p1d = p1d , qv1d = qv1d , & qg_max_diam1d = qg_max_diam1d ) !, configs=configs) max_hail_diameter_sfc ( i , j ) = max ( 0.0_wp , qg_max_diam1d ( kts )) max_hail_diameter_column ( i , j ) = max ( 0.0_wp , maxval ( qg_max_diam1d )) endif ! Cloud, ice, and snow effective radius if ( has_reqc /= 0 . and . has_reqi /= 0 . and . has_reqs /= 0 ) then do k = kts , kte re_qc1d ( k ) = 2.49e-6 re_qi1d ( k ) = 4.99e-6 re_qs1d ( k ) = 9.99e-6 enddo call calc_effectRad ( t1d = t1d , p1d = p1d , qv1d = qv1d , qc1d = qc1d , nc1d = nc1d , qi1d = qi1d , & ni1d = ni1d , qs1d = qs1d , re_qc1d = re_qc1d , re_qi1d = re_qi1d , re_qs1d = re_qs1d , & kts = kts , kte = kte ) !, configs=configs) do k = kts , kte re_cloud ( i , k , j ) = max ( 2.49e-6 , min ( re_qc1d ( k ), 5 0.e-6 )) re_ice ( i , k , j ) = max ( 4.99e-6 , min ( re_qi1d ( k ), 12 5.e-6 )) re_snow ( i , k , j ) = max ( 9.99e-6 , min ( re_qs1d ( k ), 99 9.e-6 )) enddo endif enddo i_loop enddo j_loop end subroutine tempo_3d_to_1d_driver !================================================================================================================= end module module_mp_tempo_driver","tags":"","url":"sourcefile/module_mp_tempo_driver.f90.html"},{"title":"module_mp_tempo_main.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_main.f90~~EfferentGraph sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~module_mp_tempo_main.f90~~AfferentGraph sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! 1D TEMPO microphysics scheme !================================================================================================================= module module_mp_tempo_main use module_mp_tempo_params use module_mp_tempo_utils , only : calc_rslf , calc_rsif ! use module_mp_tempo_init, only : tempo_init_cfgs ! #if defined(mpas) !     use mpas_kind_types, only: wp => RKIND, sp => R4KIND, dp => R8KIND ! #elif defined(standalone) !     use machine, only: wp => kind_phys, sp => kind_sngl_prec, dp => kind_dbl_prec ! #else !     use machine, only: wp => kind_phys, sp => kind_sngl_prec, dp => kind_dbl_prec ! #define ccpp_default 1 ! #endif implicit none private public :: mp_tempo_main contains !================================================================================================================= ! This subroutine computes the moisture tendencies of water vapor, cloud droplets, rain, cloud ice (pristine), ! snow, and graupel. Previously this code was based on Reisner et al (1998), but few of those pieces remain. ! A complete description is now found in Thompson et al. (2004, 2008), Thompson and Eidhammer (2014), ! and Jensen et al. (2023). subroutine mp_tempo_main ( qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , qb1d , ni1d , nr1d , nc1d , ng1d , & nwfa1d , nifa1d , t1d , p1d , w1d , dzq , pptrain , pptsnow , pptgraul , pptice , & !!! #if defined(mpas) !         rainprod, evapprod, & ! #endif #if defined(ccpp_default) ! Extended diagnostics, most arrays only ! allocated if ext_diag flag is .true. ext_diag , sedi_semi , & prw_vcdc1 , prw_vcde1 , & tpri_inu1 , tpri_ide1_d , tpri_ide1_s , tprs_ide1 , & tprs_sde1_d , tprs_sde1_s , & tprg_gde1_d , tprg_gde1_s , tpri_iha1 , tpri_wfz1 , & tpri_rfz1 , tprg_rfz1 , tprs_scw1 , tprg_scw1 ,& tprg_rcs1 , tprs_rcs1 , tprr_rci1 , & tprg_rcg1 , tprw_vcd1_c , & tprw_vcd1_e , tprr_sml1 , tprr_gml1 , tprr_rcg1 , & tprr_rcs1 , tprv_rev1 , & tten1 , qvten1 , qrten1 , qsten1 , & qgten1 , qiten1 , niten1 , nrten1 , ncten1 , qcten1 , & #endif decfl , pfil1 , pfll1 , & lsml , rand1 , rand2 , rand3 , & kts , kte , dt , ii , jj ) !! configs) ! #if defined(ccpp_default) && defined (MPI) !         use mpi_f08 ! #endif ! Subroutine arguments integer , intent ( in ) :: kts , kte , ii , jj real ( wp ), dimension ( kts : kte ), intent ( inout ) :: qv1d , qc1d , qi1d , qr1d , qs1d , qg1d , qb1d , & ni1d , nr1d , nc1d , ng1d , nwfa1d , nifa1d , t1d real ( wp ), dimension ( kts : kte ), intent ( in ) :: p1d , w1d , dzq real ( wp ), intent ( inout ) :: pptrain , pptsnow , pptgraul , pptice real ( wp ), intent ( in ) :: dt !! type(ty_tempo_cfg), intent(in) :: configs integer , intent ( in ), optional :: lsml real ( wp ), intent ( in ), optional :: rand1 , rand2 , rand3 real ( wp ), dimension ( kts : kte ), intent ( out ), optional :: pfil1 , pfll1 integer , intent ( in ), optional :: decfl #if defined(ccpp_default) ! Extended diagnostics, most arrays only allocated if ext_diag is true logical , intent ( in ) :: ext_diag logical , intent ( in ) :: sedi_semi real ( wp ), optional , dimension (:), intent ( out ) :: & prw_vcdc1 , & prw_vcde1 , tpri_inu1 , tpri_ide1_d , & tpri_ide1_s , tprs_ide1 , & tprs_sde1_d , tprs_sde1_s , tprg_gde1_d , & tprg_gde1_s , tpri_iha1 , tpri_wfz1 , & tpri_rfz1 , tprg_rfz1 , tprs_scw1 , tprg_scw1 , & tprg_rcs1 , tprs_rcs1 , & tprr_rci1 , tprg_rcg1 , & tprw_vcd1_c , tprw_vcd1_e , tprr_sml1 , & tprr_gml1 , tprr_rcg1 , & tprr_rcs1 , tprv_rev1 , tten1 , qvten1 , & qrten1 , qsten1 , qgten1 , qiten1 , niten1 , & nrten1 , ncten1 , qcten1 #endif #if defined(mpas) real ( wp ), dimension ( kts : kte ), intent ( inout ) :: rainprod , evapprod #endif !================================================================================================================= ! Local variables real ( wp ), dimension ( kts : kte ) :: tten , qvten , qcten , qiten , qrten , & qsten , qgten , qbten , niten , nrten , ncten , ngten , nwfaten , nifaten real ( dp ), dimension ( kts : kte ) :: prw_vcd real ( dp ), dimension ( kts : kte ) :: pnc_wcd , pnc_wau , pnc_rcw , pnc_scw , pnc_gcw real ( dp ), dimension ( kts : kte ) :: pna_rca , pna_sca , pna_gca , pnd_rcd , pnd_scd , pnd_gcd real ( dp ), dimension ( kts : kte ) :: prr_wau , prr_rcw , prr_rcs , & prr_rcg , prr_sml , prr_gml , & prr_rci , prv_rev , & pnr_wau , pnr_rcs , pnr_rcg , & pnr_rci , pnr_sml , pnr_gml , & pnr_rev , pnr_rcr , pnr_rfz real ( dp ), dimension ( kts : kte ) :: pri_inu , pni_inu , pri_ihm , & pni_ihm , pri_wfz , pni_wfz , & pri_rfz , pni_rfz , pri_ide , & pni_ide , pri_rci , pni_rci , & pni_sci , pni_iau , pri_iha , pni_iha real ( dp ), dimension ( kts : kte ) :: prs_iau , prs_sci , prs_rcs , prs_scw , prs_sde , prs_ihm , prs_ide real ( dp ), dimension ( kts : kte ) :: prg_scw , prg_rfz , prg_gde , & prg_gcw , prg_rci , prg_rcs , prg_rcg , prg_ihm , & png_rcs , png_rcg , png_scw , png_gde , png_rfz , png_rci , & pbg_scw , pbg_rfz , pbg_gcw , pbg_rci , pbg_rcs , pbg_rcg , & pbg_sml , pbg_gml real ( dp ), parameter :: zerod0 = 0.0d0 real ( wp ), dimension ( kts : kte ) :: pfll , pfil , pdummy real ( wp ) :: dtcfl , rainsfc , graulsfc , orhodt integer :: niter real ( wp ), dimension ( kts : kte ) :: rr_tmp , nr_tmp , rg_tmp real ( wp ), dimension ( kts : kte ) :: temp , twet , pres , qv real ( wp ), dimension ( kts : kte ) :: rc , ri , rr , rs , rg , rb real ( wp ), dimension ( kts : kte ) :: ni , nr , nc , ns , ng , nwfa , nifa real ( wp ), dimension ( kts : kte ) :: rho , rhof , rhof2 real ( wp ), dimension ( kts : kte ) :: qvs , qvsi , delqvs real ( wp ), dimension ( kts : kte ) :: satw , sati , ssatw , ssati real ( wp ), dimension ( kts : kte ) :: diffu , visco , vsc2 , & tcond , lvap , ocp , lvt2 real ( dp ), dimension ( kts : kte ) :: ilamr , ilamg , n0_r , n0_g real ( dp ) :: n0_melt real ( wp ), dimension ( kts : kte ) :: mvd_r , mvd_c , mvd_g real ( wp ), dimension ( kts : kte ) :: smob , smo2 , smo1 , smo0 , & smoc , smod , smoe , smof , smog real ( wp ), dimension ( kts : kte ) :: sed_r , sed_s , sed_g , sed_i , sed_n , sed_c , sed_b real ( wp ) :: rgvm , delta_tp , orho , lfus2 real ( wp ), dimension ( 5 ) :: onstep real ( dp ) :: n0_exp , n0_min , lam_exp , lamc , lamr , lamg real ( dp ) :: lami , ilami , ilamc real ( wp ) :: xdc , dc_b , dc_g , xdi , xdr , xds , xdg , ds_m , dg_m real ( dp ) :: dr_star , dc_star real ( wp ) :: zeta1 , zeta , taud , tau real ( wp ) :: stoke_r , stoke_s , stoke_g , stoke_i real ( wp ) :: vti , vtr , vts , vtg , vtc real ( wp ) :: xrho_g , afall , vtg1 , vtg2 real ( wp ) :: bfall = 3 * b_coeff - 1 real ( wp ), dimension ( kts : kte + 1 ) :: vtik , vtnik , vtrk , vtnrk , vtsk , vtgk , vtngk , vtck , vtnck real ( wp ), dimension ( kts : kte ) :: vts_boost real ( wp ) :: m0 , slam1 , slam2 real ( wp ) :: mrat , ils1 , ils2 , t1_vts , t2_vts , t3_vts , t4_vts , c_snow real ( wp ) :: a_ , b_ , loga_ , a1 , a2 , tf real ( wp ) :: tempc , tc0 , r_mvd1 , r_mvd2 , xkrat real ( wp ) :: dew_t , tlcl , the real ( wp ) :: xnc , xri , xni , xmi , oxmi , xrc , xrr , xnr , xrg , xng , xrb real ( wp ) :: xsat , rate_max , sump , ratio real ( wp ) :: clap , fcd , dfcd real ( wp ) :: otemp , rvs , rvs_p , rvs_pp , gamsc , alphsc , t1_evap , t1_subl real ( wp ) :: r_frac , g_frac , const_Ri , rime_dens real ( wp ) :: Ef_rw , Ef_sw , Ef_gw , Ef_rr real ( wp ) :: Ef_ra , Ef_sa , Ef_ga real ( wp ) :: dtsave , odts , odt , odzq , hgt_agl , SR real ( wp ) :: xslw1 , ygra1 , zans1 , eva_factor real ( wp ) :: melt_f , rand integer :: i , k , k2 , n , nn , nstep , k_0 , kbot , IT , iexfrq , k_melting integer , dimension ( 5 ) :: ksed1 integer :: nir , nis , nig , nii , nic , niin integer :: idx_tc , idx_t , idx_s , idx_g1 , idx_g , idx_r1 , idx_r , & idx_i1 , idx_i , idx_c , idx , idx_d , idx_n , idx_in integer , dimension ( kts : kte ) :: idx_bg , idx_table logical :: melti , no_micro logical , dimension ( kts : kte ) :: l_qc , l_qi , l_qr , l_qs , l_qg logical :: debug_flag character * 256 :: mp_debug integer :: nu_c , decfl_ !================================================================================================================= debug_flag = . false . no_micro = . true . dtsave = dt odt = 1. / dt odts = 1. / dtsave iexfrq = 1 rand = 0.0 decfl_ = 10 if ( present ( decfl )) decfl_ = decfl !================================================================================================================= ! Source/sink terms.  First 2 chars: \"pr\" represents source/sink of ! mass while \"pn\" represents source/sink of number.  Next char is one ! of \"v\" for water vapor, \"r\" for rain, \"i\" for cloud ice, \"w\" for ! cloud water, \"s\" for snow, and \"g\" for graupel.  Next chars ! represent processes: \"de\" for sublimation/deposition, \"ev\" for ! evaporation, \"fz\" for freezing, \"ml\" for melting, \"au\" for ! autoconversion, \"nu\" for ice nucleation, \"hm\" for Hallet/Mossop ! secondary ice production, and \"c\" for collection followed by the ! character for the species being collected.  ALL of these terms are ! positive (except for deposition/sublimation terms which can switch ! signs based on super/subsaturation) and are treated as negatives ! where necessary in the tendency equations. !================================================================================================================= ! TODO: Put these in derived data type and add initialization subroutine do k = kts , kte tten ( k ) = 0. qvten ( k ) = 0. qcten ( k ) = 0. qiten ( k ) = 0. qrten ( k ) = 0. qsten ( k ) = 0. qgten ( k ) = 0. ngten ( k ) = 0. qbten ( k ) = 0. niten ( k ) = 0. nrten ( k ) = 0. ncten ( k ) = 0. nwfaten ( k ) = 0. nifaten ( k ) = 0. prw_vcd ( k ) = 0. pnc_wcd ( k ) = 0. pnc_wau ( k ) = 0. pnc_rcw ( k ) = 0. pnc_scw ( k ) = 0. pnc_gcw ( k ) = 0. prv_rev ( k ) = 0. prr_wau ( k ) = 0. prr_rcw ( k ) = 0. prr_rcs ( k ) = 0. prr_rcg ( k ) = 0. prr_sml ( k ) = 0. prr_gml ( k ) = 0. prr_rci ( k ) = 0. pnr_wau ( k ) = 0. pnr_rcs ( k ) = 0. pnr_rcg ( k ) = 0. pnr_rci ( k ) = 0. pnr_sml ( k ) = 0. pnr_gml ( k ) = 0. pnr_rev ( k ) = 0. pnr_rcr ( k ) = 0. pnr_rfz ( k ) = 0. pri_inu ( k ) = 0. pni_inu ( k ) = 0. pri_ihm ( k ) = 0. pni_ihm ( k ) = 0. pri_wfz ( k ) = 0. pni_wfz ( k ) = 0. pri_rfz ( k ) = 0. pni_rfz ( k ) = 0. pri_ide ( k ) = 0. pni_ide ( k ) = 0. pri_rci ( k ) = 0. pni_rci ( k ) = 0. pni_sci ( k ) = 0. pni_iau ( k ) = 0. pri_iha ( k ) = 0. pni_iha ( k ) = 0. prs_iau ( k ) = 0. prs_sci ( k ) = 0. prs_rcs ( k ) = 0. prs_scw ( k ) = 0. prs_sde ( k ) = 0. prs_ihm ( k ) = 0. prs_ide ( k ) = 0. prg_scw ( k ) = 0. prg_rfz ( k ) = 0. prg_gde ( k ) = 0. prg_gcw ( k ) = 0. prg_rci ( k ) = 0. prg_rcs ( k ) = 0. prg_rcg ( k ) = 0. prg_ihm ( k ) = 0. !   new source/sink terms for 3-moment graupel png_scw ( k ) = 0. png_rcs ( k ) = 0. png_rcg ( k ) = 0. png_rfz ( k ) = 0. png_rci ( k ) = 0. png_gde ( k ) = 0. pbg_scw ( k ) = 0. pbg_rfz ( k ) = 0. pbg_gcw ( k ) = 0. pbg_rci ( k ) = 0. pbg_rcs ( k ) = 0. pbg_rcg ( k ) = 0. pbg_sml ( k ) = 0. pbg_gml ( k ) = 0. pna_rca ( k ) = 0. pna_sca ( k ) = 0. pna_gca ( k ) = 0. pnd_rcd ( k ) = 0. pnd_scd ( k ) = 0. pnd_gcd ( k ) = 0. if ( present ( pfil1 )) pfil1 ( k ) = 0. if ( present ( pfll1 )) pfll1 ( k ) = 0. pfil ( k ) = 0. pfll ( k ) = 0. pdummy ( k ) = 0. enddo #if defined(mpas) do k = kts , kte rainprod ( k ) = 0. evapprod ( k ) = 0. enddo #endif #if defined(ccpp_default) !Diagnostics if ( ext_diag ) then do k = kts , kte !vtsk1(k) = 0. !txrc1(k) = 0. !txri1(k) = 0. prw_vcdc1 ( k ) = 0. prw_vcde1 ( k ) = 0. tpri_inu1 ( k ) = 0. tpri_ide1_d ( k ) = 0. tpri_ide1_s ( k ) = 0. tprs_ide1 ( k ) = 0. tprs_sde1_d ( k ) = 0. tprs_sde1_s ( k ) = 0. tprg_gde1_d ( k ) = 0. tprg_gde1_s ( k ) = 0. tpri_iha1 ( k ) = 0. tpri_wfz1 ( k ) = 0. tpri_rfz1 ( k ) = 0. tprg_rfz1 ( k ) = 0. tprg_scw1 ( k ) = 0. tprs_scw1 ( k ) = 0. tprg_rcs1 ( k ) = 0. tprs_rcs1 ( k ) = 0. tprr_rci1 ( k ) = 0. tprg_rcg1 ( k ) = 0. tprw_vcd1_c ( k ) = 0. tprw_vcd1_e ( k ) = 0. tprr_sml1 ( k ) = 0. tprr_gml1 ( k ) = 0. tprr_rcg1 ( k ) = 0. tprr_rcs1 ( k ) = 0. tprv_rev1 ( k ) = 0. tten1 ( k ) = 0. qvten1 ( k ) = 0. qrten1 ( k ) = 0. qsten1 ( k ) = 0. qgten1 ( k ) = 0. qiten1 ( k ) = 0. niten1 ( k ) = 0. nrten1 ( k ) = 0. ncten1 ( k ) = 0. qcten1 ( k ) = 0. enddo endif #endif !..Bug fix (2016Jun15), prevent use of uninitialized value(s) of snow moments. do k = kts , kte smo0 ( k ) = 0. smo1 ( k ) = 0. smo2 ( k ) = 0. smob ( k ) = 0. smoc ( k ) = 0. smod ( k ) = 0. smoe ( k ) = 0. smof ( k ) = 0. smog ( k ) = 0. ns ( k ) = 0. mvd_r ( k ) = 0. mvd_c ( k ) = 0. enddo !================================================================================================================= ! Convert microphysics variables to concentrations (kg / m&#94;3 and # / m&#94;3) do k = kts , kte temp ( k ) = t1d ( k ) qv ( k ) = max ( min_qv , qv1d ( k )) pres ( k ) = p1d ( k ) rho ( k ) = RoverRv * pres ( k ) / ( r * temp ( k ) * ( qv ( k ) + RoverRv )) ! CCPP version has rho(k) multiplier for min and max ! nwfa(k) = max(11.1e6, min(9999.e6, nwfa1d(k)*rho(k))) ! nifa(k) = max(nain1*0.01, min(9999.e6, nifa1d(k)*rho(k))) nwfa ( k ) = max ( nwfa_default * rho ( k ), min ( aero_max * rho ( k ), nwfa1d ( k ) * rho ( k ))) nifa ( k ) = max ( nifa_default * rho ( k ), min ( aero_max * rho ( k ), nifa1d ( k ) * rho ( k ))) ! From CCPP version mvd_r ( k ) = D0r mvd_c ( k ) = D0c if ( qc1d ( k ) . gt . R1 ) then no_micro = . false . rc ( k ) = qc1d ( k ) * rho ( k ) nc ( k ) = max ( 2. , min ( nc1d ( k ) * rho ( k ), nt_c_max )) l_qc ( k ) = . true . if ( nc ( k ). gt . 1000 0.e6 ) then nu_c = 2 elseif ( nc ( k ). lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / nc ( k )) + 2 rand = 0.0 if ( present ( rand2 )) then rand = rand2 endif nu_c = max ( 2 , min ( nu_c + nint ( rand ), 15 )) endif lamc = ( nc ( k ) * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / rc ( k )) ** obmr xDc = ( bm_r + nu_c + 1. ) / lamc if ( xDc . lt . D0c ) then lamc = cce ( 2 , nu_c ) / D0c elseif ( xDc . gt . D0r * 2. ) then lamc = cce ( 2 , nu_c ) / ( D0r * 2. ) endif nc ( k ) = min ( real ( nt_c_max , kind = dp ), ccg ( 1 , nu_c ) * ocg2 ( nu_c ) * rc ( k ) / am_r * lamc ** bm_r ) ! CCPP version has different values of Nt_c for land/ocean if (. not .( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then nc ( k ) = Nt_c if ( present ( lsml )) then if ( lsml == 1 ) then nc ( k ) = Nt_c_l else nc ( k ) = Nt_c_o endif endif endif else qc1d ( k ) = 0.0 nc1d ( k ) = 0.0 rc ( k ) = R1 nc ( k ) = 2. L_qc ( k ) = . false . endif if ( qi1d ( k ) . gt . R1 ) then no_micro = . false . ri ( k ) = qi1d ( k ) * rho ( k ) ni ( k ) = max ( r2 , ni1d ( k ) * rho ( k )) if ( ni ( k ). le . r2 ) then lami = cie ( 2 ) / 5.e-6 ni ( k ) = min ( max_ni , cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i ) endif L_qi ( k ) = . true . lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 5.E-6 ) then lami = cie ( 2 ) / 5.E-6 ni ( k ) = min ( max_ni , cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i ) elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 ni ( k ) = cig ( 1 ) * oig2 * ri ( k ) / am_i * lami ** bm_i endif else qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif if ( qr1d ( k ) . gt . R1 ) then no_micro = . false . rr ( k ) = qr1d ( k ) * rho ( k ) nr ( k ) = max ( R2 , nr1d ( k ) * rho ( k )) if ( nr ( k ). le . R2 ) then mvd_r ( k ) = 1.0E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if ( qs1d ( k ) . gt . R1 ) then no_micro = . false . rs ( k ) = qs1d ( k ) * rho ( k ) L_qs ( k ) = . true . else qs1d ( k ) = 0.0 rs ( k ) = R1 L_qs ( k ) = . false . endif if ( qg1d ( k ) . gt . R1 ) then no_micro = . false . L_qg ( k ) = . true . rg ( k ) = qg1d ( k ) * rho ( k ) ng ( k ) = max ( r2 , ng1d ( k ) * rho ( k )) rb ( k ) = max ( qg1d ( k ) / rho_g ( nrhg ), qb1d ( k )) rb ( k ) = min ( qg1d ( k ) / rho_g ( 1 ), rb ( k )) qb1d ( k ) = rb ( k ) idx_bg ( k ) = max ( 1 , min ( nint ( qg1d ( k ) / rb ( k ) * 0.01 ) + 1 , nrhg )) idx_table ( k ) = idx_bg ( k ) if ( ng ( k ). le . R2 ) then mvd_g ( k ) = 1.5E-3 lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) ng ( k ) = cgg ( 2 , 1 ) * ogg3 * rg ( k ) * lamg ** bm_g / am_g ( idx_bg ( k )) endif lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng ( k ) / rg ( k )) ** obmg mvd_g ( k ) = ( 3.0 + mu_g + 0.672 ) / lamg if ( mvd_g ( k ) . gt . 2 5.4E-3 ) then mvd_g ( k ) = 2 5.4E-3 lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) ng ( k ) = cgg ( 2 , 1 ) * ogg3 * rg ( k ) * lamg ** bm_g / am_g ( idx_bg ( k )) elseif ( mvd_g ( k ) . lt . D0r ) then mvd_g ( k ) = D0r lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) ng ( k ) = cgg ( 2 , 1 ) * ogg3 * rg ( k ) * lamg ** bm_g / am_g ( idx_bg ( k )) endif else qg1d ( k ) = 0.0 ng1d ( k ) = 0.0 qb1d ( k ) = 0.0 idx_bg ( k ) = nrhg idx_table ( k ) = idx_bg ( k ) rg ( k ) = R1 ng ( k ) = R2 rb ( k ) = R1 / rho ( k ) / rho_g ( NRHG ) L_qg ( k ) = . false . endif if (. not . tempo_init_cfgs % hailaware_flag ) then idx_bg ( k ) = idx_bg1 idx_table ( k ) = idx_bg ( k ) ! If dimNRHG = 1, set idx_table(k) = 1, ! otherwise idx_bg1 ! if(.not. using_hail_aware_table) then !     idx_table(k) = 1 ! endif endif enddo !     if (debug_flag) then !      write(mp_debug,*) 'DEBUG-VERBOSE at (i,j) ', ii, ', ', jj !      CALL wrf_debug(550, mp_debug) !      do k = kts, kte !        write(mp_debug, '(a,i3,f8.2,1x,f7.2,1x, 11(1x,e13.6))')        & !    &              'VERBOSE: ', k, pres(k)*0.01, temp(k)-273.15, qv(k), rc(k), rr(k), ri(k), rs(k), rg(k), nc(k), nr(k), ni(k), nwfa(k), nifa(k) !        CALL wrf_debug(550, mp_debug) !      enddo !     endif !================================================================================================================= ! Derive various thermodynamic variables frequently used. ! Saturation vapor pressure (mixing ratio) over liquid/ice comes from ! Flatau et al. 1992; enthalpy (latent heat) of vaporization from ! Bohren & Albrecht 1998; others from Pruppacher & Klett 1978. do k = kts , kte tempc = temp ( k ) - 27 3.15 rhof ( k ) = sqrt ( rho_not / rho ( k )) rhof2 ( k ) = sqrt ( rhof ( k )) qvs ( k ) = calc_rslf ( pres ( k ), temp ( k )) delqvs ( k ) = max ( 0.0 , calc_rslf ( pres ( k ), 27 3.15 ) - qv ( k )) if ( tempc . le . 0.0 ) then qvsi ( k ) = calc_rsif ( pres ( k ), temp ( k )) else qvsi ( k ) = qvs ( k ) endif satw ( k ) = qv ( k ) / qvs ( k ) sati ( k ) = qv ( k ) / qvsi ( k ) ssatw ( k ) = satw ( k ) - 1. ssati ( k ) = sati ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 if ( abs ( ssati ( k )). lt . eps ) ssati ( k ) = 0.0 if ( no_micro . and . ssati ( k ). gt . 0.0 ) no_micro = . false . diffu ( k ) = 2.11e-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0e-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2e-5 * tempc * tempc ) * 1.0e-5 endif ocp ( k ) = 1. / ( cp2 * ( 1. + 0.887 * qv ( k ))) vsc2 ( k ) = sqrt ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0e-5 * 41 8.936 enddo !================================================================================================================= !..If no existing hydrometeor species and no chance to initiate ice or !.. condense cloud water, just exit quickly! if ( no_micro ) return !..Calculate y-intercept, slope, and useful moments for snow. if (. not . iiwarm ) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = min ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate 0th moment.  Represents snow number concentration. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 5 ) * tc0 * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 5 ) * tc0 * tc0 + sb ( 9 ) * tc0 * tc0 * tc0 smo0 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1st moment.  Useful for depositional growth and melting. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) & + sa ( 4 ) * tc0 + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) + sa ( 7 ) * tc0 * tc0 & + sa ( 8 ) * tc0 + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) + sb ( 4 ) * tc0 & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) & + sb ( 7 ) * tc0 * tc0 + sb ( 8 ) * tc0 & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) smo1 ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate snow number concentration (explicit integral, not smo0) M0 = smob ( k ) / smoc ( k ) Mrat = smob ( k ) * M0 * M0 * M0 slam1 = M0 * Lam0 slam2 = M0 * Lam1 ns ( k ) = Mrat * Kap0 / slam1 & + Mrat * Kap1 * M0 ** mu_s * csg ( 15 ) / slam2 ** cse ( 15 ) !..Calculate bv_s+2 (th) moment.  Useful for riming. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 13 ) & + sa ( 4 ) * tc0 * cse ( 13 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 13 ) * cse ( 13 ) + sa ( 7 ) * tc0 * tc0 * cse ( 13 ) & + sa ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 13 ) + sb ( 4 ) * tc0 * cse ( 13 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 13 ) * cse ( 13 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 13 ) + sb ( 8 ) * tc0 * cse ( 13 ) * cse ( 13 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 13 ) * cse ( 13 ) * cse ( 13 ) smoe ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 16 ) & + sa ( 4 ) * tc0 * cse ( 16 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 16 ) * cse ( 16 ) + sa ( 7 ) * tc0 * tc0 * cse ( 16 ) & + sa ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 16 ) + sb ( 4 ) * tc0 * cse ( 16 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 16 ) * cse ( 16 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 16 ) + sb ( 8 ) * tc0 * cse ( 16 ) * cse ( 16 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 16 ) * cse ( 16 ) * cse ( 16 ) smof ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s + bv_s+2 (th) moment.  Useful for riming into graupel. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 17 ) & + sa ( 4 ) * tc0 * cse ( 17 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 17 ) * cse ( 17 ) + sa ( 7 ) * tc0 * tc0 * cse ( 17 ) & + sa ( 8 ) * tc0 * cse ( 17 ) * cse ( 17 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 17 ) * cse ( 17 ) * cse ( 17 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 17 ) + sb ( 4 ) * tc0 * cse ( 17 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 17 ) * cse ( 17 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 17 ) + sb ( 8 ) * tc0 * cse ( 17 ) * cse ( 17 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 17 ) * cse ( 17 ) * cse ( 17 ) smog ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng ( k ) / rg ( k )) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = ng ( k ) * ogg2 * lamg ** cge ( 2 , 1 ) enddo ! do k = kte, kts, -1 !     ygra1 = alog10(max(1.e-9, rg(k))) !     zans1 = 3.4 + 2./7.*(ygra1+8.) + rand1 !     N0_exp = 10.**(zans1) !     N0_exp = max(dble(gonv_min), min(N0_exp, dble(gonv_max))) !     lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1 !     lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg !     ilamg(k) = 1./lamg !     N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2) !  enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !================================================================================================================= !..Compute warm-rain process terms (except evap done later). !+---+-----------------------------------------------------------------+ do k = kts , kte !..Rain self-collection follows Seifert, 1994 and drop break-up !.. follows Verlinde and Cotton, 1993.                                        RAIN2M if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r ) then Ef_rr = max ( - 0.1 , 1.0 - exp ( 230 0.0 * ( mvd_r ( k ) - 195 0.0e-6 ))) !!!                Ef_rr = 1.0 - exp(2300.0*(mvd_r(k)-1950.0E-6)) pnr_rcr ( k ) = Ef_rr * 2.0 * nr ( k ) * rr ( k ) endif mvd_c ( k ) = D0c if ( l_qc ( k )) then if ( nc ( k ). gt . 1000 0.e6 ) then nu_c = 2 elseif ( nc ( k ). lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / nc ( k )) + 2 rand = 0.0 if ( present ( rand2 )) then rand = rand2 endif nu_c = max ( 2 , min ( nu_c + nint ( rand ), 15 )) endif xdc = max ( D0c * 1.e6 , (( rc ( k ) / ( am_r * nc ( k ))) ** obmr ) * 1.e6 ) lamc = ( nc ( k ) * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / rc ( k )) ** obmr mvd_c ( k ) = ( 3.0 + nu_c + 0.672 ) / lamc mvd_c ( k ) = max ( d0c , min ( mvd_c ( k ), d0r )) endif !..Autoconversion follows Berry & Reinhardt (1974) with characteristic !.. diameters correctly computed from gamma distrib of cloud droplets. if ( rc ( k ). gt . 0.01e-3 ) then Dc_g = (( ccg ( 3 , nu_c ) * ocg2 ( nu_c )) ** obmr / lamc ) * 1.E6 Dc_b = ( xDc * xDc * xDc * Dc_g * Dc_g * Dc_g - xDc * xDc * xDc * xDc * xDc * xDc ) & ** ( 1. / 6. ) zeta1 = 0.5 * (( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 ) & + abs ( 6.25E-6 * xDc * Dc_b * Dc_b * Dc_b - 0.4 )) zeta = 0.027 * rc ( k ) * zeta1 taud = 0.5 * (( 0.5 * Dc_b - 7.5 ) + abs ( 0.5 * Dc_b - 7.5 )) + R1 tau = 3.72 / ( rc ( k ) * taud ) prr_wau ( k ) = zeta / tau prr_wau ( k ) = min ( real ( rc ( k ) * odts , kind = dp ), prr_wau ( k )) pnr_wau ( k ) = prr_wau ( k ) / ( am_r * nu_c * 1 0. * D0r * D0r * D0r ) ! RAIN2M pnc_wau ( k ) = min ( real ( nc ( k ) * odts , kind = dp ), prr_wau ( k ) / ( am_r * mvd_c ( k ) * mvd_c ( k ) * mvd_c ( k ))) ! Qc2M endif !>  - Rain collecting cloud water.  In CE, assume Dc<<Dr and vtc=~0. if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r . and . mvd_c ( k ). gt . D0c ) then lamr = 1. / ilamr ( k ) idx = 1 + int ( nbr * log ( real ( mvd_r ( k ) / Dr ( 1 ), kind = dp )) / log ( real ( Dr ( nbr ) / Dr ( 1 ), kind = dp ))) idx = min ( idx , nbr ) Ef_rw = t_Efrw ( idx , int ( mvd_c ( k ) * 1.E6 )) prr_rcw ( k ) = rhof ( k ) * t1_qr_qc * Ef_rw * rc ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) prr_rcw ( k ) = min ( real ( rc ( k ) * odts , kind = dp ), prr_rcw ( k )) pnc_rcw ( k ) = rhof ( k ) * t1_qr_qc * Ef_rw * nc ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) ! Qc2M pnc_rcw ( k ) = min ( real ( nc ( k ) * odts , kind = dp ), pnc_rcw ( k )) endif !>  - Rain collecting aerosols, wet scavenging. if ( L_qr ( k ) . and . mvd_r ( k ). gt . D0r ) then Ef_ra = Eff_aero ( mvd_r ( k ), 0.04E-6 , visco ( k ), rho ( k ), temp ( k ), 'r' ) lamr = 1. / ilamr ( k ) pna_rca ( k ) = rhof ( k ) * t1_qr_qc * Ef_ra * nwfa ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) pna_rca ( k ) = min ( real ( nwfa ( k ) * odts , kind = dp ), pna_rca ( k )) Ef_ra = Eff_aero ( mvd_r ( k ), 0.8E-6 , visco ( k ), rho ( k ), temp ( k ), 'r' ) pnd_rcd ( k ) = rhof ( k ) * t1_qr_qc * Ef_ra * nifa ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) pnd_rcd ( k ) = min ( real ( nifa ( k ) * odts , kind = dp ), pnd_rcd ( k )) endif enddo !================================================================================================================= !..Compute all frozen hydrometeor species' process terms. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte vts_boost ( k ) = 1.0 xDs = 0.0 if ( L_qs ( k )) xDs = smoc ( k ) / smob ( k ) !                orho = 1./rho(k) ! if (L_qs(k)) then !     xDs = smoc(k) / smob(k) !     rho_s2 = max(rho_g(1), min(0.13/xDs, rho_i-100.)) ! else !     xDs = 0. !     rho_s2 = 100. ! endif !..Temperature lookup table indexes. tempc = temp ( k ) - 27 3.15 idx_tc = max ( 1 , min ( nint ( - tempc ), 45 ) ) idx_t = int ( ( tempc - 2.5 ) / 5. ) - 1 idx_t = max ( 1 , - idx_t ) idx_t = min ( idx_t , ntb_t ) it = max ( 1 , min ( nint ( - tempc ), 31 ) ) !>  - Cloud water lookup table index. if ( rc ( k ). gt . r_c ( 1 )) then nic = nint ( log10 ( rc ( k ))) do_loop_rc : do nn = nic - 1 , nic + 1 n = nn if ( ( rc ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( rc ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_rc enddo do_loop_rc idx_c = int ( rc ( k ) / 1 0. ** n ) + 10 * ( n - nic2 ) - ( n - nic2 ) idx_c = max ( 1 , min ( idx_c , ntb_c )) else idx_c = 1 endif !>  - Cloud droplet number lookup table index. idx_n = nint ( 1.0 + real ( nbc , kind = wp ) * log ( real ( nc ( k ) / t_Nc ( 1 ), kind = dp )) / nic1 ) idx_n = max ( 1 , min ( idx_n , nbc )) !>  - Cloud ice lookup table indexes. if ( ri ( k ). gt . r_i ( 1 )) then nii = nint ( log10 ( ri ( k ))) do_loop_ri : do nn = nii - 1 , nii + 1 n = nn if ( ( ri ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( ri ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_ri enddo do_loop_ri idx_i = int ( ri ( k ) / 1 0. ** n ) + 10 * ( n - nii2 ) - ( n - nii2 ) idx_i = max ( 1 , min ( idx_i , ntb_i )) else idx_i = 1 endif if ( ni ( k ). gt . Nt_i ( 1 )) then nii = nint ( log10 ( ni ( k ))) do_loop_ni : do nn = nii - 1 , nii + 1 n = nn if ( ( ni ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( ni ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_ni enddo do_loop_ni idx_i1 = int ( ni ( k ) / 1 0. ** n ) + 10 * ( n - nii3 ) - ( n - nii3 ) idx_i1 = max ( 1 , min ( idx_i1 , ntb_i1 )) else idx_i1 = 1 endif !>  - Rain lookup table indexes. if ( rr ( k ). gt . r_r ( 1 )) then nir = nint ( log10 ( rr ( k ))) do_loop_rr : do nn = nir - 1 , nir + 1 n = nn if ( ( rr ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( rr ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_rr enddo do_loop_rr idx_r = int ( rr ( k ) / 1 0. ** n ) + 10 * ( n - nir2 ) - ( n - nir2 ) idx_r = max ( 1 , min ( idx_r , ntb_r )) lamr = 1. / ilamr ( k ) lam_exp = lamr * ( crg ( 3 ) * org2 * org1 ) ** bm_r N0_exp = org1 * rr ( k ) / am_r * lam_exp ** cre ( 1 ) nir = nint ( log10 ( real ( N0_exp , kind = dp ))) do_loop_nr : do nn = nir - 1 , nir + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_nr enddo do_loop_nr idx_r1 = int ( N0_exp / 1 0. ** n ) + 10 * ( n - nir3 ) - ( n - nir3 ) idx_r1 = max ( 1 , min ( idx_r1 , ntb_r1 )) else idx_r = 1 idx_r1 = ntb_r1 endif !>  - Snow lookup table index. if ( rs ( k ). gt . r_s ( 1 )) then nis = nint ( log10 ( rs ( k ))) do_loop_rs : do nn = nis - 1 , nis + 1 n = nn if ( ( rs ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( rs ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_rs enddo do_loop_rs idx_s = int ( rs ( k ) / 1 0. ** n ) + 10 * ( n - nis2 ) - ( n - nis2 ) idx_s = max ( 1 , min ( idx_s , ntb_s )) else idx_s = 1 endif !>  - Graupel lookup table index. if ( rg ( k ). gt . r_g ( 1 )) then nig = nint ( log10 ( rg ( k ))) do_loop_rg : do nn = nig - 1 , nig + 1 n = nn if ( ( rg ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( rg ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_rg enddo do_loop_rg idx_g = int ( rg ( k ) / 1 0. ** n ) + 10 * ( n - nig2 ) - ( n - nig2 ) idx_g = max ( 1 , min ( idx_g , ntb_g )) lamg = 1. / ilamg ( k ) lam_exp = lamg * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** bm_g N0_exp = ogg1 * rg ( k ) / am_g ( idx_bg ( k )) * lam_exp ** cge ( 1 , 1 ) nig = nint ( log10 ( real ( N0_exp , kind = dp ))) do_loop_ng : do nn = nig - 1 , nig + 1 n = nn if ( ( N0_exp / 1 0. ** nn ). ge . 1.0 . and . ( N0_exp / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_ng enddo do_loop_ng idx_g1 = int ( N0_exp / 1 0. ** n ) + 10 * ( n - nig3 ) - ( n - nig3 ) idx_g1 = max ( 1 , min ( idx_g1 , ntb_g1 )) else idx_g = 1 idx_g1 = ntb_g1 endif !..Deposition/sublimation prefactor (from Srivastava & Coen 1992). otemp = 1. / temp ( k ) rvs = rho ( k ) * qvsi ( k ) rvs_p = rvs * otemp * ( lsub * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lsub * otemp * oRv - 1. ) & * otemp * ( lsub * otemp * oRv - 1. ) & + ( - 2. * lsub * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lsub * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = max ( 1.E-9 , alphsc ) xsat = ssati ( k ) if ( abs ( xsat ). lt . 1.E-9 ) xsat = 0. t1_subl = 4. * PI * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) !..Snow collecting cloud water.  In CE, assume Dc<<Ds and vtc=~0. if ( L_qc ( k ) . and . mvd_c ( k ). gt . D0c ) then ! xDs = 0.0 ! if (L_qs(k)) xDs = smoc(k) / smob(k) if ( xDs > d0s ) then idx = 1 + int ( nbs * log ( real ( xDs / Ds ( 1 ), kind = dp )) / log ( real ( Ds ( nbs ) / Ds ( 1 ), kind = dp ))) idx = min ( idx , nbs ) Ef_sw = t_Efsw ( idx , int ( mvd_c ( k ) * 1.E6 )) prs_scw ( k ) = rhof ( k ) * t1_qs_qc * Ef_sw * rc ( k ) * smoe ( k ) prs_scw ( k ) = min ( real ( rc ( k ) * odts , kind = dp ), prs_scw ( k )) pnc_scw ( k ) = rhof ( k ) * t1_qs_qc * Ef_sw * nc ( k ) * smoe ( k ) ! Qc2M pnc_scw ( k ) = min ( real ( nc ( k ) * odts , kind = dp ), pnc_scw ( k )) endif !..Graupel collecting cloud water.  In CE, assume Dc<<Dg and vtc=~0. if ( rg ( k ). ge . r_g ( 1 ) . and . mvd_c ( k ). gt . D0c ) then xDg = ( bm_g + mu_g + 1. ) * ilamg ( k ) vtg = rhof ( k ) * av_g ( idx_bg ( k )) * cgg ( 6 , idx_bg ( k )) * ogg3 * ilamg ( k ) ** bv_g ( idx_bg ( k )) stoke_g = mvd_c ( k ) * mvd_c ( k ) * vtg * rho_w2 / ( 9. * visco ( k ) * xDg ) !..Rime density formula of Cober and List (1993) also used by Milbrandt and Morrison (2014). const_Ri = - 1. * ( mvd_c ( k ) * 0.5E6 ) * vtg / MIN ( - 0.1 , tempc ) const_Ri = MAX ( 0.1 , MIN ( const_Ri , 1 0. )) rime_dens = ( 0.051 + 0.114 * const_Ri - 0.0055 * const_Ri * const_Ri ) * 100 0. ! CCPP version has check on xDg > D0g if ( xDg > D0g ) then if ( stoke_g . ge . 0.4 . and . stoke_g . le . 1 0. ) then Ef_gw = 0.55 * log10 ( 2.51 * stoke_g ) elseif ( stoke_g . lt . 0.4 ) then Ef_gw = 0.0 elseif ( stoke_g . gt . 10 ) then Ef_gw = 0.77 endif ! Not sure what to do here - hail increases size rapidly here below melting level. if ( temp ( k ). gt . T_0 ) Ef_gw = Ef_gw * 0.1 t1_qg_qc = PI * . 25 * av_g ( idx_bg ( k )) * cgg ( 9 , idx_bg ( k )) prg_gcw ( k ) = rhof ( k ) * t1_qg_qc * Ef_gw * rc ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 , idx_bg ( k )) pnc_gcw ( k ) = rhof ( k ) * t1_qg_qc * Ef_gw * nc ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 , idx_bg ( k )) ! Qc2M pnc_gcw ( k ) = min ( real ( nc ( k ) * odts , kind = dp ), pnc_gcw ( k )) if ( temp ( k ). lt . T_0 ) pbg_gcw ( k ) = prg_gcw ( k ) / rime_dens ! CCPP version has end check on xDg > D0g endif endif endif !>  - Snow and graupel collecting aerosols, wet scavenging. if ( rs ( k ) . gt . r_s ( 1 )) then Ef_sa = Eff_aero ( xDs , 0.04E-6 , visco ( k ), rho ( k ), temp ( k ), 's' ) pna_sca ( k ) = rhof ( k ) * t1_qs_qc * Ef_sa * nwfa ( k ) * smoe ( k ) pna_sca ( k ) = min ( real ( nwfa ( k ) * odts , kind = dp ), pna_sca ( k )) Ef_sa = Eff_aero ( xDs , 0.8E-6 , visco ( k ), rho ( k ), temp ( k ), 's' ) pnd_scd ( k ) = rhof ( k ) * t1_qs_qc * Ef_sa * nifa ( k ) * smoe ( k ) pnd_scd ( k ) = min ( real ( nifa ( k ) * odts , kind = dp ), pnd_scd ( k )) endif if ( rg ( k ) . gt . r_g ( 1 )) then xDg = ( bm_g + mu_g + 1. ) * ilamg ( k ) Ef_ga = Eff_aero ( xDg , 0.04E-6 , visco ( k ), rho ( k ), temp ( k ), 'g' ) t1_qg_qc = PI * . 25 * av_g ( idx_bg ( k )) * cgg ( 9 , idx_bg ( k )) pna_gca ( k ) = rhof ( k ) * t1_qg_qc * Ef_ga * nwfa ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 , idx_bg ( k )) pna_gca ( k ) = min ( real ( nwfa ( k ) * odts , kind = dp ), pna_gca ( k )) Ef_ga = Eff_aero ( xDg , 0.8E-6 , visco ( k ), rho ( k ), temp ( k ), 'g' ) pnd_gcd ( k ) = rhof ( k ) * t1_qg_qc * Ef_ga * nifa ( k ) * N0_g ( k ) & * ilamg ( k ) ** cge ( 9 , idx_bg ( k )) pnd_gcd ( k ) = min ( real ( nifa ( k ) * odts , kind = dp ), pnd_gcd ( k )) endif !..Rain collecting snow.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rr ( k ). ge . r_r ( 1 )) then if ( rs ( k ). ge . r_s ( 1 )) then if ( temp ( k ). lt . T_0 ) then prr_rcs ( k ) = - ( tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r )) prs_rcs ( k ) = tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) & - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prg_rcs ( k ) = tmr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) prr_rcs ( k ) = max ( real ( - rr ( k ) * odts , kind = dp ), prr_rcs ( k )) prs_rcs ( k ) = max ( real ( - rs ( k ) * odts , kind = dp ), prs_rcs ( k )) prg_rcs ( k ) = min ( real (( rr ( k ) + rs ( k )) * odts , kind = dp ), prg_rcs ( k )) pnr_rcs ( k ) = tnr_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & ! RAIN2M + tnr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tnr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) pnr_rcs ( k ) = min ( real ( nr ( k ) * odts , kind = dp ), pnr_rcs ( k )) png_rcs ( k ) = pnr_rcs ( k ) !-GT        pbg_rcs(k) = prg_rcs(k)/(0.5*(rho_i+rho_s)) pbg_rcs ( k ) = prg_rcs ( k ) / rho_i else prs_rcs ( k ) = - tcs_racs1 ( idx_s , idx_t , idx_r1 , idx_r ) & - tms_sacr1 ( idx_s , idx_t , idx_r1 , idx_r ) & + tmr_racs2 ( idx_s , idx_t , idx_r1 , idx_r ) & + tcr_sacr2 ( idx_s , idx_t , idx_r1 , idx_r ) prs_rcs ( k ) = max ( real ( - rs ( k ) * odts , kind = dp ), prs_rcs ( k )) prr_rcs ( k ) = - prs_rcs ( k ) !pnr_rcs(k) = tnr_racs2(idx_s,idx_t,idx_r1,idx_r)            &   ! RAIN2M !   + tnr_sacr2(idx_s,idx_t,idx_r1,idx_r) endif !pnr_rcs(k) = MIN(DBLE(nr(k)*odts), pnr_rcs(k)) endif !..Rain collecting graupel.  Cannot assume Wisner (1972) approximation !.. or Mizuno (1990) approach so we solve the CE explicitly and store !.. results in lookup table. if ( rg ( k ). ge . r_g ( 1 )) then if ( temp ( k ). lt . T_0 ) then prg_rcg ( k ) = tmr_racg ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) & + tcr_gacr ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) prg_rcg ( k ) = min ( real ( rr ( k ) * odts , kind = dp ), prg_rcg ( k )) prr_rcg ( k ) = - prg_rcg ( k ) pnr_rcg ( k ) = tnr_racg ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) & ! RAIN2M + tnr_gacr ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) pnr_rcg ( k ) = min ( real ( nr ( k ) * odts , kind = dp ), pnr_rcg ( k )) !-GT        pbg_rcg(k) = prg_rcg(k)/(0.5*(rho_i+rho_g(idx_bg(k)))) pbg_rcg ( k ) = prg_rcg ( k ) / rho_i else prr_rcg ( k ) = tcg_racg ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) prr_rcg ( k ) = min ( real ( rg ( k ) * odts , kind = dp ), prr_rcg ( k )) prg_rcg ( k ) = - prr_rcg ( k ) png_rcg ( k ) = tnr_racg ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) !!!                    + tnr_gacr(idx_g1,idx_g,idx_table(k),idx_r1,idx_r) png_rcg ( k ) = min ( real ( ng ( k ) * odts , kind = dp ), png_rcg ( k )) pbg_rcg ( k ) = prg_rcg ( k ) / rho_g ( idx_bg ( k )) !..Put in explicit drop break-up due to collisions. pnr_rcg ( k ) = - 1.5 * tnr_gacr ( idx_g1 , idx_g , idx_table ( k ), idx_r1 , idx_r ) ! RAIN2M endif endif endif !+---+-----------------------------------------------------------------+ !..Next IF block handles only those processes below 0C. !+---+-----------------------------------------------------------------+ if ( temp ( k ). lt . T_0 ) then vts_boost ( k ) = 1.0 rate_max = ( qv ( k ) - qvsi ( k )) * rho ( k ) * odts * 0.999 !+---+---------------- BEGIN NEW ICE NUCLEATION -----------------------+ !..Freezing of supercooled water (rain or cloud) is influenced by dust !.. but still using Bigg 1953 with a temperature adjustment of a few !.. degrees depending on dust concentration.  A default value by way !.. of idx_IN is 1.0 per Liter of air is used when dustyIce flag is !.. false.  Next, a combination of deposition/condensation freezing !.. using DeMott et al (2010) dust nucleation when water saturated or !.. Phillips et al (2008) when below water saturation; else, without !.. dustyIce flag, use the previous Cooper (1986) temperature-dependent !.. value.  Lastly, allow homogeneous freezing of deliquesced aerosols !.. following Koop et al. (2001, Nature). !.. Implemented by T. Eidhammer and G. Thompson 2012Dec18 !+---+-----------------------------------------------------------------+ ! if (dustyIce) then if ( dustyIce . and . ( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then xni = iceDeMott ( tempc , qvs ( k ), qvs ( k ), qvsi ( k ), rho ( k ), nifa ( k )) else xni = 1.0 * 100 0. ! Default is 1.0 per Liter endif !>  - Ice nuclei lookup table index. if ( xni . gt . Nt_IN ( 1 )) then niin = nint ( log10 ( xni )) do_loop_xni : do nn = niin - 1 , niin + 1 n = nn if ( ( xni / 1 0. ** nn ). ge . 1.0 . and . ( xni / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_xni enddo do_loop_xni idx_IN = int ( xni / 1 0. ** n ) + 10 * ( n - niin2 ) - ( n - niin2 ) idx_IN = max ( 1 , min ( idx_IN , ntb_IN )) else idx_IN = 1 endif !..Freezing of water drops into graupel/cloud ice (Bigg 1953). if ( rr ( k ). gt . r_r ( 1 )) then prg_rfz ( k ) = tpg_qrfz ( idx_r , idx_r1 , idx_tc , idx_IN ) * odts pri_rfz ( k ) = tpi_qrfz ( idx_r , idx_r1 , idx_tc , idx_IN ) * odts pni_rfz ( k ) = tni_qrfz ( idx_r , idx_r1 , idx_tc , idx_IN ) * odts pnr_rfz ( k ) = tnr_qrfz ( idx_r , idx_r1 , idx_tc , idx_IN ) * odts ! RAIN2M prg_rfz ( k ) = min ( real ( rr ( k ) * odts , kind = dp ), prg_rfz ( k )) pnr_rfz ( k ) = min ( real ( nr ( k ) * odts , kind = dp ), pnr_rfz ( k )) png_rfz ( k ) = pnr_rfz ( k ) * max ( min (( 1 0. ** ( - 0.1 * w1d ( k )) + 0.1 ), 1.0 ), 0.1 ) elseif ( rr ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_rfz ( k ) = rr ( k ) * odts pni_rfz ( k ) = nr ( k ) * odts endif pbg_rfz ( k ) = prg_rfz ( k ) / rho_i if ( rc ( k ). gt . r_c ( 1 )) then pri_wfz ( k ) = tpi_qcfz ( idx_c , idx_n , idx_tc , idx_IN ) * odts pri_wfz ( k ) = min ( real ( rc ( k ) * odts , kind = dp ), pri_wfz ( k )) pni_wfz ( k ) = tni_qcfz ( idx_c , idx_n , idx_tc , idx_IN ) * odts pni_wfz ( k ) = min ( real ( nc ( k ) * odts , kind = dp ), pri_wfz ( k ) / ( 2.0_dp * xm0i ), pni_wfz ( k )) elseif ( rc ( k ). gt . R1 . and . temp ( k ). lt . HGFR ) then pri_wfz ( k ) = rc ( k ) * odts pni_wfz ( k ) = nc ( k ) * odts endif !..Deposition nucleation of dust/mineral from DeMott et al (2010) !.. we may need to relax the temperature and ssati constraints. if ( ( ssati ( k ). ge . demott_nuc_ssati ) . or . ( ssatw ( k ). gt . eps & . and . temp ( k ). lt . 25 3.15 ) ) then if ( dustyIce . and . ( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then xnc = iceDeMott ( tempc , qv ( k ), qvs ( k ), qvsi ( k ), rho ( k ), nifa ( k )) rand = 0.0 if ( present ( rand3 )) then rand = rand3 endif xnc = xnc * ( 1.0 + 5 0. * rand ) else xnc = min ( icenuc_max , tno * exp ( ato * ( t_0 - temp ( k )))) endif xni = ni ( k ) + ( pni_rfz ( k ) + pni_wfz ( k )) * dtsave pni_inu ( k ) = 0.5 * ( xnc - xni + abs ( xnc - xni )) * odts pri_inu ( k ) = min ( real ( rate_max , kind = dp ), xm0i * pni_inu ( k )) pni_inu ( k ) = pri_inu ( k ) / xm0i endif !..Freezing of aqueous aerosols based on Koop et al (2001, Nature) xni = smo0 ( k ) + ni ( k ) + ( pni_rfz ( k ) + pni_wfz ( k ) + pni_inu ( k )) * dtsave if (( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware ) . and . homogIce . and . & ( xni . le . max_ni ) . and .( temp ( k ). lt . 23 8. ). and .( ssati ( k ). ge . 0.4 )) then xnc = iceKoop ( temp ( k ), qv ( k ), qvs ( k ), nwfa ( k ), dtsave ) pni_iha ( k ) = xnc * odts pri_iha ( k ) = min ( real ( rate_max , kind = dp ), xm0i * 0.1 * pni_iha ( k )) pni_iha ( k ) = pri_iha ( k ) / ( xm0i * 0.1 ) endif !+---+------------------ END NEW ICE NUCLEATION -----------------------+ !..Deposition/sublimation of cloud ice (Srivastava & Coen 1992). if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = max ( real ( D0i , kind = dp ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi pri_ide ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * oig1 * cig ( 5 ) * ni ( k ) * ilami if ( pri_ide ( k ) . lt . 0.0 ) then pri_ide ( k ) = max ( real ( - ri ( k ) * odts , kind = dp ), pri_ide ( k ), real ( rate_max , kind = dp )) pni_ide ( k ) = pri_ide ( k ) * oxmi pni_ide ( k ) = max ( real ( - ni ( k ) * odts , kind = dp ), pni_ide ( k )) else pri_ide ( k ) = min ( pri_ide ( k ), real ( rate_max , kind = dp )) prs_ide ( k ) = ( 1.0_dp - tpi_ide ( idx_i , idx_i1 )) * pri_ide ( k ) pri_ide ( k ) = tpi_ide ( idx_i , idx_i1 ) * pri_ide ( k ) endif !..Some cloud ice needs to move into the snow category.  Use lookup !.. table that resulted from explicit bin representation of distrib. if ( ( idx_i . eq . ntb_i ) . or . ( xDi . gt . 5.0 * D0s ) ) then prs_iau ( k ) = ri ( k ) * . 99 * odts pni_iau ( k ) = ni ( k ) * . 95 * odts elseif ( xDi . lt . 0.1 * D0s ) then prs_iau ( k ) = 0. pni_iau ( k ) = 0. else prs_iau ( k ) = tps_iaus ( idx_i , idx_i1 ) * odts prs_iau ( k ) = min ( real ( ri ( k ) * . 99 * odts , kind = dp ), prs_iau ( k )) pni_iau ( k ) = tni_iaus ( idx_i , idx_i1 ) * odts pni_iau ( k ) = min ( real ( ni ( k ) * . 95 * odts , kind = dp ), pni_iau ( k )) endif endif !..Deposition/sublimation of snow/graupel follows Srivastava & Coen !.. (1992). if ( l_qs ( k )) then c_snow = c_sqrd + ( tempc + 1.5 ) * ( c_cube - c_sqrd ) / ( - 3 0. + 1.5 ) c_snow = max ( c_sqrd , min ( c_snow , c_cube )) prs_sde ( k ) = c_snow * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) if ( prs_sde ( k ). lt . 0. ) then prs_sde ( k ) = max ( real ( - rs ( k ) * odts , kind = dp ), prs_sde ( k ), real ( rate_max , kind = dp )) else prs_sde ( k ) = min ( prs_sde ( k ), real ( rate_max , kind = dp )) endif endif if ( l_qg ( k ) . and . ssati ( k ). lt . - eps ) then t2_qg_sd = 0.28 * sc3 * sqrt ( av_g ( idx_bg ( k ))) * cgg ( 11 , idx_bg ( k )) prg_gde ( k ) = c_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * n0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 , 1 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 , idx_bg ( k ))) if ( prg_gde ( k ). lt . 0. ) then prg_gde ( k ) = max ( real ( - rg ( k ) * odts , kind = dp ), prg_gde ( k ), real ( rate_max , kind = dp )) png_gde ( k ) = prg_gde ( k ) * ng ( k ) / rg ( k ) else prg_gde ( k ) = min ( prg_gde ( k ), real ( rate_max , kind = dp )) endif endif !..Snow collecting cloud ice.  In CE, assume Di<<Ds and vti=~0. if ( L_qi ( k )) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami xDi = max ( real ( D0i , kind = dp ), ( bm_i + mu_i + 1. ) * ilami ) xmi = am_i * xDi ** bm_i oxmi = 1. / xmi if ( rs ( k ). ge . r_s ( 1 )) then prs_sci ( k ) = t1_qs_qi * rhof ( k ) * Ef_si * ri ( k ) * smoe ( k ) pni_sci ( k ) = prs_sci ( k ) * oxmi endif !..Rain collecting cloud ice.  In CE, assume Di<<Dr and vti=~0. if ( rr ( k ). ge . r_r ( 1 ) . and . mvd_r ( k ). gt . 4. * xDi ) then lamr = 1. / ilamr ( k ) pri_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ri ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 9 ))) pnr_rci ( k ) = rhof ( k ) * t1_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & ! RAIN2M * (( lamr + fv_r ) ** ( - cre ( 9 ))) pnr_rci ( k ) = min ( real ( nr ( k ) * odts , kind = dp ), pnr_rci ( k )) png_rci ( k ) = pnr_rci ( k ) * max ( min (( 1 0. ** ( - 0.1 * w1d ( k )) + 0.1 ), 1.0 ), 0.1 ) pni_rci ( k ) = pri_rci ( k ) * oxmi prr_rci ( k ) = rhof ( k ) * t2_qr_qi * Ef_ri * ni ( k ) * N0_r ( k ) & * (( lamr + fv_r ) ** ( - cre ( 8 ))) prr_rci ( k ) = min ( real ( rr ( k ) * odts , kind = dp ), prr_rci ( k )) prg_rci ( k ) = pri_rci ( k ) + prr_rci ( k ) pbg_rci ( k ) = prg_rci ( k ) / rho_i endif endif !..Ice multiplication from rime-splinters (Hallet & Mossop 1974). if ( prg_gcw ( k ). gt . eps . and . tempc . gt . - 8.0 ) then tf = 0. if ( tempc . ge . - 5.0 . and . tempc . lt . - 3.0 ) then tf = 0.5 * ( - 3.0 - tempc ) elseif ( tempc . gt . - 8.0 . and . tempc . lt . - 5.0 ) then tf = 0.33333333 * ( 8.0 + tempc ) endif pni_ihm ( k ) = 3.5E8 * tf * prg_gcw ( k ) pri_ihm ( k ) = xm0i * pni_ihm ( k ) prs_ihm ( k ) = prs_scw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) prg_ihm ( k ) = prg_gcw ( k ) / ( prs_scw ( k ) + prg_gcw ( k )) & * pri_ihm ( k ) endif !..A portion of rimed snow converts to graupel but some remains snow. !.. Interp from 15 to 95% as riming factor increases from 2.0 to 30.0 !.. 0.028 came from (.95-.15)/(30.-2.).  This remains ad-hoc and should !.. be revisited. if ( prs_scw ( k ). gt . rime_threshold * prs_sde ( k ) . and . prs_sde ( k ). gt . eps ) then r_frac = min ( 3 0.0_dp , prs_scw ( k ) / prs_sde ( k )) g_frac = min ( rime_conversion , 0.15 + ( r_frac - 2. ) * . 028 ) vts_boost ( k ) = min ( 1.5 , 1.1 + ( r_frac - 2. ) * . 016 ) prg_scw ( k ) = g_frac * prs_scw ( k ) png_scw ( k ) = prg_scw ( k ) * smo0 ( k ) / rs ( k ) !..gt      png_scw(k) = prg_scw(k)*ns(k)/rs(k) vts = av_s * xds ** bv_s * exp ( - fv_s * xds ) const_ri = - 1. * ( mvd_c ( k ) * 0.5e6 ) * vts / min ( - 0.1 , tempc ) const_ri = max ( 0.1 , min ( const_ri , 1 0. )) rime_dens = ( 0.051 + 0.114 * const_Ri - 0.0055 * const_Ri * const_Ri ) * 100 0. if ( rime_dens . lt . 15 0. ) then ! Idea of A. Jensen g_frac = 0. prg_scw ( k ) = 0. png_scw ( k ) = 0. endif pbg_scw ( k ) = prg_scw ( k ) / ( 0.5 * ( rime_dens + rho_s2 )) prs_scw ( k ) = ( 1. - g_frac ) * prs_scw ( k ) endif else !..Melt snow and graupel and enhance from collisions with liquid. !.. We also need to sublimate snow and graupel if subsaturated. if ( L_qs ( k )) then prr_sml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * ( t1_qs_me * smo1 ( k ) + t2_qs_me * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) if ( prr_sml ( k ) . gt . 0. ) then prr_sml ( k ) = prr_sml ( k ) + 421 8. * olfus * tempc & * ( prr_rcs ( k ) + prs_scw ( k )) prr_sml ( k ) = min ( real ( rs ( k ) * odts , kind = dp ), max ( zerod0 , prr_sml ( k ))) pnr_sml ( k ) = smo0 ( k ) / rs ( k ) * prr_sml ( k ) * 1 0.0 ** ( - 0.25 * tempc ) ! RAIN2M pnr_sml ( k ) = min ( real ( smo0 ( k ) * odts , kind = dp ), pnr_sml ( k )) else prr_sml ( k ) = 0.0 pnr_sml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then prs_sde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * ( t1_qs_sd * smo1 ( k ) & + t2_qs_sd * rhof2 ( k ) * vsc2 ( k ) * smof ( k )) prs_sde ( k ) = max ( real ( - rs ( k ) * odts , kind = dp ), prs_sde ( k )) endif endif endif if ( l_qg ( k )) then n0_melt = n0_g ( k ) if (( rg ( k ) * ng ( k )) . lt . 1.e-4 ) then lamg = 1. / ilamg ( k ) n0_melt = ( 1.e-4 / rg ( k )) * ogg2 * lamg ** cge ( 2 , 1 ) endif t2_qg_me = pi * 4. * c_cube * olfus * 0.28 * sc3 * sqrt ( av_g ( idx_bg ( k ))) * cgg ( 11 , idx_bg ( k )) prr_gml ( k ) = ( tempc * tcond ( k ) - lvap0 * diffu ( k ) * delQvs ( k )) & * N0_melt * ( t1_qg_me * ilamg ( k ) ** cge ( 10 , 1 ) & + t2_qg_me * rhof2 ( k ) * vsc2 ( k ) * ilamg ( k ) ** cge ( 11 , idx_bg ( k ))) !          if (prr_gml(k) .gt. 0.) then !             prr_gml(k) = prr_gml(k) + 4218.*olfus*(twet(k)-T_0)       & !                                     * (prr_rcg(k)+prg_gcw(k)) !          endif prr_gml ( k ) = min ( real ( rg ( k ) * odts , kind = dp ), max ( 0.D0 , prr_gml ( k ))) !           pnr_gml(k) = N0_g(k)*cgg(2)*ilamg(k)**cge(2) / rg(k)         &   ! RAIN2M !                      * prr_gml(k) * 10.0**(-0.5*tempc) if ( prr_gml ( k ) . gt . 0.0 ) then melt_f = max ( 0.05 , min ( prr_gml ( k ) * dt / rg ( k ), 1.0 )) !..1000 is density water, 50 is lower limit (max ice density is 800) pbg_gml ( k ) = prr_gml ( k ) / max ( min ( melt_f * rho_g ( idx_bg ( k )), 100 0. ), 5 0. ) !-GT        pnr_gml(k) = prr_gml(k)*ng(k)/rg(k) pnr_gml ( k ) = prr_gml ( k ) * ng ( k ) / rg ( k ) * 1 0.0 ** ( - 0.33 * ( temp ( k ) - T_0 )) else prr_gml ( k ) = 0.0 pnr_gml ( k ) = 0.0 pbg_gml ( k ) = 0.0 if ( ssati ( k ). lt . 0. ) then t2_qg_sd = 0.28 * Sc3 * sqrt ( av_g ( idx_bg ( k ))) * cgg ( 11 , idx_bg ( k )) prg_gde ( k ) = C_cube * t1_subl * diffu ( k ) * ssati ( k ) * rvs & * N0_g ( k ) * ( t1_qg_sd * ilamg ( k ) ** cge ( 10 , 1 ) & + t2_qg_sd * vsc2 ( k ) * rhof2 ( k ) * ilamg ( k ) ** cge ( 11 , idx_bg ( k ))) prg_gde ( k ) = max ( real ( - rg ( k ) * odts , kind = dp ), prg_gde ( k )) png_gde ( k ) = prg_gde ( k ) * ng ( k ) / rg ( k ) endif endif endif !.. This change will be required if users run adaptive time step that !.. results in delta-t that is generally too long to allow cloud water !.. collection by snow/graupel above melting temperature. !.. Credit to Bjorn-Egil Nygaard for discovering. if ( dt . gt . 12 0. ) then prr_rcw ( k ) = prr_rcw ( k ) + prs_scw ( k ) + prg_gcw ( k ) prs_scw ( k ) = 0. prg_gcw ( k ) = 0. endif endif if (. not . tempo_init_cfgs % hailaware_flag ) idx_bg ( k ) = idx_bg1 enddo endif !================================================================================================================= !..Ensure we do not deplete more hydrometeor species than exists. !+---+-----------------------------------------------------------------+ do k = kts , kte !..If ice supersaturated, ensure sum of depos growth terms does not !.. deplete more vapor than possibly exists.  If subsaturated, limit !.. sum of sublimation terms such that vapor does not reproduce ice !.. supersat again. sump = pri_inu ( k ) + pri_ide ( k ) + prs_ide ( k ) & + prs_sde ( k ) + prg_gde ( k ) + pri_iha ( k ) rate_max = ( qv ( k ) - qvsi ( k )) * rho ( k ) * odts * 0.999 if ( ( sump . gt . eps . and . sump . gt . rate_max ) . or . & ( sump . lt . - eps . and . sump . lt . rate_max ) ) then ratio = rate_max / sump pri_inu ( k ) = pri_inu ( k ) * ratio pri_ide ( k ) = pri_ide ( k ) * ratio pni_ide ( k ) = pni_ide ( k ) * ratio prs_ide ( k ) = prs_ide ( k ) * ratio prs_sde ( k ) = prs_sde ( k ) * ratio prg_gde ( k ) = prg_gde ( k ) * ratio pri_iha ( k ) = pri_iha ( k ) * ratio endif !..Cloud water conservation. sump = - prr_wau ( k ) - pri_wfz ( k ) - prr_rcw ( k ) & - prs_scw ( k ) - prg_scw ( k ) - prg_gcw ( k ) rate_max = - rc ( k ) * odts if ( sump . lt . rate_max . and . L_qc ( k )) then ratio = rate_max / sump prr_wau ( k ) = prr_wau ( k ) * ratio pri_wfz ( k ) = pri_wfz ( k ) * ratio prr_rcw ( k ) = prr_rcw ( k ) * ratio prs_scw ( k ) = prs_scw ( k ) * ratio prg_scw ( k ) = prg_scw ( k ) * ratio prg_gcw ( k ) = prg_gcw ( k ) * ratio endif !..Cloud ice conservation. sump = pri_ide ( k ) - prs_iau ( k ) - prs_sci ( k ) & - pri_rci ( k ) rate_max = - ri ( k ) * odts if ( sump . lt . rate_max . and . L_qi ( k )) then ratio = rate_max / sump pri_ide ( k ) = pri_ide ( k ) * ratio prs_iau ( k ) = prs_iau ( k ) * ratio prs_sci ( k ) = prs_sci ( k ) * ratio pri_rci ( k ) = pri_rci ( k ) * ratio endif !..Rain conservation. sump = - prg_rfz ( k ) - pri_rfz ( k ) - prr_rci ( k ) & + prr_rcs ( k ) + prr_rcg ( k ) rate_max = - rr ( k ) * odts if ( sump . lt . rate_max . and . L_qr ( k )) then ratio = rate_max / sump prg_rfz ( k ) = prg_rfz ( k ) * ratio pbg_rfz ( k ) = pbg_rfz ( k ) * ratio pri_rfz ( k ) = pri_rfz ( k ) * ratio prr_rci ( k ) = prr_rci ( k ) * ratio prr_rcs ( k ) = prr_rcs ( k ) * ratio prr_rcg ( k ) = prr_rcg ( k ) * ratio endif !..Snow conservation. sump = prs_sde ( k ) - prs_ihm ( k ) - prr_sml ( k ) & + prs_rcs ( k ) rate_max = - rs ( k ) * odts if ( sump . lt . rate_max . and . L_qs ( k )) then ratio = rate_max / sump prs_sde ( k ) = prs_sde ( k ) * ratio prs_ihm ( k ) = prs_ihm ( k ) * ratio prr_sml ( k ) = prr_sml ( k ) * ratio prs_rcs ( k ) = prs_rcs ( k ) * ratio endif !..Graupel conservation. sump = prg_gde ( k ) - prg_ihm ( k ) - prr_gml ( k ) & + prg_rcg ( k ) rate_max = - rg ( k ) * odts if ( sump . lt . rate_max . and . L_qg ( k )) then ratio = rate_max / sump prg_gde ( k ) = prg_gde ( k ) * ratio prg_ihm ( k ) = prg_ihm ( k ) * ratio prr_gml ( k ) = prr_gml ( k ) * ratio prg_rcg ( k ) = prg_rcg ( k ) * ratio pbg_rcg ( k ) = pbg_rcg ( k ) * ratio endif !..Re-enforce proper mass conservation for subsequent elements in case !.. any of the above terms were altered.  Thanks P. Blossey. 2009Sep28 pri_ihm ( k ) = prs_ihm ( k ) + prg_ihm ( k ) ratio = min ( abs ( prr_rcg ( k )), abs ( prg_rcg ( k )) ) prr_rcg ( k ) = ratio * sign ( 1.0 , sngl ( prr_rcg ( k ))) prg_rcg ( k ) = - prr_rcg ( k ) pbg_rcg ( k ) = prg_rcg ( k ) / rho_i if ( temp ( k ). gt . t_0 ) then ratio = min ( abs ( prr_rcs ( k )), abs ( prs_rcs ( k )) ) prr_rcs ( k ) = ratio * sign ( 1.0 , sngl ( prr_rcs ( k ))) prs_rcs ( k ) = - prr_rcs ( k ) endif enddo !================================================================================================================= !..Calculate tendencies of all species but constrain the number of ice !.. to reasonable values. !+---+-----------------------------------------------------------------+ do k = kts , kte orho = 1. / rho ( k ) lfus2 = lsub - lvap ( k ) !..Aerosol number tendency if ( tempo_init_cfgs % aerosolaware_flag ) then nwfaten ( k ) = nwfaten ( k ) - ( pna_rca ( k ) + pna_sca ( k ) & + pna_gca ( k ) + pni_iha ( k )) * orho nifaten ( k ) = nifaten ( k ) - ( pnd_rcd ( k ) + pnd_scd ( k ) & + pnd_gcd ( k )) * orho if ( dustyIce ) then nifaten ( k ) = nifaten ( k ) - pni_inu ( k ) * orho else nifaten ( k ) = 0. endif endif !..Water vapor tendency qvten ( k ) = qvten ( k ) + ( - pri_inu ( k ) - pri_iha ( k ) - pri_ide ( k ) & - prs_ide ( k ) - prs_sde ( k ) - prg_gde ( k )) & * orho !..Cloud water tendency qcten ( k ) = qcten ( k ) + ( - prr_wau ( k ) - pri_wfz ( k ) & - prr_rcw ( k ) - prs_scw ( k ) - prg_scw ( k ) & - prg_gcw ( k )) & * orho !..Cloud water number tendency ncten ( k ) = ncten ( k ) + ( - pnc_wau ( k ) - pnc_rcw ( k ) & - pni_wfz ( k ) - pnc_scw ( k ) - pnc_gcw ( k )) & * orho !..Cloud water mass/number balance; keep mass-wt mean size between !.. 1 and 50 microns.  Also no more than Nt_c_max drops total. xrc = max ( r1 , ( qc1d ( k ) + qcten ( k ) * dtsave ) * rho ( k )) xnc = max ( 2. , ( nc1d ( k ) + ncten ( k ) * dtsave ) * rho ( k )) if ( xrc . gt . r1 ) then if ( xnc . gt . 1000 0.e6 ) then nu_c = 2 elseif ( xnc . lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / xnc ) + 2 rand = 0.0 if ( present ( rand2 )) then rand = rand2 endif nu_c = max ( 2 , min ( nu_c + nint ( rand ), 15 )) endif lamc = ( xnc * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / rc ( k )) ** obmr xDc = ( bm_r + nu_c + 1. ) / lamc if ( xDc . lt . D0c ) then lamc = cce ( 2 , nu_c ) / D0c xnc = ccg ( 1 , nu_c ) * ocg2 ( nu_c ) * xrc / am_r * lamc ** bm_r ncten ( k ) = ( xnc - nc1d ( k ) * rho ( k )) * odts * orho elseif ( xDc . gt . D0r * 2. ) then lamc = cce ( 2 , nu_c ) / ( D0r * 2. ) xnc = ccg ( 1 , nu_c ) * ocg2 ( nu_c ) * xrc / am_r * lamc ** bm_r ncten ( k ) = ( xnc - nc1d ( k ) * rho ( k )) * odts * orho endif else ncten ( k ) = - nc1d ( k ) * odts endif xnc = max ( 0. , ( nc1d ( k ) + ncten ( k ) * dtsave ) * rho ( k )) if ( xnc . gt . Nt_c_max ) & ncten ( k ) = ( Nt_c_max - nc1d ( k ) * rho ( k )) * odts * orho !..Cloud ice mixing ratio tendency qiten ( k ) = qiten ( k ) + ( pri_inu ( k ) + pri_iha ( k ) + pri_ihm ( k ) & + pri_wfz ( k ) + pri_rfz ( k ) + pri_ide ( k ) & - prs_iau ( k ) - prs_sci ( k ) - pri_rci ( k )) & * orho !..Cloud ice number tendency. niten ( k ) = niten ( k ) + ( pni_inu ( k ) + pni_iha ( k ) + pni_ihm ( k ) & + pni_wfz ( k ) + pni_rfz ( k ) + pni_ide ( k ) & - pni_iau ( k ) - pni_sci ( k ) - pni_rci ( k )) & * orho !..Cloud ice mass/number balance; keep mass-wt mean size between !.. 5 and 300 microns.  Also no more than 500 xtals per liter. xri = max ( r1 ,( qi1d ( k ) + qiten ( k ) * dtsave ) * rho ( k )) xni = max ( r2 ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xri . gt . r1 ) then lami = ( am_i * cig ( 2 ) * oig1 * xni / xri ) ** obmi ilami = 1. / lami xdi = ( bm_i + mu_i + 1. ) * ilami if ( xdi . lt . 5.e-6 ) then lami = cie ( 2 ) / 5.e-6 xni = min ( max_ni , cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i ) niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho elseif ( xdi . gt . 30 0.e-6 ) then lami = cie ( 2 ) / 30 0.e-6 xni = cig ( 1 ) * oig2 * xri / am_i * lami ** bm_i niten ( k ) = ( xni - ni1d ( k ) * rho ( k )) * odts * orho endif else niten ( k ) = - ni1d ( k ) * odts endif xni = max ( 0. ,( ni1d ( k ) + niten ( k ) * dtsave ) * rho ( k )) if ( xni . gt . max_ni ) & niten ( k ) = ( max_ni - ni1d ( k ) * rho ( k )) * odts * orho !..Rain tendency qrten ( k ) = qrten ( k ) + ( prr_wau ( k ) + prr_rcw ( k ) & + prr_sml ( k ) + prr_gml ( k ) + prr_rcs ( k ) & + prr_rcg ( k ) - prg_rfz ( k ) & - pri_rfz ( k ) - prr_rci ( k )) & * orho !..Rain number tendency nrten ( k ) = nrten ( k ) + ( pnr_wau ( k ) + pnr_sml ( k ) + pnr_gml ( k ) & - ( pnr_rfz ( k ) + pnr_rcr ( k ) + pnr_rcg ( k ) & + pnr_rcs ( k ) + pnr_rci ( k ) + pni_rfz ( k )) ) & * orho !..Rain mass/number balance; keep median volume diameter between !.. 37 microns (D0r*0.75) and 2.5 mm. xrr = max ( R1 ,( qr1d ( k ) + qrten ( k ) * dtsave ) * rho ( k )) xnr = max ( R2 ,( nr1d ( k ) + nrten ( k ) * dtsave ) * rho ( k )) if ( xrr . gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * xnr / xrr ) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) xnr = crg ( 2 ) * org3 * xrr * lamr ** bm_r / am_r nrten ( k ) = ( xnr - nr1d ( k ) * rho ( k )) * odts * orho endif else qrten ( k ) = - qr1d ( k ) * odts nrten ( k ) = - nr1d ( k ) * odts endif !..Snow tendency qsten ( k ) = qsten ( k ) + ( prs_iau ( k ) + prs_sde ( k ) + prs_sci ( k ) & + prs_scw ( k ) + prs_rcs ( k ) + prs_ide ( k ) & - prs_ihm ( k ) - prr_sml ( k )) & * orho !..Graupel tendency qgten ( k ) = qgten ( k ) + ( prg_scw ( k ) + prg_rfz ( k ) & + prg_gde ( k ) + prg_rcg ( k ) + prg_gcw ( k ) & + prg_rci ( k ) + prg_rcs ( k ) - prg_ihm ( k ) & - prr_gml ( k )) & * orho !..Graupel number tendency ngten ( k ) = ngten ( k ) + ( png_scw ( k ) + png_rfz ( k ) - png_rcg ( k ) & + png_rci ( k ) + png_rcs ( k ) + png_gde ( k ) & - pnr_gml ( k )) * orho !..Graupel volume mixing ratio tendency qbten ( k ) = qbten ( k ) + ( pbg_scw ( k ) + pbg_rfz ( k ) & + pbg_gcw ( k ) + pbg_rci ( k ) + pbg_rcs ( k ) & + pbg_rcg ( k ) + pbg_sml ( k ) - pbg_gml ( k ) & + ( prg_gde ( k ) - prg_ihm ( k )) / rho_g ( idx_bg ( k )) ) & * orho !..Graupel mass/number balance; keep its median volume diameter between !.. 3.0 times minimum size (D0g) and 25 mm. xrg = max ( r1 ,( qg1d ( k ) + qgten ( k ) * dtsave ) * rho ( k )) xng = max ( r2 ,( ng1d ( k ) + ngten ( k ) * dtsave ) * rho ( k )) xrb = max ( xrg / rho ( k ) / rho_g ( nrhg ),( qb1d ( k ) + qbten ( k ) * dtsave )) xrb = min ( xrg / rho ( k ) / rho_g ( 1 ), xrb ) if ( xrg . gt . R1 ) then lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * xng / xrg ) ** obmg mvd_g ( k ) = ( 3.0 + mu_g + 0.672 ) / lamg if ( mvd_g ( k ) . gt . 2 5.4E-3 ) then mvd_g ( k ) = 2 5.4E-3 lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) xng = cgg ( 2 , 1 ) * ogg3 * xrg * lamg ** bm_g / am_g ( idx_bg ( k )) ngten ( k ) = ( xng - ng1d ( k ) * rho ( k )) * odts * orho elseif ( mvd_g ( k ) . lt . D0r ) then mvd_g ( k ) = D0r lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) xng = cgg ( 2 , 1 ) * ogg3 * xrg * lamg ** bm_g / am_g ( idx_bg ( k )) ngten ( k ) = ( xng - ng1d ( k ) * rho ( k )) * odts * orho endif else qgten ( k ) = - qg1d ( k ) * odts ngten ( k ) = - ng1d ( k ) * odts qbten ( k ) = - qb1d ( k ) * odts endif !..Temperature tendency if ( temp ( k ). lt . T_0 ) then tten ( k ) = tten ( k ) & + ( lsub * ocp ( k ) * ( pri_inu ( k ) + pri_ide ( k ) & + prs_ide ( k ) + prs_sde ( k ) & + prg_gde ( k ) + pri_iha ( k )) & + lfus2 * ocp ( k ) * ( pri_wfz ( k ) + pri_rfz ( k ) & + prg_rfz ( k ) + prs_scw ( k ) & + prg_scw ( k ) + prg_gcw ( k ) & + prg_rcs ( k ) + prs_rcs ( k ) & + prr_rci ( k ) + prg_rcg ( k )) & ) * orho * ( 1 - IFDRY ) else tten ( k ) = tten ( k ) & + ( lfus * ocp ( k ) * ( - prr_sml ( k ) - prr_gml ( k ) & - prr_rcg ( k ) - prr_rcs ( k )) & + lsub * ocp ( k ) * ( prs_sde ( k ) + prg_gde ( k )) & ) * orho * ( 1 - IFDRY ) endif enddo !================================================================================================================= !..Update variables for TAU+1 before condensation & sedimention. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) + dt * tten ( k ) otemp = 1. / temp ( k ) tempc = temp ( k ) - 27 3.15 qv ( k ) = max ( min_qv , qv1d ( k ) + dt * qvten ( k )) rho ( k ) = roverrv * pres ( k ) / ( r * temp ( k ) * ( qv ( k ) + roverrv )) rhof ( k ) = sqrt ( rho_not / rho ( k )) rhof2 ( k ) = sqrt ( rhof ( k )) qvs ( k ) = calc_rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. if ( abs ( ssatw ( k )). lt . eps ) ssatw ( k ) = 0.0 diffu ( k ) = 2.11e-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0e-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2e-5 * tempc * tempc ) * 1.0e-5 endif vsc2 ( k ) = sqrt ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0e-5 * 41 8.936 ocp ( k ) = 1. / ( cp2 * ( 1. + 0.887 * qv ( k ))) lvt2 ( k ) = lvap ( k ) * lvap ( k ) * ocp ( k ) * orv * otemp * otemp if ( tempo_init_cfgs % aerosolaware_flag ) then nwfa ( k ) = MAX ( nwfa_default * rho ( k ), ( nwfa1d ( k ) + nwfaten ( k ) * DT ) * rho ( k )) endif enddo do k = kts , kte if (( qc1d ( k ) + qcten ( k ) * dt ) . gt . r1 ) then rc ( k ) = ( qc1d ( k ) + qcten ( k ) * dt ) * rho ( k ) nc ( k ) = max ( 2. , min (( nc1d ( k ) + ncten ( k ) * dt ) * rho ( k ), nt_c_max )) if (. not .( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then nc ( k ) = Nt_c if ( present ( lsml )) then if ( lsml == 1 ) then nc ( k ) = Nt_c_l else nc ( k ) = Nt_c_o endif endif endif L_qc ( k ) = . true . else rc ( k ) = R1 nc ( k ) = 2. L_qc ( k ) = . false . endif if (( qi1d ( k ) + qiten ( k ) * DT ) . gt . R1 ) then ri ( k ) = ( qi1d ( k ) + qiten ( k ) * DT ) * rho ( k ) ni ( k ) = max ( R2 , ( ni1d ( k ) + niten ( k ) * DT ) * rho ( k )) L_qi ( k ) = . true . else ri ( k ) = R1 ni ( k ) = R2 L_qi ( k ) = . false . endif if (( qr1d ( k ) + qrten ( k ) * DT ) . gt . R1 ) then rr ( k ) = ( qr1d ( k ) + qrten ( k ) * DT ) * rho ( k ) nr ( k ) = max ( R2 , ( nr1d ( k ) + nrten ( k ) * DT ) * rho ( k )) L_qr ( k ) = . true . lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr ( k ) = crg ( 2 ) * org3 * rr ( k ) * lamr ** bm_r / am_r endif else rr ( k ) = R1 nr ( k ) = R2 L_qr ( k ) = . false . endif if (( qs1d ( k ) + qsten ( k ) * DT ) . gt . R1 ) then rs ( k ) = ( qs1d ( k ) + qsten ( k ) * DT ) * rho ( k ) L_qs ( k ) = . true . else rs ( k ) = R1 L_qs ( k ) = . false . endif enddo if ( tempo_init_cfgs % hailaware_flag ) then do k = kts , kte if (( qg1d ( k ) + qgten ( k ) * dt ) . gt . r1 ) then l_qg ( k ) = . true . rg ( k ) = ( qg1d ( k ) + qgten ( k ) * dt ) * rho ( k ) ng ( k ) = max ( r2 , ( ng1d ( k ) + ngten ( k ) * dt ) * rho ( k )) rb ( k ) = max ( rg ( k ) / rho ( k ) / rho_g ( nrhg ), qb1d ( k ) + qbten ( k ) * dt ) rb ( k ) = min ( rg ( k ) / rho ( k ) / rho_g ( 1 ), rb ( k )) idx_bg ( k ) = max ( 1 , min ( nint ( rg ( k ) / rho ( k ) / rb ( k ) * 0.01 ) + 1 , nrhg )) else rg ( k ) = r1 ng ( k ) = r2 rb ( k ) = r1 / rho ( k ) / rho_g ( nrhg ) idx_bg ( k ) = nrhg l_qg ( k ) = . false . endif enddo else do k = kte , kts , - 1 idx_bg ( k ) = idx_bg1 enddo do k = kte , kts , - 1 if (( qg1d ( k ) + qgten ( k ) * dt ) . gt . r1 ) then rg ( k ) = ( qg1d ( k ) + qgten ( k ) * dt ) * rho ( k ) ygra1 = log10 ( max ( 1.e-9 , rg ( k ))) zans1 = 3.4 + 2. / 7. * ( ygra1 + 8. ) ! zans1 = max(2., min(zans1, 6.)) N0_exp = max ( gonv_min , min ( 1 0.0 ** ( zans1 ), gonv_max )) lam_exp = ( n0_exp * am_g ( idx_bg ( k )) * cgg ( 1 , 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** obmg ng ( k ) = cgg ( 2 , 1 ) * ogg3 * rg ( k ) * lamg ** bm_g / am_g ( idx_bg ( k )) rb ( k ) = rg ( k ) / rho ( k ) / rho_g ( idx_bg ( k )) else rg ( k ) = R1 ng ( k ) = R2 rb ( k ) = R1 / rho ( k ) / rho_g ( NRHG ) L_qg ( k ) = . false . endif enddo endif !================================================================================================================= !..With tendency-updated mixing ratios, recalculate snow moments and !.. intercepts/slopes of graupel and rain. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte smo2 ( k ) = 0. smob ( k ) = 0. smoc ( k ) = 0. smod ( k ) = 0. enddo do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = min ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s+bv_s (th) moment.  Useful for sedimentation. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 14 ) & + sa ( 4 ) * tc0 * cse ( 14 ) + sa ( 5 ) * tc0 * tc0 & + sa ( 6 ) * cse ( 14 ) * cse ( 14 ) + sa ( 7 ) * tc0 * tc0 * cse ( 14 ) & + sa ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) + sa ( 9 ) * tc0 * tc0 * tc0 & + sa ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 14 ) + sb ( 4 ) * tc0 * cse ( 14 ) & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 14 ) * cse ( 14 ) & + sb ( 7 ) * tc0 * tc0 * cse ( 14 ) + sb ( 8 ) * tc0 * cse ( 14 ) * cse ( 14 ) & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 14 ) * cse ( 14 ) * cse ( 14 ) smod ( k ) = a_ * smo2 ( k ) ** b_ enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng ( k ) / rg ( k )) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = ng ( k ) * ogg2 * lamg ** cge ( 2 , 1 ) enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for rain. !+---+-----------------------------------------------------------------+ do k = kte , kts , - 1 lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) enddo !================================================================================================================= !..Cloud water condensation and evaporation.  Nucleate cloud droplets !.. using explicit CCN aerosols with hygroscopicity like sulfates using !.. parcel model lookup table results provided by T. Eidhammer.  Evap !.. drops using calculation of max drop size capable of evaporating in !.. single timestep and explicit number of drops smaller than Dc_star !.. from lookup table. !+---+-----------------------------------------------------------------+ do k = kts , kte orho = 1. / rho ( k ) if (( ssatw ( k ). gt . eps ) . or . ( ssatw ( k ). lt . - eps . and . L_qc ( k ))) then clap = ( qv ( k ) - qvs ( k )) / ( 1. + lvt2 ( k ) * qvs ( k )) do n = 1 , 3 fcd = qvs ( k ) * exp ( lvt2 ( k ) * clap ) - qv ( k ) + clap dfcd = qvs ( k ) * lvt2 ( k ) * exp ( lvt2 ( k ) * clap ) + 1. clap = clap - fcd / dfcd enddo xrc = rc ( k ) + clap * rho ( k ) xnc = 0. if ( xrc > R1 ) then prw_vcd ( k ) = clap * odt !+---+-----------------------------------------------------------------+ !  DROPLET NUCLEATION if ( clap . gt . eps ) then if ( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware ) then rand = 0.0 if ( present ( rand3 )) then rand = rand3 endif xnc = max ( 2. , activ_ncloud ( temp ( k ), w1d ( k ) + rand , nwfa ( k ), lsml )) else xnc = Nt_c if ( present ( lsml )) then if ( lsml == 1 ) then xnc = Nt_c_l else xnc = Nt_c_o endif endif endif pnc_wcd ( k ) = 0.5 * ( xnc - nc ( k ) + abs ( xnc - nc ( k ))) * odts * orho !+---+-----------------------------------------------------------------+ !  EVAPORATION elseif ( clap . lt . - eps . AND . ssatw ( k ). lt . - 1.e-6 . and . tempo_init_cfgs % aerosolaware_flag ) then tempc = temp ( k ) - 27 3.15 otemp = 1. / temp ( k ) rvs = rho ( k ) * qvs ( k ) rvs_p = rvs * otemp * ( lvap ( k ) * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lvap ( k ) * otemp * oRv - 1. ) & * otemp * ( lvap ( k ) * otemp * oRv - 1. ) & + ( - 2. * lvap ( k ) * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lvap ( k ) * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = max ( 1.e-9 , alphsc ) xsat = ssatw ( k ) if ( abs ( xsat ). lt . 1.e-9 ) xsat = 0. t1_evap = 2. * pi * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) dc_star = dsqrt ( - 2.d0 * dt * t1_evap / ( 2. * pi ) & * 4. * diffu ( k ) * ssatw ( k ) * rvs / rho_w2 ) idx_d = max ( 1 , min ( int ( 1.e6 * dc_star ), nbc )) idx_n = nint ( 1.0 + float ( nbc ) * dlog ( nc ( k ) / t_nc ( 1 )) / nic1 ) idx_n = max ( 1 , min ( idx_n , nbc )) !>  - Cloud water lookup table index. if ( rc ( k ). gt . r_c ( 1 )) then nic = nint ( log10 ( rc ( k ))) do_loop_rc_cond : do nn = nic - 1 , nic + 1 n = nn if ( ( rc ( k ) / 1 0. ** nn ). ge . 1.0 . and . ( rc ( k ) / 1 0. ** nn ). lt . 1 0.0 ) exit do_loop_rc_cond enddo do_loop_rc_cond idx_c = int ( rc ( k ) / 1 0. ** n ) + 10 * ( n - nic2 ) - ( n - nic2 ) idx_c = max ( 1 , min ( idx_c , ntb_c )) else idx_c = 1 endif !prw_vcd(k) = MAX(DBLE(-rc(k)*orho*odt),                     & !           -tpc_wev(idx_d, idx_c, idx_n)*orho*odt) prw_vcd ( k ) = max ( real ( - rc ( k ) * 0.99 * orho * odt , kind = dp ), prw_vcd ( k )) pnc_wcd ( k ) = max ( real ( - nc ( k ) * 0.99 * orho * odt , & kind = dp ), real ( - tnc_wev ( idx_d , idx_c , idx_n ) * orho * odt , kind = dp )) endif else prw_vcd ( k ) = - rc ( k ) * orho * odt pnc_wcd ( k ) = - nc ( k ) * orho * odt endif !+---+-----------------------------------------------------------------+ qvten ( k ) = qvten ( k ) - prw_vcd ( k ) qcten ( k ) = qcten ( k ) + prw_vcd ( k ) ncten ( k ) = ncten ( k ) + pnc_wcd ( k ) ! Be careful here: depending on initial conditions, ! cloud evaporation can increase aerosols if ( tempo_init_cfgs % aerosolaware_flag ) nwfaten ( k ) = nwfaten ( k ) - pnc_wcd ( k ) tten ( k ) = tten ( k ) + lvap ( k ) * ocp ( k ) * prw_vcd ( k ) * ( 1 - IFDRY ) rc ( k ) = max ( R1 , ( qc1d ( k ) + dt * qcten ( k )) * rho ( k )) if ( rc ( k ). eq . R1 ) l_qc ( k ) = . false . nc ( k ) = max ( 2. , min (( nc1d ( k ) + ncten ( k ) * dt ) * rho ( k ), nt_c_max )) if (. not .( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then nc ( k ) = Nt_c if ( present ( lsml )) then if ( lsml == 1 ) then nc ( k ) = Nt_c_l else nc ( k ) = Nt_c_o endif endif endif qv ( k ) = max ( min_qv , qv1d ( k ) + DT * qvten ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = RoverRv * pres ( k ) / ( R * temp ( k ) * ( qv ( k ) + RoverRv )) qvs ( k ) = calc_rslf ( pres ( k ), temp ( k )) ssatw ( k ) = qv ( k ) / qvs ( k ) - 1. endif enddo !================================================================================================================= !.. If still subsaturated, allow rain to evaporate, following !.. Srivastava & Coen (1992). !+---+-----------------------------------------------------------------+ do k = kts , kte if ( ( ssatw ( k ). lt . - eps ) . and . L_qr ( k ) & . and . (. not .( prw_vcd ( k ). gt . 0. )) ) then tempc = temp ( k ) - 27 3.15 otemp = 1. / temp ( k ) orho = 1. / rho ( k ) rhof ( k ) = sqrt ( rho_not * orho ) rhof2 ( k ) = sqrt ( rhof ( k )) diffu ( k ) = 2.11e-5 * ( temp ( k ) / 27 3.15 ) ** 1.94 * ( 10132 5. / pres ( k )) if ( tempc . ge . 0.0 ) then visco ( k ) = ( 1.718 + 0.0049 * tempc ) * 1.0e-5 else visco ( k ) = ( 1.718 + 0.0049 * tempc - 1.2e-5 * tempc * tempc ) * 1.0e-5 endif vsc2 ( k ) = sqrt ( rho ( k ) / visco ( k )) lvap ( k ) = lvap0 + ( 210 6.0 - 421 8.0 ) * tempc tcond ( k ) = ( 5.69 + 0.0168 * tempc ) * 1.0E-5 * 41 8.936 ocp ( k ) = 1. / ( Cp2 * ( 1. + 0.887 * qv ( k ))) rvs = rho ( k ) * qvs ( k ) rvs_p = rvs * otemp * ( lvap ( k ) * otemp * oRv - 1. ) rvs_pp = rvs * ( otemp * ( lvap ( k ) * otemp * oRv - 1. ) & * otemp * ( lvap ( k ) * otemp * oRv - 1. ) & + ( - 2. * lvap ( k ) * otemp * otemp * otemp * oRv ) & + otemp * otemp ) gamsc = lvap ( k ) * diffu ( k ) / tcond ( k ) * rvs_p alphsc = 0.5 * ( gamsc / ( 1. + gamsc )) * ( gamsc / ( 1. + gamsc )) & * rvs_pp / rvs_p * rvs / rvs_p alphsc = max ( 1.E-9 , alphsc ) xsat = min ( - 1.E-9 , ssatw ( k )) t1_evap = 2. * PI * ( 1.0 - alphsc * xsat & + 2. * alphsc * alphsc * xsat * xsat & - 5. * alphsc * alphsc * alphsc * xsat * xsat * xsat ) & / ( 1. + gamsc ) lamr = 1. / ilamr ( k ) !..Rapidly eliminate near zero values when low humidity (<95%) if ( qv ( k ) / qvs ( k ) . lt . 0.95 . AND . rr ( k ) * orho . le . 1.E-8 ) then prv_rev ( k ) = rr ( k ) * orho * odts else prv_rev ( k ) = t1_evap * diffu ( k ) * ( - ssatw ( k )) * N0_r ( k ) * rvs & * ( t1_qr_ev * ilamr ( k ) ** cre ( 10 ) & + t2_qr_ev * vsc2 ( k ) * rhof2 ( k ) * (( lamr + 0.5 * fv_r ) ** ( - cre ( 11 )))) rate_max = min (( rr ( k ) * orho * odts ), ( qvs ( k ) - qv ( k )) * odts ) prv_rev ( k ) = min ( real ( rate_max , kind = dp ), prv_rev ( k ) * orho ) !..TEST: G. Thompson  10 May 2013 !..Reduce the rain evaporation in same places as melting graupel occurs. !..Rationale: falling and simultaneous melting graupel in subsaturated !..regions will not melt as fast because particle temperature stays !..at 0C.  Also not much shedding of the water from the graupel so !..likely that the water-coated graupel evaporating much slower than !..if the water was immediately shed off. IF ( prr_gml ( k ). gt . 0.0 ) THEN eva_factor = min ( 1.0 , 0.01 + ( 0.99 - 0.01 ) * ( tempc / 2 0.0 )) prv_rev ( k ) = prv_rev ( k ) * eva_factor ENDIF endif pnr_rev ( k ) = min ( real ( nr ( k ) * 0.99 * orho * odts , kind = dp ), & ! RAIN2M prv_rev ( k ) * nr ( k ) / rr ( k )) qrten ( k ) = qrten ( k ) - prv_rev ( k ) qvten ( k ) = qvten ( k ) + prv_rev ( k ) nrten ( k ) = nrten ( k ) - pnr_rev ( k ) nwfaten ( k ) = nwfaten ( k ) + pnr_rev ( k ) tten ( k ) = tten ( k ) - lvap ( k ) * ocp ( k ) * prv_rev ( k ) * ( 1 - IFDRY ) rr ( k ) = max ( r1 , ( qr1d ( k ) + dt * qrten ( k )) * rho ( k )) qv ( k ) = max ( 1.e-10 , qv1d ( k ) + dt * qvten ( k )) nr ( k ) = max ( r2 , ( nr1d ( k ) + dt * nrten ( k )) * rho ( k )) temp ( k ) = t1d ( k ) + DT * tten ( k ) rho ( k ) = RoverRv * pres ( k ) / ( R * temp ( k ) * ( qv ( k ) + RoverRv )) endif enddo #if defined(mpas) do k = kts , kte evapprod ( k ) = prv_rev ( k ) - ( min ( zeroD0 , prs_sde ( k )) + & min ( zeroD0 , prg_gde ( k ))) rainprod ( k ) = prr_wau ( k ) + prr_rcw ( k ) + prs_scw ( k ) + & prg_scw ( k ) + prs_iau ( k ) + & prg_gcw ( k ) + prs_sci ( k ) + & pri_rci ( k ) enddo #endif !================================================================================================================= !..Find max terminal fallspeed (distribution mass-weighted mean !.. velocity) and use it to determine if we need to split the timestep !.. (var nstep>1).  Either way, only bother to do sedimentation below !.. 1st level that contains any sedimenting particles (k=ksed1 on down). !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !+---+-----------------------------------------------------------------+ nstep = 0 onstep (:) = 1.0 ksed1 (:) = 1 do k = kte + 1 , kts , - 1 vtrk ( k ) = 0. vtnrk ( k ) = 0. vtik ( k ) = 0. vtnik ( k ) = 0. vtsk ( k ) = 0. vtgk ( k ) = 0. vtngk ( k ) = 0. vtck ( k ) = 0. vtnck ( k ) = 0. enddo if ( any ( l_qr . eqv . . true .)) then do k = kte , kts , - 1 vtr = 0. rhof ( k ) = sqrt ( rho_not / rho ( k )) if ( rr ( k ). gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr vtr = rhof ( k ) * av_r * crg ( 6 ) * org3 * lamr ** cre ( 3 ) & * (( lamr + fv_r ) ** ( - cre ( 6 ))) vtrk ( k ) = vtr ! First below is technically correct: !         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                 & !                     *((lamr+fv_r)**(-cre(5))) ! Test: make number fall faster (but still slower than mass) ! Goal: less prominent size sorting vtr = rhof ( k ) * av_r * crg ( 7 ) / crg ( 12 ) * lamr ** cre ( 12 ) & * (( lamr + fv_r ) ** ( - cre ( 7 ))) vtnrk ( k ) = vtr else vtrk ( k ) = vtrk ( k + 1 ) vtnrk ( k ) = vtnrk ( k + 1 ) endif if ( max ( vtrk ( k ), vtnrk ( k )) . gt . 1.e-3 ) then ksed1 ( 1 ) = max ( ksed1 ( 1 ), k ) delta_tp = dzq ( k ) / ( max ( vtrk ( k ), vtnrk ( k ))) nstep = max ( nstep , int ( dt / delta_tp + 1. )) endif enddo if ( ksed1 ( 1 ) . eq . kte ) ksed1 ( 1 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 1 ) = 1. / real ( nstep ) endif !+---+-----------------------------------------------------------------+ if ( any ( l_qc . eqv . . true .)) then hgt_agl = 0. do_loop_hgt_agl : do k = kts , kte - 1 if ( rc ( k ) . gt . R2 ) ksed1 ( 5 ) = k hgt_agl = hgt_agl + dzq ( k ) if ( hgt_agl . gt . 50 0.0 ) exit do_loop_hgt_agl enddo do_loop_hgt_agl do k = ksed1 ( 5 ), kts , - 1 vtc = 0. if ( rc ( k ) . gt . R1 . and . w1d ( k ) . lt . 1.E-1 ) then if ( nc ( k ). gt . 1000 0.e6 ) then nu_c = 2 elseif ( nc ( k ). lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / nc ( k )) + 2 rand = 0.0 if ( present ( rand2 )) then rand = rand2 endif nu_c = max ( 2 , min ( nu_c + nint ( rand ), 15 )) endif lamc = ( nc ( k ) * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / rc ( k )) ** obmr ilamc = 1. / lamc vtc = rhof ( k ) * av_c * ccg ( 5 , nu_c ) * ocg2 ( nu_c ) * ilamc ** bv_c vtck ( k ) = vtc vtc = rhof ( k ) * av_c * ccg ( 4 , nu_c ) * ocg1 ( nu_c ) * ilamc ** bv_c vtnck ( k ) = vtc endif enddo endif !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then if ( any ( l_qi . eqv . . true .)) then nstep = 0 do k = kte , kts , - 1 vti = 0. if ( ri ( k ). gt . R1 ) then lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi ilami = 1. / lami vti = rhof ( k ) * av_i * cig ( 3 ) * oig2 * ilami ** bv_i vtik ( k ) = vti ! First below is technically correct: !          vti = rhof(k)*av_i*cig(4)*oig1 * ilami**bv_i ! Goal: less prominent size sorting vti = rhof ( k ) * av_i * cig ( 6 ) / cig ( 7 ) * ilami ** bv_i vtnik ( k ) = vti else vtik ( k ) = vtik ( k + 1 ) vtnik ( k ) = vtnik ( k + 1 ) endif if ( vtik ( k ) . gt . 1.e-3 ) then ksed1 ( 2 ) = max ( ksed1 ( 2 ), k ) delta_tp = dzq ( k ) / vtik ( k ) nstep = max ( nstep , int ( dt / delta_tp + 1. )) endif enddo if ( ksed1 ( 2 ) . eq . kte ) ksed1 ( 2 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 2 ) = 1. / real ( nstep ) endif !+---+-----------------------------------------------------------------+ if ( any ( l_qs . eqv . . true .)) then nstep = 0 do k = kte , kts , - 1 vts = 0. if ( rs ( k ). gt . R1 ) then xDs = smoc ( k ) / smob ( k ) Mrat = 1. / xDs ils1 = 1. / ( Mrat * Lam0 + fv_s ) ils2 = 1. / ( Mrat * Lam1 + fv_s ) t1_vts = Kap0 * csg ( 4 ) * ils1 ** cse ( 4 ) t2_vts = Kap1 * Mrat ** mu_s * csg ( 10 ) * ils2 ** cse ( 10 ) ils1 = 1. / ( Mrat * Lam0 ) ils2 = 1. / ( Mrat * Lam1 ) t3_vts = Kap0 * csg ( 1 ) * ils1 ** cse ( 1 ) t4_vts = Kap1 * Mrat ** mu_s * csg ( 7 ) * ils2 ** cse ( 7 ) vts = rhof ( k ) * av_s * ( t1_vts + t2_vts ) / ( t3_vts + t4_vts ) if ( prr_sml ( k ) . gt . 0.0 ) then SR = rs ( k ) / ( rs ( k ) + rr ( k )) vtsk ( k ) = vts * SR + ( 1. - SR ) * vtrk ( k ) else vtsk ( k ) = vts * vts_boost ( k ) endif else vtsk ( k ) = vtsk ( k + 1 ) endif if ( vtsk ( k ) . gt . 1.e-3 ) then ksed1 ( 3 ) = max ( ksed1 ( 3 ), k ) delta_tp = dzq ( k ) / vtsk ( k ) nstep = max ( nstep , int ( dt / delta_tp + 1. )) endif enddo if ( ksed1 ( 3 ) . eq . kte ) ksed1 ( 3 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 3 ) = 1. / real ( nstep ) endif !+---+-----------------------------------------------------------------+ if ( ANY ( L_qg . eqv . . true .)) then nstep = 0 do k = kte , kts , - 1 vtg = 0. if ( rg ( k ). gt . R1 ) then if ( tempo_init_cfgs % hailaware_flag ) then xrho_g = MAX ( rho_g ( 1 ), MIN ( rg ( k ) / rho ( k ) / rb ( k ), rho_g ( NRHG ))) afall = a_coeff * (( 4.0 * xrho_g * 9.8 ) / ( 3.0 * rho ( k ))) ** b_coeff afall = afall * visco ( k ) ** ( 1.0 - 2.0 * b_coeff ) else afall = av_g_old bfall = bv_g_old endif vtg = rhof ( k ) * afall * cgg ( 6 , idx_bg ( k )) * ogg3 * ilamg ( k ) ** bfall #if defined(ccpp_default) if ( temp ( k ). gt . T_0 ) then vtgk ( k ) = MAX ( vtg , vtrk ( k )) else vtgk ( k ) = vtg endif #else vtgk ( k ) = vtg #endif ! Goal: less prominent size sorting !    the ELSE section below is technically (mathematically) correct: if ( mu_g . eq . 0 ) then vtg = rhof ( k ) * afall * cgg ( 7 , idx_bg ( k )) / cgg ( 12 , idx_bg ( k )) * ilamg ( k ) ** bfall else vtg = rhof ( k ) * afall * cgg ( 8 , idx_bg ( k )) * ogg2 * ilamg ( k ) ** bfall endif vtngk ( k ) = vtg else vtgk ( k ) = vtgk ( k + 1 ) vtngk ( k ) = vtngk ( k + 1 ) endif if ( vtgk ( k ) . gt . 1.e-3 ) then ksed1 ( 4 ) = max ( ksed1 ( 4 ), k ) delta_tp = dzq ( k ) / vtgk ( k ) nstep = max ( nstep , int ( dt / delta_tp + 1. )) endif enddo if ( ksed1 ( 4 ) . eq . kte ) ksed1 ( 4 ) = kte - 1 if ( nstep . gt . 0 ) onstep ( 4 ) = 1. / real ( nstep ) endif endif !================================================================================================================= !..Sedimentation of mixing ratio is the integral of v(D)*m(D)*N(D)*dD, !.. whereas neglect m(D) term for number concentration.  Therefore, !.. cloud ice has proper differential sedimentation. !.. New in v3.0+ is computing separate for rain, ice, snow, and !.. graupel species thus making code faster with credit to J. Schmidt. !.. Bug fix, 2013Nov01 to tendencies using rho(k+1) correction thanks to !.. Eric Skyllingstad. !+---+-----------------------------------------------------------------+ if ( any ( l_qr . eqv . . true .)) then nstep = nint ( 1. / onstep ( 1 )) if (. not . sedi_semi ) then do n = 1 , nstep do k = kte , kts , - 1 sed_r ( k ) = vtrk ( k ) * rr ( k ) sed_n ( k ) = vtnrk ( k ) * nr ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) - sed_r ( k ) * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) - sed_n ( k ) * odzq * onstep ( 1 ) * orho rr ( k ) = max ( r1 , rr ( k ) - sed_r ( k ) * odzq * dt * onstep ( 1 )) nr ( k ) = max ( r2 , nr ( k ) - sed_n ( k ) * odzq * dt * onstep ( 1 )) #if defined(ccpp_default) pfll1 ( k ) = pfll1 ( k ) + sed_r ( k ) * DT * onstep ( 1 ) #endif do k = ksed1 ( 1 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qrten ( k ) = qrten ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * onstep ( 1 ) * orho nrten ( k ) = nrten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 1 ) * orho rr ( k ) = max ( r1 , rr ( k ) + ( sed_r ( k + 1 ) - sed_r ( k )) & * odzq * dt * onstep ( 1 )) nr ( k ) = max ( r2 , nr ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 1 )) #if defined(ccpp_default) pfll1 ( k ) = pfll1 ( k ) + sed_r ( k ) * DT * onstep ( 1 ) #endif enddo if ( rr ( kts ). gt . R1 * 100 0. ) & pptrain = pptrain + sed_r ( kts ) * DT * onstep ( 1 ) enddo else !if(.not. sedi_semi) niter = 1 dtcfl = dt niter = int ( nstep / max ( decfl_ , 1 )) + 1 dtcfl = dt / niter do n = 1 , niter rr_tmp (:) = rr (:) nr_tmp (:) = nr (:) call semi_lagrange_sedim ( kte , dzq , vtrk , rr , rainsfc , pfll , dtcfl , R1 ) call semi_lagrange_sedim ( kte , dzq , vtnrk , nr , vtr , pdummy , dtcfl , R2 ) do k = kts , kte orhodt = 1. / ( rho ( k ) * dt ) qrten ( k ) = qrten ( k ) + ( rr ( k ) - rr_tmp ( k )) * orhodt nrten ( k ) = nrten ( k ) + ( nr ( k ) - nr_tmp ( k )) * orhodt pfll1 ( k ) = pfll1 ( k ) + pfll ( k ) enddo pptrain = pptrain + rainsfc do k = kte + 1 , kts , - 1 vtrk ( k ) = 0. vtnrk ( k ) = 0. enddo do k = kte , kts , - 1 vtr = 0. if ( rr ( k ). gt . R1 ) then lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr vtr = rhof ( k ) * av_r * crg ( 6 ) * org3 * lamr ** cre ( 3 ) & * (( lamr + fv_r ) ** ( - cre ( 6 ))) vtrk ( k ) = vtr ! First below is technically correct: !         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                & !                     *((lamr+fv_r)**(-cre(5))) ! Test: make number fall faster (but still slower than mass) ! Goal: less prominent size sorting vtr = rhof ( k ) * av_r * crg ( 7 ) / crg ( 12 ) * lamr ** cre ( 12 ) & * (( lamr + fv_r ) ** ( - cre ( 7 ))) vtnrk ( k ) = vtr endif enddo enddo endif ! if(.not. sedi_semi) endif !+---+-----------------------------------------------------------------+ if ( any ( l_qc . eqv . . true .)) then do k = kte , kts , - 1 sed_c ( k ) = vtck ( k ) * rc ( k ) sed_n ( k ) = vtnck ( k ) * nc ( k ) enddo do k = ksed1 ( 5 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qcten ( k ) = qcten ( k ) + ( sed_c ( k + 1 ) - sed_c ( k )) * odzq * orho ncten ( k ) = ncten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) * odzq * orho rc ( k ) = max ( r1 , rc ( k ) + ( sed_c ( k + 1 ) - sed_c ( k )) * odzq * dt ) nc ( k ) = max ( 1 0. , nc ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) * odzq * dt ) enddo endif !+---+-----------------------------------------------------------------+ if ( any ( l_qi . eqv . . true .)) then nstep = nint ( 1. / onstep ( 2 )) do n = 1 , nstep do k = kte , kts , - 1 sed_i ( k ) = vtik ( k ) * ri ( k ) sed_n ( k ) = vtnik ( k ) * ni ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) - sed_i ( k ) * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) - sed_n ( k ) * odzq * onstep ( 2 ) * orho ri ( k ) = max ( r1 , ri ( k ) - sed_i ( k ) * odzq * dt * onstep ( 2 )) ni ( k ) = max ( r2 , ni ( k ) - sed_n ( k ) * odzq * dt * onstep ( 2 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_i ( k ) * DT * onstep ( 2 ) #endif do k = ksed1 ( 2 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qiten ( k ) = qiten ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * onstep ( 2 ) * orho niten ( k ) = niten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 2 ) * orho ri ( k ) = max ( r1 , ri ( k ) + ( sed_i ( k + 1 ) - sed_i ( k )) & * odzq * dt * onstep ( 2 )) ni ( k ) = max ( r2 , ni ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * DT * onstep ( 2 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_i ( k ) * DT * onstep ( 2 ) #endif enddo if ( ri ( kts ). gt . R1 * 100 0. ) & pptice = pptice + sed_i ( kts ) * DT * onstep ( 2 ) enddo endif !+---+-----------------------------------------------------------------+ if ( any ( l_qs . eqv . . true .)) then nstep = nint ( 1. / onstep ( 3 )) do n = 1 , nstep do k = kte , kts , - 1 sed_s ( k ) = vtsk ( k ) * rs ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) - sed_s ( k ) * odzq * onstep ( 3 ) * orho rs ( k ) = max ( r1 , rs ( k ) - sed_s ( k ) * odzq * dt * onstep ( 3 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_s ( k ) * DT * onstep ( 3 ) #endif do k = ksed1 ( 3 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qsten ( k ) = qsten ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * onstep ( 3 ) * orho rs ( k ) = max ( r1 , rs ( k ) + ( sed_s ( k + 1 ) - sed_s ( k )) & * odzq * DT * onstep ( 3 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_s ( k ) * DT * onstep ( 3 ) #endif enddo if ( rs ( kts ). gt . R1 * 100 0. ) & pptsnow = pptsnow + sed_s ( kts ) * DT * onstep ( 3 ) enddo endif !+---+-----------------------------------------------------------------+ if ( any ( l_qg . eqv . . true .)) then nstep = nint ( 1. / onstep ( 4 )) if (. not . sedi_semi ) then do n = 1 , nstep do k = kte , kts , - 1 sed_g ( k ) = vtgk ( k ) * rg ( k ) sed_n ( k ) = vtngk ( k ) * ng ( k ) sed_b ( k ) = vtgk ( k ) * rb ( k ) enddo k = kte odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) - sed_g ( k ) * odzq * onstep ( 4 ) * orho ngten ( k ) = ngten ( k ) - sed_n ( k ) * odzq * onstep ( 4 ) * orho qbten ( k ) = qbten ( k ) - sed_b ( k ) * odzq * onstep ( 4 ) rg ( k ) = max ( r1 , rg ( k ) - sed_g ( k ) * odzq * dt * onstep ( 4 )) ng ( k ) = max ( r2 , ng ( k ) - sed_n ( k ) * odzq * dt * onstep ( 4 )) rb ( k ) = max ( r1 / rho ( k ) / rho_g ( nrhg ), rb ( k ) - sed_b ( k ) * odzq * dt * onstep ( 4 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_g ( k ) * DT * onstep ( 4 ) #endif do k = ksed1 ( 4 ), kts , - 1 odzq = 1. / dzq ( k ) orho = 1. / rho ( k ) qgten ( k ) = qgten ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * onstep ( 4 ) * orho ngten ( k ) = ngten ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * onstep ( 4 ) * orho qbten ( k ) = qbten ( k ) + ( sed_b ( k + 1 ) - sed_b ( k )) & * odzq * onstep ( 4 ) rg ( k ) = max ( r1 , rg ( k ) + ( sed_g ( k + 1 ) - sed_g ( k )) & * odzq * dt * onstep ( 4 )) ng ( k ) = max ( r2 , ng ( k ) + ( sed_n ( k + 1 ) - sed_n ( k )) & * odzq * dt * onstep ( 4 )) rb ( k ) = max ( rg ( k ) / rho ( k ) / rho_g ( nrhg ), rb ( k ) + ( sed_b ( k + 1 ) - sed_b ( k )) & * odzq * DT * onstep ( 4 )) #if defined(ccpp_default) pfil1 ( k ) = pfil1 ( k ) + sed_g ( k ) * DT * onstep ( 4 ) #endif enddo if ( rg ( kts ). gt . R1 * 100 0. ) & pptgraul = pptgraul + sed_g ( kts ) * DT * onstep ( 4 ) enddo else ! if(.not. sedi_semi) then niter = 1 dtcfl = dt niter = int ( nstep / max ( decfl_ , 1 )) + 1 dtcfl = dt / niter do n = 1 , niter rg_tmp (:) = rg (:) call semi_lagrange_sedim ( kte , dzq , vtgk , rg , graulsfc , pfil , dtcfl , R1 ) do k = kts , kte orhodt = 1. / ( rho ( k ) * dt ) qgten ( k ) = qgten ( k ) + ( rg ( k ) - rg_tmp ( k )) * orhodt pfil1 ( k ) = pfil1 ( k ) + pfil ( k ) enddo pptgraul = pptgraul + graulsfc do k = kte + 1 , kts , - 1 vtgk ( k ) = 0. enddo do k = kte , kts , - 1 vtg = 0. if ( rg ( k ). gt . R1 ) then ygra1 = alog10 ( max ( 1.E-9 , rg ( k ))) rand = 0.0 if ( present ( rand1 )) then rand = rand1 endif zans1 = 3.4 + 2. / 7. * ( ygra1 + 8. ) + rand N0_exp = 1 0. ** ( zans1 ) N0_exp = MAX ( gonv_min , MIN ( N0_exp , gonv_max )) lam_exp = ( N0_exp * am_g ( idx_bg ( k )) * cgg ( 1 , 1 ) / rg ( k )) ** oge1 lamg = lam_exp * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** obmg vtg = rhof ( k ) * afall * cgg ( 6 , idx_bg ( k )) * ogg3 * ( 1. / lamg ) ** bfall if ( temp ( k ). gt . T_0 ) then vtgk ( k ) = MAX ( vtg , vtrk ( k )) else vtgk ( k ) = vtg endif endif enddo enddo endif ! if(.not. sedi_semi) then endif !+---+-----------------------------------------------------------------+ !.. Instantly melt any cloud ice into cloud water if above 0C and !.. instantly freeze any cloud water found below HGFR. !+---+-----------------------------------------------------------------+ if (. not . iiwarm ) then do k = kts , kte xri = max ( 0.0 , qi1d ( k ) + qiten ( k ) * DT ) if ( ( temp ( k ). gt . T_0 ) . and . ( xri . gt . 0.0 ) ) then qcten ( k ) = qcten ( k ) + xri * odt ncten ( k ) = ncten ( k ) + ni1d ( k ) * odt qiten ( k ) = qiten ( k ) - xri * odt niten ( k ) = - ni1d ( k ) * odt tten ( k ) = tten ( k ) - lfus * ocp ( k ) * xri * odt * ( 1 - IFDRY ) endif xrc = max ( 0.0 , qc1d ( k ) + qcten ( k ) * DT ) if ( ( temp ( k ). lt . HGFR ) . and . ( xrc . gt . 0.0 ) ) then lfus2 = lsub - lvap ( k ) xnc = nc1d ( k ) + ncten ( k ) * DT qiten ( k ) = qiten ( k ) + xrc * odt niten ( k ) = niten ( k ) + xnc * odt qcten ( k ) = qcten ( k ) - xrc * odt ncten ( k ) = ncten ( k ) - xnc * odt tten ( k ) = tten ( k ) + lfus2 * ocp ( k ) * xrc * odt * ( 1 - IFDRY ) endif enddo endif !================================================================================================================= !.. All tendencies computed, apply and pass back final values to parent. !+---+-----------------------------------------------------------------+ do k = kts , kte t1d ( k ) = t1d ( k ) + tten ( k ) * DT qv1d ( k ) = max ( min_qv , qv1d ( k ) + qvten ( k ) * dt ) qc1d ( k ) = qc1d ( k ) + qcten ( k ) * dt nc1d ( k ) = max ( 2. / rho ( k ), min ( nc1d ( k ) + ncten ( k ) * dt , nt_c_max )) if ( tempo_init_cfgs % aerosolaware_flag ) then nwfa1d ( k ) = max ( nwfa_default , min ( aero_max , ( nwfa1d ( k ) + nwfaten ( k ) * dt ))) nifa1d ( k ) = max ( nifa_default , min ( aero_max , ( nifa1d ( k ) + nifaten ( k ) * dt ))) endif if ( qc1d ( k ) . le . R1 ) then qc1d ( k ) = 0.0 nc1d ( k ) = 0.0 else if ( nc1d ( k ) * rho ( k ). gt . 1000 0.e6 ) then nu_c = 2 elseif ( nc1d ( k ) * rho ( k ). lt . 10 0. ) then nu_c = 15 else nu_c = nint ( nu_c_scale / ( nc1d ( k ) * rho ( k ))) + 2 rand = 0.0 if ( present ( rand2 )) then rand = rand2 endif nu_c = max ( 2 , min ( nu_c + nint ( rand ), 15 )) endif lamc = ( am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) * nc1d ( k ) / qc1d ( k )) ** obmr xDc = ( bm_r + nu_c + 1. ) / lamc if ( xDc . lt . D0c ) then lamc = cce ( 2 , nu_c ) / D0c elseif ( xDc . gt . D0r * 2. ) then lamc = cce ( 2 , nu_c ) / ( D0r * 2. ) endif nc1d ( k ) = min ( ccg ( 1 , nu_c ) * ocg2 ( nu_c ) * qc1d ( k ) / am_r * lamc ** bm_r ,& real ( Nt_c_max , kind = dp ) / rho ( k )) endif qi1d ( k ) = qi1d ( k ) + qiten ( k ) * DT ni1d ( k ) = max ( R2 / rho ( k ), ni1d ( k ) + niten ( k ) * DT ) if ( qi1d ( k ) . le . R1 ) then qi1d ( k ) = 0.0 ni1d ( k ) = 0.0 else lami = ( am_i * cig ( 2 ) * oig1 * ni1d ( k ) / qi1d ( k )) ** obmi ilami = 1. / lami xDi = ( bm_i + mu_i + 1. ) * ilami if ( xDi . lt . 5.E-6 ) then lami = cie ( 2 ) / 5.E-6 elseif ( xDi . gt . 30 0.E-6 ) then lami = cie ( 2 ) / 30 0.E-6 endif ni1d ( k ) = min ( cig ( 1 ) * oig2 * qi1d ( k ) / am_i * lami ** bm_i , max_ni / rho ( k )) endif qr1d ( k ) = qr1d ( k ) + qrten ( k ) * DT nr1d ( k ) = max ( R2 / rho ( k ), nr1d ( k ) + nrten ( k ) * DT ) if ( qr1d ( k ) . le . R1 ) then qr1d ( k ) = 0.0 nr1d ( k ) = 0.0 else lamr = ( am_r * crg ( 3 ) * org2 * nr1d ( k ) / qr1d ( k )) ** obmr mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) / lamr if ( mvd_r ( k ) . gt . 2.5E-3 ) then mvd_r ( k ) = 2.5E-3 elseif ( mvd_r ( k ) . lt . D0r * 0.75 ) then mvd_r ( k ) = D0r * 0.75 endif lamr = ( 3.0 + mu_r + 0.672 ) / mvd_r ( k ) nr1d ( k ) = crg ( 2 ) * org3 * qr1d ( k ) * lamr ** bm_r / am_r endif qs1d ( k ) = qs1d ( k ) + qsten ( k ) * DT if ( qs1d ( k ) . le . R1 ) qs1d ( k ) = 0.0 qg1d ( k ) = qg1d ( k ) + qgten ( k ) * DT ng1d ( k ) = MAX ( R2 / rho ( k ), ng1d ( k ) + ngten ( k ) * DT ) if ( qg1d ( k ) . le . R1 ) then qg1d ( k ) = 0.0 ng1d ( k ) = 0.0 qb1d ( k ) = 0.0 else qb1d ( k ) = max ( qg1d ( k ) / rho_g ( nrhg ), qb1d ( k ) + qbten ( k ) * dt ) qb1d ( k ) = min ( qg1d ( k ) / rho_g ( 1 ), qb1d ( k )) idx_bg ( k ) = max ( 1 , min ( nint ( qg1d ( k ) / qb1d ( k ) * 0.01 ) + 1 , nrhg )) if (. not . tempo_init_cfgs % hailaware_flag ) idx_bg ( k ) = idx_bg1 lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng1d ( k ) / qg1d ( k )) ** obmg mvd_g ( k ) = ( 3.0 + mu_g + 0.672 ) / lamg if ( mvd_g ( k ) . gt . 2 5.4E-3 ) then mvd_g ( k ) = 2 5.4E-3 elseif ( mvd_g ( k ) . lt . D0r ) then mvd_g ( k ) = D0r endif lamg = ( 3.0 + mu_g + 0.672 ) / mvd_g ( k ) ng1d ( k ) = cgg ( 2 , 1 ) * ogg3 * qg1d ( k ) * lamg ** bm_g / am_g ( idx_bg ( k )) endif enddo #if defined(ccpp_default) ! Diagnostics calculate_extended_diagnostics : if ( ext_diag ) then do k = kts , kte if ( prw_vcd ( k ). gt . 0 ) then prw_vcdc1 ( k ) = prw_vcd ( k ) * dt elseif ( prw_vcd ( k ). lt . 0 ) then prw_vcde1 ( k ) = - 1 * prw_vcd ( k ) * dt endif !heating/cooling diagnostics tpri_inu1 ( k ) = pri_inu ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT if ( pri_ide ( k ). gt . 0 ) then tpri_ide1_d ( k ) = pri_ide ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT else tpri_ide1_s ( k ) = - pri_ide ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif if ( temp ( k ). lt . T_0 ) then tprs_ide1 ( k ) = prs_ide ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif if ( prs_sde ( k ). gt . 0 ) then tprs_sde1_d ( k ) = prs_sde ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT else tprs_sde1_s ( k ) = - prs_sde ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif if ( prg_gde ( k ). gt . 0 ) then tprg_gde1_d ( k ) = prg_gde ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT else tprg_gde1_s ( k ) = - prg_gde ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif tpri_iha1 ( k ) = pri_iha ( k ) * lsub * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tpri_wfz1 ( k ) = pri_wfz ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tpri_rfz1 ( k ) = pri_rfz ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tprg_rfz1 ( k ) = prg_rfz ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tprs_scw1 ( k ) = prs_scw ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tprg_scw1 ( k ) = prg_scw ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tprg_rcs1 ( k ) = prg_rcs ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT if ( temp ( k ). lt . T_0 ) then tprs_rcs1 ( k ) = prs_rcs ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif tprr_rci1 ( k ) = prr_rci ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT if ( temp ( k ). lt . T_0 ) then tprg_rcg1 ( k ) = prg_rcg ( k ) * lfus2 * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif if ( prw_vcd ( k ). gt . 0 ) then tprw_vcd1_c ( k ) = lvap ( k ) * ocp ( k ) * prw_vcd ( k ) * ( 1 - IFDRY ) * DT else tprw_vcd1_e ( k ) = - lvap ( k ) * ocp ( k ) * prw_vcd ( k ) * ( 1 - IFDRY ) * DT endif ! cooling terms tprr_sml1 ( k ) = prr_sml ( k ) * lfus * ocp ( k ) * orho * ( 1 - IFDRY ) * DT tprr_gml1 ( k ) = prr_gml ( k ) * lfus * ocp ( k ) * orho * ( 1 - IFDRY ) * DT if ( temp ( k ). ge . T_0 ) then tprr_rcg1 ( k ) = - prr_rcg ( k ) * lfus * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif if ( temp ( k ). ge . T_0 ) then tprr_rcs1 ( k ) = - prr_rcs ( k ) * lfus * ocp ( k ) * orho * ( 1 - IFDRY ) * DT endif tprv_rev1 ( k ) = lvap ( k ) * ocp ( k ) * prv_rev ( k ) * ( 1 - IFDRY ) * DT tten1 ( k ) = tten ( k ) * DT qvten1 ( k ) = qvten ( k ) * DT qiten1 ( k ) = qiten ( k ) * DT qrten1 ( k ) = qrten ( k ) * DT qsten1 ( k ) = qsten ( k ) * DT qgten1 ( k ) = qgten ( k ) * DT niten1 ( k ) = niten ( k ) * DT nrten1 ( k ) = nrten ( k ) * DT ncten1 ( k ) = ncten ( k ) * DT qcten1 ( k ) = qcten ( k ) * DT enddo endif calculate_extended_diagnostics #endif end subroutine mp_tempo_main !================================================================================================================= !..Function to compute collision efficiency of collector species (rain, !.. snow, graupel) of aerosols.  Follows Wang et al, 2010, ACP, which !.. follows Slinn (1983). !+---+-----------------------------------------------------------------+ real function Eff_aero ( D , Da , visc , rhoa , Temp , species ) implicit none real ( wp ) :: D , Da , visc , rhoa , Temp character ( LEN = 1 ) :: species real ( wp ) :: aval , Cc , diff , Re , Sc , St , St2 , vt , Eff real ( wp ), parameter :: boltzman = 1.3806503E-23 real ( wp ), parameter :: meanPath = 0.0256E-6 vt = 1. if ( species . eq . 'r' ) then vt = - 0.1021 + 4.932E3 * D - 0.9551E6 * D * D & + 0.07934E9 * D * D * D - 0.002362E12 * D * D * D * D elseif ( species . eq . 's' ) then vt = av_s * D ** bv_s elseif ( species . eq . 'g' ) then vt = av_g ( idx_bg1 ) * D ** bv_g ( idx_bg1 ) endif Cc = 1. + 2. * meanPath / Da * ( 1.257 + 0.4 * exp ( - 0.55 * Da / meanPath )) diff = boltzman * Temp * Cc / ( 3. * PI * visc * Da ) Re = 0.5 * rhoa * D * vt / visc Sc = visc / ( rhoa * diff ) St = Da * Da * vt * 100 0. / ( 9. * visc * D ) aval = 1. + LOG ( 1. + Re ) St2 = ( 1.2 + 1. / 1 2. * aval ) / ( 1. + aval ) eff = 4. / ( re * sc ) * ( 1. + 0.4 * sqrt ( re ) * sc ** 0.3333 & + 0.16 * sqrt ( re ) * sqrt ( sc )) & + 4. * da / d * ( 0.02 + da / d * ( 1. + 2. * sqrt ( re ))) if ( St . gt . St2 ) Eff = Eff + ( ( St - St2 ) / ( St - St2 + 0.666667 )) ** 1.5 eff_aero = max ( 1.e-5 , min ( eff , 1.0 )) end function Eff_aero !================================================================================================================= !..Retrieve fraction of CCN that gets activated given the model temp, !.. vertical velocity, and available CCN concentration.  The lookup !.. table (read from external file) has CCN concentration varying the !.. quickest, then updraft, then temperature, then mean aerosol radius, !.. and finally hygroscopicity, kappa. !.. TO_DO ITEM:  For radiation cooling producing fog, in which case the !.. updraft velocity could easily be negative, we could use the temp !.. and its tendency to diagnose a pretend postive updraft velocity. !+---+-----------------------------------------------------------------+ real function activ_ncloud ( Tt , Ww , NCCN , lsm_in ) implicit none REAL , INTENT ( IN ) :: Tt , Ww , NCCN INTEGER , INTENT ( IN ), optional :: lsm_in REAL :: n_local , w_local INTEGER :: i , j , k , l , m , n REAL :: A , B , C , D , t , u , x1 , x2 , y1 , y2 , nx , wy , fraction REAL :: lower_lim_nuc_frac !     ta_Na = (/10.0, 31.6, 100.0, 316.0, 1000.0, 3160.0, 10000.0/)  ntb_arc !     ta_Ww = (/0.01, 0.0316, 0.1, 0.316, 1.0, 3.16, 10.0, 31.6, 100.0/)  ntb_arw !     ta_Tk = (/243.15, 253.15, 263.15, 273.15, 283.15, 293.15, 303.15/)  ntb_art !     ta_Ra = (/0.01, 0.02, 0.04, 0.08, 0.16/)  ntb_arr !     ta_Ka = (/0.2, 0.4, 0.6, 0.8/)  ntb_ark n_local = NCCN * 1.E-6 w_local = Ww if ( n_local . ge . ta_Na ( ntb_arc )) then n_local = ta_Na ( ntb_arc ) - 1.0 elseif ( n_local . le . ta_Na ( 1 )) then n_local = ta_Na ( 1 ) + 1.0 endif do n = 2 , ntb_arc if ( n_local . ge . ta_Na ( n - 1 ) . and . n_local . lt . ta_Na ( n )) goto 8003 enddo 8003 continue i = n x1 = LOG ( ta_Na ( i - 1 )) x2 = LOG ( ta_Na ( i )) if ( w_local . ge . ta_Ww ( ntb_arw )) then w_local = ta_Ww ( ntb_arw ) - 1.0 elseif ( w_local . le . ta_Ww ( 1 )) then w_local = ta_Ww ( 1 ) + 0.001 endif do n = 2 , ntb_arw if ( w_local . ge . ta_Ww ( n - 1 ) . and . w_local . lt . ta_Ww ( n )) goto 8005 enddo 8005 continue j = n y1 = LOG ( ta_Ww ( j - 1 )) y2 = LOG ( ta_Ww ( j )) k = MAX ( 1 , MIN ( NINT ( ( Tt - ta_Tk ( 1 )) * 0.1 ) + 1 , ntb_art )) !..The next two values are indexes of mean aerosol radius and !.. hygroscopicity.  Currently these are constant but a future version !.. should implement other variables to allow more freedom such as !.. at least simple separation of tiny size sulfates from larger !.. sea salts. l = 3 m = 2 lower_lim_nuc_frac = 0. if ( present ( lsm_in )) then if ( lsm_in . eq . 1 ) then ! land lower_lim_nuc_frac = 0. else if ( lsm_in . eq . 0 ) then ! water lower_lim_nuc_frac = 0.15 else lower_lim_nuc_frac = 0.15 ! catch-all for anything else endif endif A = tnccn_act ( i - 1 , j - 1 , k , l , m ) B = tnccn_act ( i , j - 1 , k , l , m ) C = tnccn_act ( i , j , k , l , m ) D = tnccn_act ( i - 1 , j , k , l , m ) nx = LOG ( n_local ) wy = LOG ( w_local ) t = ( nx - x1 ) / ( x2 - x1 ) u = ( wy - y1 ) / ( y2 - y1 ) !     t = (n_local-ta(Na(i-1))/(ta_Na(i)-ta_Na(i-1)) !     u = (w_local-ta_Ww(j-1))/(ta_Ww(j)-ta_Ww(j-1)) fraction = ( 1.0 - t ) * ( 1.0 - u ) * A + t * ( 1.0 - u ) * B + t * u * C + ( 1.0 - t ) * u * D fraction = max ( fraction , lower_lim_nuc_frac ) !     if (NCCN*fraction .gt. 0.75*Nt_c_max) then !        write(*,*) ' DEBUG-GT ', n_local, w_local, Tt, i, j, k !     endif activ_ncloud = NCCN * fraction end function activ_ncloud !================================================================================================================= !+---+-----------------------------------------------------------------+ real function iceDeMott ( tempc , qv , qvs , qvsi , rho , nifa ) implicit none REAL , INTENT ( IN ) :: tempc , qv , qvs , qvsi , rho , nifa !..Local vars REAL :: satw , sati , siw , p_x , si0x , dtt , dsi , dsw , dab , fc , hx REAL :: ntilde , n_in , nmax , nhat , mux , xni , nifa_cc REAL , PARAMETER :: p_c1 = 100 0. REAL , PARAMETER :: p_rho_c = 0.76 REAL , PARAMETER :: p_alpha = 1.0 REAL , PARAMETER :: p_gam = 2. REAL , PARAMETER :: delT = 5. REAL , PARAMETER :: T0x = - 4 0. REAL , PARAMETER :: Sw0x = 0.97 REAL , PARAMETER :: delSi = 0.1 REAL , PARAMETER :: hdm = 0.15 REAL , PARAMETER :: p_psi = 0.058707 * p_gam / p_rho_c REAL , PARAMETER :: aap = 1. REAL , PARAMETER :: bbp = 0. REAL , PARAMETER :: y1p = - 3 5. REAL , PARAMETER :: y2p = - 2 5. REAL , PARAMETER :: rho_not0 = 10132 5. / ( 28 7.05 * 27 3.15 ) !+---+ xni = 0.0 !     satw = qv/qvs !     sati = qv/qvsi !     siw = qvs/qvsi !     p_x = -1.0261+(3.1656e-3*tempc)+(5.3938e-4*(tempc*tempc))         & !                +  (8.2584e-6*(tempc*tempc*tempc)) !     si0x = 1.+(10.**p_x) !     if (sati.ge.si0x .and. satw.lt.0.985) then !        dtt = delta_p (tempc, T0x, T0x+delT, 1., hdm) !        dsi = delta_p (sati, Si0x, Si0x+delSi, 0., 1.) !        dsw = delta_p (satw, Sw0x, 1., 0., 1.) !        fc = dtt*dsi*0.5 !        hx = min(fc+((1.-fc)*dsw), 1.) !        ntilde = p_c1*p_gam*((exp(12.96*(sati-1.1)))**0.3) / p_rho_c !        if (tempc .le. y1p) then !           n_in = ntilde !        elseif (tempc .ge. y2p) then !           n_in = p_psi*p_c1*exp(12.96*(sati-1.)-0.639) !        else !           if (tempc .le. -30.) then !              nmax = p_c1*p_gam*(exp(12.96*(siw-1.1)))**0.3/p_rho_c !           else !              nmax = p_psi*p_c1*exp(12.96*(siw-1.)-0.639) !           endif !           ntilde = MIN(ntilde, nmax) !           nhat = MIN(p_psi*p_c1*exp(12.96*(sati-1.)-0.639), nmax) !           dab = delta_p (tempc, y1p, y2p, aap, bbp) !           n_in = MIN(nhat*(ntilde/nhat)**dab, nmax) !        endif !        mux = hx*p_alpha*n_in*rho !        xni = mux*((6700.*nifa)-200.)/((6700.*5.E5)-200.) !     elseif (satw.ge.0.985 .and. tempc.gt.HGFR-273.15) then nifa_cc = MAX ( 0.5 , nifa * RHO_NOT0 * 1.E-6 / rho ) !        xni  = 3.*nifa_cc**(1.25)*exp((0.46*(-tempc))-11.6)              !  [DeMott, 2015] xni = ( 5.94e-5 * ( - tempc ) ** 3.33 ) & !  [DeMott, 2010] * ( nifa_cc ** (( - 0.0264 * ( tempc )) + 0.0033 )) xni = xni * rho / RHO_NOT0 * 100 0. !     endif iceDeMott = MAX ( 0. , xni ) end FUNCTION iceDeMott !+---+-----------------------------------------------------------------+ !..Newer research since Koop et al (2001) suggests that the freezing !.. rate should be lower than original paper, so J_rate is reduced !.. by two orders of magnitude. real function iceKoop ( temp , qv , qvs , naero , dt ) implicit none REAL , INTENT ( IN ) :: temp , qv , qvs , naero , DT REAL :: mu_diff , a_w_i , delta_aw , log_J_rate , J_rate , prob_h , satw REAL :: xni xni = 0.0 satw = qv / qvs mu_diff = 21036 8.0 + ( 13 1.438 * temp ) - ( 3.32373E6 / temp ) & & - ( 4172 9.1 * alog ( temp )) a_w_i = exp ( mu_diff / ( R_uni * temp )) delta_aw = satw - a_w_i log_J_rate = - 90 6.7 + ( 850 2.0 * delta_aw ) & & - ( 2692 4.0 * delta_aw * delta_aw ) & & + ( 2918 0.0 * delta_aw * delta_aw * delta_aw ) log_J_rate = MIN ( 2 0.0 , log_J_rate ) J_rate = 1 0. ** log_J_rate ! cm-3 s-1 prob_h = MIN ( 1. - exp ( - J_rate * ar_volume * DT ), 1. ) if ( prob_h . gt . 0. ) then xni = MIN ( prob_h * naero , 100 0.E3 ) endif iceKoop = MAX ( 0.0 , xni ) end FUNCTION iceKoop !+---+-----------------------------------------------------------------+ !.. Helper routine for Phillips et al (2008) ice nucleation.  Trude REAL FUNCTION delta_p ( yy , y1 , y2 , aa , bb ) IMPLICIT NONE REAL , INTENT ( IN ) :: yy , y1 , y2 , aa , bb REAL :: dab , A , B , a0 , a1 , a2 , a3 A = 6. * ( aa - bb ) / (( y2 - y1 ) * ( y2 - y1 ) * ( y2 - y1 )) B = aa + ( A * y1 * y1 * y1 / 6. ) - ( A * y1 * y1 * y2 * 0.5 ) a0 = B a1 = A * y1 * y2 a2 = - A * ( y1 + y2 ) * 0.5 a3 = A / 3. if ( yy . le . y1 ) then dab = aa else if ( yy . ge . y2 ) then dab = bb else dab = a0 + ( a1 * yy ) + ( a2 * yy * yy ) + ( a3 * yy * yy * yy ) endif if ( dab . lt . aa ) then dab = aa endif if ( dab . gt . bb ) then dab = bb endif delta_p = dab END FUNCTION delta_p !+---+-----------------------------------------------------------------+ !------------------------------------------------------------------- SUBROUTINE semi_lagrange_sedim ( km , dzl , wwl , rql , precip , pfsan , dt , R1 ) !------------------------------------------------------------------- ! ! This routine is a semi-Lagrangain forward advection for hydrometeors ! with mass conservation and positive definite advection ! 2nd order interpolation with monotonic piecewise parabolic method is used. ! This routine is under assumption of decfl < 1 for semi_Lagrangian ! ! dzl    depth of model layer in meter ! wwl    terminal velocity at model layer m/s ! rql    dry air density*mixing ratio ! precip precipitation at surface ! dt     time step ! ! author: hann-ming henry juang <henry.juang@noaa.gov> !         implemented by song-you hong ! reference: Juang, H.-M., and S.-Y. Hong, 2010: Forward semi-Lagrangian advection !         with mass conservation and positive definiteness for falling !         hydrometeors. *Mon.  Wea. Rev.*, *138*, 1778-1791 ! implicit none integer , intent ( in ) :: km real , intent ( in ) :: dt , R1 real , intent ( in ) :: dzl ( km ), wwl ( km ) real , intent ( out ) :: precip real , intent ( inout ) :: rql ( km ) real , intent ( out ) :: pfsan ( km ) integer k , m , kk , kb , kt real tl , tl2 , qql , dql , qqd real th , th2 , qqh , dqh real zsum , qsum , dim , dip , con1 , fa1 , fa2 real allold , decfl real dz ( km ), ww ( km ), qq ( km ) real wi ( km + 1 ), zi ( km + 1 ), za ( km + 2 ) real qn ( km ) real dza ( km + 1 ), qa ( km + 1 ), qmi ( km + 1 ), qpi ( km + 1 ) real net_flx ( km ) ! precip = 0.0 qa (:) = 0.0 qq (:) = 0.0 dz (:) = dzl (:) ww (:) = wwl (:) do k = 1 , km if ( rql ( k ). gt . R1 ) then qq ( k ) = rql ( k ) else ww ( k ) = 0.0 endif pfsan ( k ) = 0.0 net_flx ( k ) = 0.0 enddo ! skip for no precipitation for all layers allold = 0.0 do k = 1 , km allold = allold + qq ( k ) enddo if ( allold . le . 0.0 ) then return endif ! ! compute interface values zi ( 1 ) = 0.0 do k = 1 , km zi ( k + 1 ) = zi ( k ) + dz ( k ) enddo !     n=1 ! plm is 2nd order, we can use 2nd order wi or 3rd order wi ! 2nd order interpolation to get wi wi ( 1 ) = ww ( 1 ) wi ( km + 1 ) = ww ( km ) do k = 2 , km wi ( k ) = ( ww ( k ) * dz ( k - 1 ) + ww ( k - 1 ) * dz ( k )) / ( dz ( k - 1 ) + dz ( k )) enddo ! 3rd order interpolation to get wi fa1 = 9. / 1 6. fa2 = 1. / 1 6. wi ( 1 ) = ww ( 1 ) wi ( 2 ) = 0.5 * ( ww ( 2 ) + ww ( 1 )) do k = 3 , km - 1 wi ( k ) = fa1 * ( ww ( k ) + ww ( k - 1 )) - fa2 * ( ww ( k + 1 ) + ww ( k - 2 )) enddo wi ( km ) = 0.5 * ( ww ( km ) + ww ( km - 1 )) wi ( km + 1 ) = ww ( km ) ! terminate of top of raingroup do k = 2 , km if ( ww ( k ). eq . 0.0 ) wi ( k ) = ww ( k - 1 ) enddo ! diffusivity of wi con1 = 0.05 do k = km , 1 , - 1 decfl = ( wi ( k + 1 ) - wi ( k )) * dt / dz ( k ) if ( decfl . gt . con1 ) then wi ( k ) = wi ( k + 1 ) - con1 * dz ( k ) / dt endif enddo ! compute arrival point do k = 1 , km + 1 za ( k ) = zi ( k ) - wi ( k ) * dt enddo za ( km + 2 ) = zi ( km + 1 ) do k = 1 , km + 1 dza ( k ) = za ( k + 1 ) - za ( k ) enddo ! computer deformation at arrival point do k = 1 , km qa ( k ) = qq ( k ) * dz ( k ) / dza ( k ) enddo qa ( km + 1 ) = 0.0 ! estimate values at arrival cell interface with monotone do k = 2 , km dip = ( qa ( k + 1 ) - qa ( k )) / ( dza ( k + 1 ) + dza ( k )) dim = ( qa ( k ) - qa ( k - 1 )) / ( dza ( k - 1 ) + dza ( k )) if ( dip * dim . le . 0.0 ) then qmi ( k ) = qa ( k ) qpi ( k ) = qa ( k ) else qpi ( k ) = qa ( k ) + 0.5 * ( dip + dim ) * dza ( k ) qmi ( k ) = 2.0 * qa ( k ) - qpi ( k ) if ( qpi ( k ). lt . 0.0 . or . qmi ( k ). lt . 0.0 ) then qpi ( k ) = qa ( k ) qmi ( k ) = qa ( k ) endif endif enddo qpi ( 1 ) = qa ( 1 ) qmi ( 1 ) = qa ( 1 ) qmi ( km + 1 ) = qa ( km + 1 ) qpi ( km + 1 ) = qa ( km + 1 ) ! interpolation to regular point qn = 0.0 kb = 1 kt = 1 intp : do k = 1 , km kb = max ( kb - 1 , 1 ) kt = max ( kt - 1 , 1 ) ! find kb and kt if ( zi ( k ). ge . za ( km + 1 ) ) then exit intp else find_kb : do kk = kb , km if ( zi ( k ). le . za ( kk + 1 ) ) then kb = kk exit find_kb else cycle find_kb endif enddo find_kb find_kt : do kk = kt , km + 2 if ( zi ( k + 1 ). le . za ( kk ) ) then kt = kk exit find_kt else cycle find_kt endif enddo find_kt kt = kt - 1 ! compute q with piecewise constant method if ( kt . eq . kb ) then tl = ( zi ( k ) - za ( kb )) / dza ( kb ) th = ( zi ( k + 1 ) - za ( kb )) / dza ( kb ) tl2 = tl * tl th2 = th * th qqd = 0.5 * ( qpi ( kb ) - qmi ( kb )) qqh = qqd * th2 + qmi ( kb ) * th qql = qqd * tl2 + qmi ( kb ) * tl qn ( k ) = ( qqh - qql ) / ( th - tl ) else if ( kt . gt . kb ) then tl = ( zi ( k ) - za ( kb )) / dza ( kb ) tl2 = tl * tl qqd = 0.5 * ( qpi ( kb ) - qmi ( kb )) qql = qqd * tl2 + qmi ( kb ) * tl dql = qa ( kb ) - qql zsum = ( 1. - tl ) * dza ( kb ) qsum = dql * dza ( kb ) if ( kt - kb . gt . 1 ) then do m = kb + 1 , kt - 1 zsum = zsum + dza ( m ) qsum = qsum + qa ( m ) * dza ( m ) enddo endif th = ( zi ( k + 1 ) - za ( kt )) / dza ( kt ) th2 = th * th qqd = 0.5 * ( qpi ( kt ) - qmi ( kt )) dqh = qqd * th2 + qmi ( kt ) * th zsum = zsum + th * dza ( kt ) qsum = qsum + dqh * dza ( kt ) qn ( k ) = qsum / zsum endif cycle intp endif enddo intp ! rain out sum_precip : do k = 1 , km if ( za ( k ). lt . 0.0 . and . za ( k + 1 ). le . 0.0 ) then precip = precip + qa ( k ) * dza ( k ) net_flx ( k ) = qa ( k ) * dza ( k ) cycle sum_precip else if ( za ( k ). lt . 0.0 . and . za ( k + 1 ). gt . 0.0 ) then th = ( 0.0 - za ( k )) / dza ( k ) th2 = th * th qqd = 0.5 * ( qpi ( k ) - qmi ( k )) qqh = qqd * th2 + qmi ( k ) * th precip = precip + qqh * dza ( k ) net_flx ( k ) = qqh * dza ( k ) exit sum_precip endif exit sum_precip enddo sum_precip ! calculating precipitation fluxes do k = km , 1 , - 1 if ( k == km ) then pfsan ( k ) = net_flx ( k ) else pfsan ( k ) = pfsan ( k + 1 ) + net_flx ( k ) end if enddo ! ! replace the new values rql (:) = max ( qn (:), R1 ) END SUBROUTINE semi_lagrange_sedim !------------------ end module module_mp_tempo_main","tags":"","url":"sourcefile/module_mp_tempo_main.f90.html"},{"title":"module_mp_tempo_init.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_init.f90~~EfferentGraph sourcefile~module_mp_tempo_init.f90 module_mp_tempo_init.F90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module module_mp_tempo_init !! initialize variables for tempo microphysics !! includes a procedure to build and save lookup tables use module_mp_tempo_params , only : wp , sp , dp , tempo_init_cfgs , tempo_table_cfgs use module_mp_tempo_utils , only : snow_moments , calc_gamma_p , get_nuc ! use module_mp_radar #ifdef build_tables_with_mpi use mpi_f08 #endif implicit none private #ifdef unit_testing public :: compute_efrw , compute_efsw #endif public :: tempo_init , tempo_build_tables ! type(ty_tempo_init_cfgs) :: tempo_init_cfgs ! type(ty_tempo_table_cfgs) :: tempo_table_cfgs contains subroutine tempo_init ( aerosolaware_flag , hailaware_flag , restart_flag ) !! public procedure called to initialize tempo microphysics use module_mp_tempo_params , only : tempo_version , t_efrw , & initialize_graupel_vars , initialize_parameters , initialize_bins_for_tables , & initialize_array_efrw , initialize_array_efsw , initialize_arrays_drop_evap , initialize_arrays_ccn , initialize_arrays_qi_aut_qs , & initialize_arrays_qr_acr_qs , initialize_arrays_qr_acr_qg , initialize_arrays_freezewater , & am_r , bm_r , mu_r , am_s , bm_s , mu_s , am_g , bm_g , mu_g , idx_bg1 ! For radar logical , intent ( in ), optional :: aerosolaware_flag , hailaware_flag , restart_flag character ( len = 100 ) :: table_filename integer :: table_size logical :: initialize_mp_vars ! get tempo version from readme file call get_version ( tempo_version ) ! check an allocatable array (t_efrw) to see if initialization can be skipped initialize_mp_vars = . true . if ( allocated ( t_efrw )) initialize_mp_vars = . false . if ( initialize_mp_vars ) then if ( present ( aerosolaware_flag )) tempo_init_cfgs % aerosolaware_flag = aerosolaware_flag if ( present ( hailaware_flag )) tempo_init_cfgs % hailaware_flag = hailaware_flag if ( present ( restart_flag )) tempo_init_cfgs % restart_flag = restart_flag write ( * , '(A)' ) 'tempo_init() --- TEMPO microphysics configuration options: ' write ( * , '(A,L)' ) 'tempo_init() --- aerosol aware = ' , tempo_init_cfgs % aerosolaware_flag write ( * , '(A,L)' ) 'tempo_init() --- hail aware = ' , tempo_init_cfgs % hailaware_flag write ( * , '(A,L)' ) 'tempo_init() --- restart = ' , tempo_init_cfgs % restart_flag ! set graupel variables from hail_aware_flag call initialize_graupel_vars ( tempo_init_cfgs % hailaware_flag ) write ( * , '(A,L)' ) 'tempo_init() --- initialized graupel variables using hail aware = ' , tempo_init_cfgs % hailaware_flag ! set parameters that can depend on the host model call initialize_parameters () write ( * , '(A)' ) 'tempo_init() --- initialized parameters' ! creates log-spaced bins of hydrometers for tables call initialize_bins_for_tables () write ( * , '(A)' ) 'tempo_init() --- initialized bins for lookup tables' ! collision efficiencies between rain/snow and cloud water. call initialize_array_efrw () call compute_efrw () write ( * , '(A)' ) 'tempo_init() --- initialized collision efficiency data for rain collecting cloud water' call initialize_array_efsw () call compute_efsw () write ( * , '(A)' ) 'tempo_init() --- initialized collision efficiency data for snow collecting cloud water' ! drop evaporation call initialize_arrays_drop_evap () call compute_drop_evap () write ( * , '(A)' ) 'tempo_init() --- initialized drop evaporation data' ! cloud ice to snow and depositional growth ! consider explicitly passing arrays at init call initialize_arrays_qi_aut_qs () call qi_aut_qs () ! CCN activation table table_filename = tempo_table_cfgs % ccn_table_name call initialize_arrays_ccn ( table_size ) call read_table_ccn ( trim ( table_filename ), table_size ) write ( * , '(A)' ) 'tempo_init() --- initialized data for ccn lookup table' ! freeze water collection lookup table table_filename = tempo_table_cfgs % freezewater_table_name call initialize_arrays_freezewater ( table_size ) call read_table_freezewater ( trim ( table_filename ), table_size ) write ( * , '(A)' ) 'tempo_init() --- initialized data for frozen cloud water and rain lookup table' ! rain-snow collection lookup table table_filename = tempo_table_cfgs % qrqs_table_name call initialize_arrays_qr_acr_qs ( table_size ) call read_table_qr_acr_qs ( trim ( table_filename ), table_size ) write ( * , '(A)' ) 'tempo_init() --- initialized data for rain-snow collection lookup table' ! rain-graupel collection lookup table table_filename = tempo_table_cfgs % qrqg_table_name call initialize_arrays_qr_acr_qg ( table_size ) call read_table_qr_acr_qg ( trim ( table_filename ), table_size ) write ( * , '(A)' ) 'tempo_init() --- initialized data for rain-snow collection lookup table' ! Initialize various constants for computing radar reflectivity. ! xam_r = am_r ! xbm_r = bm_r ! xmu_r = mu_r ! xam_s = am_s ! xbm_s = bm_s ! xmu_s = mu_s ! xam_g = am_g(idx_bg1) ! xbm_g = bm_g ! xmu_g = mu_g endif end subroutine tempo_init subroutine tempo_build_tables ( build_tables_rank , build_tables_num_proc ) !! public procedure to build 3 lookup tables for tempo microphysics use module_mp_tempo_params , only : tempo_version , & initialize_graupel_vars , initialize_parameters , initialize_bins_for_tables integer , intent ( in ) :: build_tables_rank , build_tables_num_proc character ( len = 100 ) :: table_filename logical , parameter :: build_table_hail_flag = . true . ! MPI to speed up the table building process integer :: rank , num_proc ! set global variables rank and num_proc from MPI_Comm in build_tables program rank = build_tables_rank num_proc = build_tables_num_proc ! get tempo version from readme file call get_version ( tempo_version ) #ifdef build_tables_with_mpi write ( * , '(A,I4,A)' ) 'tempo_build_tables() --- building lookup tables with MPI and' , num_proc , ' process(es)' #else write ( * , '(A,I4,A)' ) 'tempo_build_tables() --- building lookup tables with' , num_proc , ' process' #endif ! hard-code hail aware = true to build lookup tables call initialize_graupel_vars ( build_table_hail_flag ) write ( * , '(A,L)' ) 'tempo_build_tables() --- initialized graupel variables using hail aware = ' , build_table_hail_flag ! set parameters that can depend on the host model call initialize_parameters () write ( * , '(A)' ) 'tempo_build_tables() --- initialized parameters' ! creates log-spaced bins of hydrometers for tables call initialize_bins_for_tables () write ( * , '(A)' ) 'tempo_build_tables() --- initialized bins for lookup tables' ! freeze water collection lookup table table_filename = tempo_table_cfgs % freezewater_table_name write ( * , '(2A)' ) 'tempo_build_tables() --- building table ' , trim ( table_filename ) call build_table_freezewater () if ( rank == 0 ) call write_table_freezewater ( trim ( table_filename )) ! rain-snow collection lookup table table_filename = tempo_table_cfgs % qrqs_table_name write ( * , '(2A)' ) 'tempo_build_tables() --- building table ' , trim ( table_filename ) call build_table_qr_acr_qs ( rank , num_proc ) if ( rank == 0 ) call write_table_qr_acr_qs ( trim ( table_filename )) ! rain-graupel collection lookup table table_filename = tempo_table_cfgs % qrqg_table_name write ( * , '(2A)' ) 'tempo_build_tables() --- building table ' , trim ( table_filename ) call build_table_qr_acr_qg ( rank , num_proc ) if ( rank == 0 ) call write_table_qr_acr_qg ( trim ( table_filename )) end subroutine tempo_build_tables subroutine build_table_freezewater () !! build lookup table data for frozen cloud and rain water use module_mp_tempo_params , only : initialize_arrays_freezewater real ( wp ) :: timing_start , timing_end call initialize_arrays_freezewater () call cpu_time ( timing_start ) call freezewater () call cpu_time ( timing_end ) write ( * , '(A,I5,A)' ) 'build_table_freezewater() --- time to build table: ' , int ( timing_end - timing_start ), ' s' end subroutine build_table_freezewater subroutine write_table_freezewater ( filename ) !! write data for frozen cloud water and rain to a file use module_mp_tempo_params , only : tpi_qrfz , tni_qrfz , tpg_qrfz , & tnr_qrfz , tpi_qcfz , tni_qcfz character ( len =* ), intent ( in ) :: filename integer :: mp_unit , istat logical :: fileexists inquire ( file = filename , exist = fileexists ) if ( fileexists ) call rename_file_if_exists ( filename ) mp_unit = 11 open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'new' , & iostat = istat , convert = 'big_endian' ) write ( mp_unit ) tpi_qrfz write ( mp_unit ) tni_qrfz write ( mp_unit ) tpg_qrfz write ( mp_unit ) tnr_qrfz write ( mp_unit ) tpi_qcfz write ( mp_unit ) tni_qcfz close ( unit = mp_unit ) end subroutine write_table_freezewater subroutine read_table_freezewater ( filename , table_size ) !! read lookup table for rain-graupel collection use module_mp_tempo_params , only : tpi_qrfz , tni_qrfz , & tpg_qrfz , tnr_qrfz , tpi_qcfz , tni_qcfz character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: table_size integer :: mp_unit , istat mp_unit = 11 call check_before_table_read ( filename , table_size ) open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'old' , & action = 'read' , iostat = istat , convert = 'big_endian' ) read ( mp_unit ) tpi_qrfz read ( mp_unit ) tni_qrfz read ( mp_unit ) tpg_qrfz read ( mp_unit ) tnr_qrfz read ( mp_unit ) tpi_qcfz read ( mp_unit ) tni_qcfz close ( unit = mp_unit ) end subroutine read_table_freezewater subroutine build_table_qr_acr_qs ( rank , num_proc ) !! build lookup table data for rain-snow collection use module_mp_tempo_params , only : table_dp , initialize_arrays_qr_acr_qs , & tcs_racs1 , tmr_racs1 , tcs_racs2 , tmr_racs2 , tcr_sacr1 , tms_sacr1 , & ! data arrays tcr_sacr2 , tms_sacr2 , tnr_racs1 , tnr_racs2 , tnr_sacr1 , tnr_sacr2 , & ! data arrays ntb_s , ntb_t , ntb_r1 , ntb_r ! dimensions integer , intent ( in ) :: rank , num_proc #ifdef build_tables_with_mpi integer :: ierror #endif real ( wp ) :: timing_start , timing_end integer :: start_idx , end_idx , local_dim_size , local_flat_size integer , allocatable , dimension (:) :: sendcounts , displacements real ( table_dp ), allocatable , dimension (:) :: tcs_racs1_flat , tmr_racs1_flat , & tcs_racs2_flat , tmr_racs2_flat , tcr_sacr1_flat , tms_sacr1_flat , & tcr_sacr2_flat , tms_sacr2_flat , tnr_racs1_flat , tnr_racs2_flat , & tnr_sacr1_flat , tnr_sacr2_flat real ( table_dp ), allocatable , dimension (:,:,:,:) :: tcs_racs1_ , tmr_racs1_ , & tcs_racs2_ , tmr_racs2_ , tcr_sacr1_ , tms_sacr1_ , tcr_sacr2_ , & tms_sacr2_ , tnr_racs1_ , tnr_racs2_ , tnr_sacr1_ , tnr_sacr2_ if ( rank == 0 ) then ! initialize lookup table arrays and flatten for MPI call initialize_arrays_qr_acr_qs () allocate ( tcs_racs1_flat ( size ( tcs_racs1 ))) allocate ( tmr_racs1_flat ( size ( tmr_racs1 ))) allocate ( tcs_racs2_flat ( size ( tcs_racs2 ))) allocate ( tmr_racs2_flat ( size ( tmr_racs2 ))) allocate ( tcr_sacr1_flat ( size ( tcr_sacr1 ))) allocate ( tms_sacr1_flat ( size ( tms_sacr1 ))) allocate ( tcr_sacr2_flat ( size ( tcr_sacr2 ))) allocate ( tms_sacr2_flat ( size ( tms_sacr2 ))) allocate ( tnr_racs1_flat ( size ( tnr_racs1 ))) allocate ( tnr_racs2_flat ( size ( tnr_racs2 ))) allocate ( tnr_sacr1_flat ( size ( tnr_sacr1 ))) allocate ( tnr_sacr2_flat ( size ( tnr_sacr2 ))) endif ! split over the last dimension, nrb_r call get_index_for_rank ( ntb_r , rank , num_proc , start_idx , end_idx ) local_dim_size = end_idx - start_idx + 1 local_flat_size = local_dim_size * ntb_s * ntb_t * ntb_r1 ! local arrays for MPI allocate ( tcs_racs1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tmr_racs1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tcs_racs2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tmr_racs2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tcr_sacr1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tms_sacr1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tcr_sacr2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tms_sacr2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tnr_racs1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tnr_racs2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tnr_sacr1_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( tnr_sacr2_ ( ntb_s , ntb_t , ntb_r1 , local_dim_size )) allocate ( sendcounts ( num_proc ), displacements ( num_proc )) if ( num_proc == 1 ) then sendcounts ( 1 ) = local_flat_size displacements ( 1 ) = 0 ! MPI displacements start at zero endif #ifdef build_tables_with_mpi call MPI_Allgather ( local_flat_size , 1 , MPI_INTEGER , sendcounts , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierror ) ! MPI displacements start at zero, i.e., start_idx-1 below call MPI_Allgather (( start_idx - 1 ) * ntb_s * ntb_t * ntb_r1 , 1 , MPI_INTEGER , displacements , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierror ) #endif #ifdef build_tables_with_mpi timing_start = MPI_Wtime () #else call cpu_time ( timing_start ) #endif call qr_acr_qs ( start_idx , end_idx , & tcs_racs1_ , tmr_racs1_ , tcs_racs2_ , tmr_racs2_ , & tcr_sacr1_ , tms_sacr1_ , tcr_sacr2_ , tms_sacr2_ , & tnr_racs1_ , tnr_racs2_ , tnr_sacr1_ , tnr_sacr2_ ) #ifdef build_tables_with_mpi timing_end = MPI_Wtime () #else call cpu_time ( timing_end ) #endif if ( rank == 0 ) write ( * , '(A,I5,A)' ) 'build_table_qr_acr_qs() --- time to build table: ' , int ( timing_end - timing_start ), ' s' #ifdef build_tables_with_mpi call MPI_Barrier ( MPI_COMM_WORLD , ierror ) call gather ( reshape ( tcs_racs1_ , ( / local_flat_size / )), tcs_racs1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tmr_racs1_ , ( / local_flat_size / )), tmr_racs1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tcs_racs2_ , ( / local_flat_size / )), tcs_racs2_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tmr_racs2_ , ( / local_flat_size / )), tmr_racs2_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tcr_sacr1_ , ( / local_flat_size / )), tcr_sacr1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tms_sacr1_ , ( / local_flat_size / )), tms_sacr1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tcr_sacr2_ , ( / local_flat_size / )), tcr_sacr2_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tms_sacr2_ , ( / local_flat_size / )), tms_sacr2_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_racs1_ , ( / local_flat_size / )), tnr_racs1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_racs2_ , ( / local_flat_size / )), tnr_racs2_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_sacr1_ , ( / local_flat_size / )), tnr_sacr1_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_sacr2_ , ( / local_flat_size / )), tnr_sacr2_flat , sendcounts , displacements , ierror ) if ( rank == 0 ) then tcs_racs1 = reshape ( tcs_racs1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tmr_racs1 = reshape ( tmr_racs1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tcs_racs2 = reshape ( tcs_racs2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tmr_racs2 = reshape ( tmr_racs2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tcr_sacr1 = reshape ( tcr_sacr1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tms_sacr1 = reshape ( tms_sacr1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tcr_sacr2 = reshape ( tcr_sacr2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tms_sacr2 = reshape ( tms_sacr2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tnr_racs1 = reshape ( tnr_racs1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tnr_racs2 = reshape ( tnr_racs2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tnr_sacr1 = reshape ( tnr_sacr1_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) tnr_sacr2 = reshape ( tnr_sacr2_flat , ( / ntb_s , ntb_t , ntb_r1 , ntb_r / )) endif #else tcs_racs1 = tcs_racs1_ tmr_racs1 = tmr_racs1_ tcs_racs2 = tcs_racs2_ tmr_racs2 = tmr_racs2_ tcr_sacr1 = tcr_sacr1_ tms_sacr1 = tms_sacr1_ tcr_sacr2 = tcr_sacr2_ tms_sacr2 = tms_sacr2_ tnr_racs1 = tnr_racs1_ tnr_racs2 = tnr_racs2_ tnr_sacr1 = tnr_sacr1_ tnr_sacr2 = tnr_sacr2_ #endif #if build_tables_with_mpi call MPI_Barrier ( MPI_COMM_WORLD , ierror ) #endif end subroutine build_table_qr_acr_qs subroutine write_table_qr_acr_qs ( filename ) !! write data for rain-snow collection to a file use module_mp_tempo_params , only : tcs_racs1 , tmr_racs1 , tcs_racs2 , & tmr_racs2 , tcr_sacr1 , tms_sacr1 , tcr_sacr2 , tms_sacr2 , tnr_racs1 , & tnr_racs2 , tnr_sacr1 , tnr_sacr2 character ( len =* ), intent ( in ) :: filename integer :: mp_unit , istat logical :: fileexists inquire ( file = filename , exist = fileexists ) if ( fileexists ) call rename_file_if_exists ( filename ) mp_unit = 11 open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'new' , & iostat = istat , convert = 'big_endian' ) write ( mp_unit ) tcs_racs1 write ( mp_unit ) tmr_racs1 write ( mp_unit ) tcs_racs2 write ( mp_unit ) tmr_racs2 write ( mp_unit ) tcr_sacr1 write ( mp_unit ) tms_sacr1 write ( mp_unit ) tcr_sacr2 write ( mp_unit ) tms_sacr2 write ( mp_unit ) tnr_racs1 write ( mp_unit ) tnr_racs2 write ( mp_unit ) tnr_sacr1 write ( mp_unit ) tnr_sacr2 close ( unit = mp_unit ) end subroutine write_table_qr_acr_qs subroutine read_table_qr_acr_qs ( filename , table_size ) !! read lookup table for rain-snow collection use module_mp_tempo_params , only : tcs_racs1 , tmr_racs1 , & tcs_racs2 , tmr_racs2 , tcr_sacr1 , tms_sacr1 , tcr_sacr2 , & tms_sacr2 , tnr_racs1 , tnr_racs2 , tnr_sacr1 , tnr_sacr2 character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: table_size integer :: mp_unit , istat mp_unit = 11 call check_before_table_read ( filename , table_size ) open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'old' , & action = 'read' , iostat = istat , convert = 'big_endian' ) read ( mp_unit ) tcs_racs1 read ( mp_unit ) tmr_racs1 read ( mp_unit ) tcs_racs2 read ( mp_unit ) tmr_racs2 read ( mp_unit ) tcr_sacr1 read ( mp_unit ) tms_sacr1 read ( mp_unit ) tcr_sacr2 read ( mp_unit ) tms_sacr2 read ( mp_unit ) tnr_racs1 read ( mp_unit ) tnr_racs2 read ( mp_unit ) tnr_sacr1 read ( mp_unit ) tnr_sacr2 close ( unit = mp_unit ) end subroutine read_table_qr_acr_qs subroutine build_table_qr_acr_qg ( rank , num_proc ) !! build lookup table data for rain-graupel collection use module_mp_tempo_params , only : table_dp , initialize_arrays_qr_acr_qg , & tcg_racg , tmr_racg , tcr_gacr , tnr_racg , tnr_gacr , & ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r integer , intent ( in ) :: rank , num_proc #ifdef build_tables_with_mpi integer :: ierror #endif real ( wp ) :: timing_start , timing_end integer :: start_idx , end_idx , local_dim_size , local_flat_size integer , allocatable , dimension (:) :: sendcounts , displacements real ( table_dp ), allocatable , dimension (:) :: tcg_racg_flat , tmr_racg_flat , & tcr_gacr_flat , tnr_racg_flat , tnr_gacr_flat real ( table_dp ), allocatable , dimension (:,:,:,:,:) :: tcg_racg_ , & tmr_racg_ , tcr_gacr_ , tnr_racg_ , tnr_gacr_ if ( rank == 0 ) then ! initialize lookup table arrays and flatten for MPI call initialize_arrays_qr_acr_qg () allocate ( tcg_racg_flat ( size ( tcg_racg ))) allocate ( tmr_racg_flat ( size ( tmr_racg ))) allocate ( tcr_gacr_flat ( size ( tcr_gacr ))) allocate ( tnr_racg_flat ( size ( tnr_racg ))) allocate ( tnr_gacr_flat ( size ( tnr_gacr ))) endif ! split over the last dimension, nrb_r call get_index_for_rank ( ntb_r , rank , num_proc , start_idx , end_idx ) local_dim_size = end_idx - start_idx + 1 local_flat_size = local_dim_size * ntb_g1 * ntb_g * nrhg * ntb_r1 ! local arrays for MPI allocate ( tcg_racg_ ( ntb_g1 , ntb_g , nrhg , ntb_r1 , local_dim_size )) allocate ( tmr_racg_ ( ntb_g1 , ntb_g , nrhg , ntb_r1 , local_dim_size )) allocate ( tcr_gacr_ ( ntb_g1 , ntb_g , nrhg , ntb_r1 , local_dim_size )) allocate ( tnr_racg_ ( ntb_g1 , ntb_g , nrhg , ntb_r1 , local_dim_size )) allocate ( tnr_gacr_ ( ntb_g1 , ntb_g , nrhg , ntb_r1 , local_dim_size )) allocate ( sendcounts ( num_proc ), displacements ( num_proc )) if ( num_proc == 1 ) then sendcounts ( 1 ) = local_flat_size displacements ( 1 ) = 0 ! MPI displacements start at zero endif #ifdef build_tables_with_mpi call MPI_Allgather ( local_flat_size , 1 , MPI_INTEGER , sendcounts , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierror ) ! MPI displacements start at zero, i.e., start_idx-1 below call MPI_Allgather (( start_idx - 1 ) * ntb_g1 * ntb_g * nrhg * ntb_r1 , 1 , MPI_INTEGER , displacements , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierror ) #endif #ifdef build_tables_with_mpi timing_start = MPI_Wtime () #else call cpu_time ( timing_start ) #endif call qr_acr_qg ( start_idx , end_idx , & tcg_racg_ , tmr_racg_ , tcr_gacr_ , tnr_racg_ , tnr_gacr_ ) #ifdef build_tables_with_mpi timing_end = MPI_Wtime () #else call cpu_time ( timing_end ) #endif if ( rank == 0 ) write ( * , '(A,I5,A)' ) 'build_table_qr_acr_qg() --- time to build table: ' , int ( timing_end - timing_start ), ' s' #ifdef build_tables_with_mpi call MPI_Barrier ( MPI_COMM_WORLD , ierror ) call gather ( reshape ( tcg_racg_ , ( / local_flat_size / )), tcg_racg_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tmr_racg_ , ( / local_flat_size / )), tmr_racg_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tcr_gacr_ , ( / local_flat_size / )), tcr_gacr_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_racg_ , ( / local_flat_size / )), tnr_racg_flat , sendcounts , displacements , ierror ) call gather ( reshape ( tnr_gacr_ , ( / local_flat_size / )), tnr_gacr_flat , sendcounts , displacements , ierror ) if ( rank == 0 ) then tcg_racg = reshape ( tcg_racg_flat , ( / ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r / )) tmr_racg = reshape ( tmr_racg_flat , ( / ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r / )) tcr_gacr = reshape ( tcr_gacr_flat , ( / ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r / )) tnr_racg = reshape ( tnr_racg_flat , ( / ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r / )) tnr_gacr = reshape ( tnr_gacr_flat , ( / ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r / )) endif #else tcg_racg = tcg_racg_ tmr_racg = tmr_racg_ tcr_gacr = tcr_gacr_ tnr_racg = tnr_racg_ tnr_gacr = tnr_gacr_ #endif #if build_tables_with_mpi call MPI_Barrier ( MPI_COMM_WORLD , ierror ) #endif end subroutine build_table_qr_acr_qg subroutine write_table_qr_acr_qg ( filename ) !! write data for rain-graupel collection to a file use module_mp_tempo_params , only : tcg_racg , tmr_racg , & tcr_gacr , tnr_racg , tnr_gacr character ( len =* ), intent ( in ) :: filename integer :: mp_unit , istat logical :: fileexists inquire ( file = filename , exist = fileexists ) if ( fileexists ) call rename_file_if_exists ( filename ) mp_unit = 11 open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'new' , & iostat = istat , convert = 'big_endian' ) write ( mp_unit ) tcg_racg write ( mp_unit ) tmr_racg write ( mp_unit ) tcr_gacr write ( mp_unit ) tnr_racg write ( mp_unit ) tnr_gacr close ( unit = mp_unit ) end subroutine write_table_qr_acr_qg subroutine read_table_qr_acr_qg ( filename , table_size ) !! read lookup table for rain-graupel collection use module_mp_tempo_params , only : tcg_racg , tmr_racg , & tcr_gacr , tnr_racg , tnr_gacr character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: table_size integer :: mp_unit , istat mp_unit = 11 call check_before_table_read ( filename , table_size ) open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'old' , & action = 'read' , iostat = istat , convert = 'big_endian' ) read ( mp_unit ) tcg_racg read ( mp_unit ) tmr_racg read ( mp_unit ) tcr_gacr read ( mp_unit ) tnr_racg read ( mp_unit ) tnr_gacr close ( unit = mp_unit ) end subroutine read_table_qr_acr_qg #ifdef build_tables_with_mpi subroutine gather ( local_flat , global_flat , sendcounts , displacements , ierror ) !! wrapper to simplify MPI_Gatherv use module_mp_tempo_params , only : table_dp real ( table_dp ), dimension (:), intent ( in ) :: local_flat real ( table_dp ), dimension (:), intent ( out ) :: global_flat integer , intent ( inout ) :: ierror integer , dimension (:), intent ( in ) :: sendcounts , displacements integer :: local_size local_size = size ( local_flat ) call MPI_Gatherv ( local_flat , local_size , MPI_DOUBLE_PRECISION , & global_flat , sendcounts , displacements , & MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) end subroutine gather #endif subroutine get_index_for_rank ( idx , rank , num_proc , start_idx , end_idx ) !! returns start and end index values for an array dimension !! of size idx distributed over num_procs integer , intent ( in ) :: idx , rank , num_proc integer , intent ( out ) :: start_idx , end_idx integer :: values_per_proc if ( num_proc > idx ) then write ( * , '(A,I4,A,I4)' ) 'num_proc' , num_proc , 'cannot be larger than idx' , idx error stop '--- reduce the number of processes' endif values_per_proc = idx / num_proc if ( rank < mod ( idx , num_proc )) then values_per_proc = values_per_proc + 1 endif if ( rank < mod ( idx , num_proc )) then start_idx = rank * values_per_proc + 1 end_idx = ( rank + 1 ) * values_per_proc else start_idx = mod ( idx , num_proc ) + rank * values_per_proc + 1 end_idx = mod ( idx , num_proc ) + ( rank + 1 ) * values_per_proc endif end subroutine get_index_for_rank subroutine get_version ( version ) !! returns the tempo version string from the README.md file or returns empty string if not found character ( len =* ), intent ( inout ) :: version character ( len = 100 ) :: first_line , filename integer :: io_unit logical :: fileexists filename = 'README.md' inquire ( file = trim ( filename ), exist = fileexists ) if (. not . fileexists ) then version = '' write ( * , '(A)' ) 'Unable to determine TEMPO Microphysics Version' return endif open ( newunit = io_unit , file = filename , status = 'old' , action = 'read' ) read ( io_unit , '(A)' ) first_line close ( io_unit ) ! format is tempo-vX.X.X version = trim ( first_line ( 8 :)) write ( * , '(A)' ) 'TEMPO Microphysics Version: ' // trim ( version ) end subroutine get_version subroutine read_table_ccn ( filename , table_size ) !! read static file containing CCN activation of aerosols; !! The data were created from a parcel model by Feingold & Heymsfield !! with further changes by Eidhammer and Kriedenweis use module_mp_tempo_params , only : tnccn_act character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: table_size integer :: mp_unit , istat call check_before_table_read ( filename = filename , table_size = table_size ) mp_unit = 11 open ( unit = mp_unit , file = filename , form = 'unformatted' , status = 'old' , & action = 'read' , iostat = istat , convert = 'big_endian' ) read ( mp_unit ) tnccn_act close ( unit = mp_unit ) end subroutine read_table_ccn subroutine check_before_table_read ( filename , table_size ) !! checks that lookup tables exist and are the correct size before attempting to read them character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: table_size logical :: fileexists integer :: filesize character ( len = 100 ) :: int_to_str1 , int_to_str2 inquire ( file = filename , size = filesize , exist = fileexists ) if (. not . fileexists ) then write ( * , '(3A)' ) 'tempo_init() --- *** FATAL *** file \"' , filename , & '\" was not found in this directory.' write ( * , '(A)' ) '' write ( * , '(A)' ) 'How to fix issues with tables (datasets stored in files):' write ( * , '(3A)' ) '   (1) The table ' , trim ( tempo_table_cfgs % ccn_table_name ), & ' is located in the TEMPO/tables/ directory. Copy this file to the directory where the model executable is located.' write ( * , '(8A)' ) '   (2) Three tables:' , trim ( tempo_table_cfgs % qrqs_table_name ), ', ' , trim ( tempo_table_cfgs % qrqg_table_name ), ', and ' , & trim ( tempo_table_cfgs % freezewater_table_name ), & ' can be build by compiling and running the executable \"build_tables\" in the main TEMPO directory. ' , & 'Then copy the file to the directory where the model executable is located.' write ( * , '(A)' ) '   (3) Ask the developers for tables. They are willing to share.' write ( * , '(A)' ) '' error stop '--- file \"' // filename // '\" needed for TEMPO microphysics was not found.' endif if ( filesize /= table_size ) then write ( int_to_str1 , '(I0)' ) filesize write ( int_to_str2 , '(I0)' ) table_size write ( * , '(7A)' ) 'tempo_init() --- *** FATAL *** file \"' , filename , '\" has a size of ' , & trim ( int_to_str1 ), ' bytes but the array allocated to hold the data expects a file size of ' , & trim ( int_to_str2 ), ' bytes.' write ( * , '(A)' ) '' write ( * , '(A)' ) 'How to fix issues with tables (datasets stored in files):' write ( * , '(3A)' ) '   (1) The table ' , trim ( tempo_table_cfgs % ccn_table_name ), & ' is located in the TEMPO/tables/ directory. Copy this file to the directory where the model executable is located.' write ( * , '(8A)' ) '   (2) Three tables: ' , trim ( tempo_table_cfgs % qrqs_table_name ), ', ' , trim ( tempo_table_cfgs % qrqg_table_name ), ', and ' , & trim ( tempo_table_cfgs % freezewater_table_name ), & ' can be build by compiling and running the executable \"build_tables\" in the main TEMPO directory. ' , & 'Then copy the file to the directory where the model executable is located.' write ( * , '(A)' ) '   (3) Ask the developers for tables. They are willing to share.' write ( * , '(A)' ) '' error stop '--- size of file \"' // filename // '\" needed for TEMPO microphysics is inconsistent with expected size.' endif end subroutine check_before_table_read subroutine rename_file_if_exists ( oldfilename ) !! rename a lookup table if attempting to write to that file and it already exists character ( len =* ), intent ( in ) :: oldfilename character ( len = 100 ) :: newfilename character ( 8 ) :: date character ( 6 ) :: time integer :: renamestat character ( len = 20 ) :: fileappend call date_and_time ( date , time ) fileappend = '_old_' // trim ( date ) // '_' // trim ( time ) newfilename = trim ( oldfilename // trim ( fileappend )) renamestat = rename ( oldfilename , newfilename ) if ( renamestat /= 0 ) then write ( * , '(3A)' ) 'rename_file_if_exists() --- *** FATAL *** unable to rename existing table file \"' , & oldfilename , '\" to \"' , newfilename , '\"' error stop '--- file rename failed.' else write ( * , '(5A)' ) 'rename_file_if_exists() --- existing table file \"' , oldfilename , & '\" has been renamed to \"' , newfilename , '\"' endif end subroutine rename_file_if_exists subroutine compute_efrw () !! collision efficiency for rain collecting cloud water from Beard and Grover (1974) !! if a/A < 0.25, otherwise uses polynomials to get close match of Pruppacher & Klett Fig. 14-9 use module_mp_tempo_params , only : nbc , nbr , dc , dr , t_efrw , rho_w , pi real ( dp ) :: vtr , stokes , reynolds , ef_rw real ( dp ) :: p , yc0 , f , g , h , z , k0 , x integer :: i , j do j = 1 , nbc do i = 1 , nbr ef_rw = 0.0_dp p = dc ( j ) / dr ( i ) if ( dr ( i ) < 5 0.e-6_dp . or . dc ( j ) < 3.e-6_dp ) then t_efrw ( i , j ) = 0.0_dp elseif ( p > 0.25_dp ) then x = dc ( j ) * 1.e6_dp if ( dr ( i ) < 7 5.e-6_dp ) then ef_rw = 0.026794_dp * x - 0.20604_dp elseif ( dr ( i ) < 12 5.e-6_dp ) then ef_rw = - 0.00066842_dp * x * x + 0.061542_dp * x - 0.37089_dp elseif ( dr ( i ) < 17 5.e-6_dp ) then ef_rw = 4.091e-06_dp * x * x * x * x - 0.00030908_dp * x * x * x + & 0.0066237_dp * x * x - 0.0013687_dp * x - 0.073022_dp elseif ( dr ( i ) < 25 0.e-6_dp ) then ef_rw = 9.6719e-5_dp * x * x * x - 0.0068901_dp * x * x + 0.17305_dp * x - 0.65988_dp elseif ( dr ( i ) < 35 0.e-6_dp ) then ef_rw = 9.0488e-5_dp * x * x * x - 0.006585_dp * x * x + 0.16606_dp * x - 0.56125_dp else ef_rw = 0.00010721_dp * x * x * x - 0.0072962_dp * x * x + 0.1704_dp * x - 0.46929_dp endif else vtr = - 0.1021_dp + 4.932e3_dp * dr ( i ) - 0.9551e6_dp * dr ( i ) * dr ( i ) + 0.07934e9_dp * dr ( i ) * dr ( i ) * dr ( i ) & - 0.002362e12_dp * dr ( i ) * dr ( i ) * dr ( i ) * dr ( i ) stokes = dc ( j ) * dc ( j ) * vtr * rho_w / ( 9._dp * 1.718e-5_dp * dr ( i )) reynolds = 9._dp * stokes / ( p * p * rho_w ) f = log ( reynolds ) g = - 0.1007_dp - 0.358_dp * f + 0.0261_dp * f * f k0 = exp ( g ) z = log ( stokes / ( k0 + 1.e-15_dp )) H = 0.1465_dp + 1.302_dp * z - 0.607_dp * z * z + 0.293_dp * z * z * z yc0 = 2.0_dp / pi * atan ( h ) ef_rw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) endif t_efrw ( i , j ) = max ( 0.0_dp , min ( ef_rw , 0.95_dp )) enddo enddo end subroutine compute_efrw subroutine compute_efsw () !! collision efficiency for snow collecting cloud water from Wang and Ji (2000) except !! equate melted snow diameter to their \"effective collision cross-section.\" use module_mp_tempo_params , only : wp , sp , dp , & nbc , dc , av_s , bv_s , ds , nbs , am_s , bm_s , am_r , obmr , fv_s , & t_efsw , d0s , rho_w , pi real ( dp ) :: ds_m , vts , vtc , stokes , reynolds , ef_sw real ( dp ) :: p , yc0 , f , g , h , z , k0 integer :: i , j do j = 1 , nbc vtc = 1.19e4_dp * ( 1.0e4_dp * dc ( j ) * dc ( j ) * 0.25_dp ) do i = 1 , nbs vts = av_s * ds ( i ) ** bv_s * exp ( real ( - fv_s * ds ( i ), kind = dp )) - vtc ds_m = ( am_s * ds ( i ) ** bm_s / am_r ) ** obmr p = dc ( j ) / ds_m if ( p > 0.25_dp . or . ds ( i ) < d0s . or . dc ( j ) < 6.e-6_dp . or . vts < 1.e-3_dp ) then t_efsw ( i , j ) = 0.0_dp else stokes = dc ( j ) * dc ( j ) * vts * rho_w / ( 9. * 1.718e-5_dp * ds_m ) reynolds = 9._dp * stokes / ( p * p * rho_w ) f = log ( reynolds ) g = - 0.1007_dp - 0.358_dp * f + 0.0261_dp * f * f k0 = exp ( g ) z = log ( stokes / ( k0 + 1.e-15_dp )) h = 0.1465_dp + 1.302_dp * z - 0.607_dp * z * z + 0.293_dp * z * z * z yc0 = 2.0_dp / pi * atan ( h ) ef_sw = ( yc0 + p ) * ( yc0 + p ) / (( 1. + p ) * ( 1. + p )) t_efsw ( i , j ) = max ( 0.0_dp , min ( ef_sw , 0.95_dp )) endif enddo enddo end subroutine compute_efsw subroutine compute_drop_evap () !! calculates droplet evaporation data use module_mp_tempo_params , only : wp , sp , dp , & nbc , am_r , dc , bm_r , nu_c_scale , nu_c_max , nu_c_min , & t_nc , ntb_c , cce , ccg , ocg1 , r_c , obmr , dtc , & tpc_wev , tnc_wev integer :: i , j , k , n real ( dp ), dimension ( nbc ) :: n_c , massc real ( dp ) :: summ , summ2 , lamc , n0_c integer :: nu_c do n = 1 , nbc massc ( n ) = am_r * dc ( n ) ** bm_r enddo do k = 1 , nbc nu_c = get_nuc ( t_nc ( k )) do j = 1 , ntb_c lamc = ( t_nc ( k ) * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / r_c ( j )) ** obmr n0_c = t_nc ( k ) * ocg1 ( nu_c ) * lamc ** cce ( 1 , nu_c ) do i = 1 , nbc n_c ( i ) = n0_c * dc ( i ) ** nu_c * exp ( - lamc * dc ( i )) * dtc ( i ) summ = 0._dp summ2 = 0._dp do n = 1 , i summ = summ + massc ( n ) * n_c ( n ) summ2 = summ2 + n_c ( n ) enddo tpc_wev ( i , j , k ) = summ tnc_wev ( i , j , k ) = summ2 enddo enddo enddo end subroutine compute_drop_evap subroutine qr_acr_qs ( local_start , local_end , & ltcs_racs1 , ltmr_racs1 , ltcs_racs2 , ltmr_racs2 , ltcr_sacr1 , ltms_sacr1 , & ltcr_sacr2 , ltms_sacr2 , ltnr_racs1 , ltnr_racs2 , ltnr_sacr1 , ltnr_sacr2 ) !! calculate rain collecting snow (and inverse) use module_mp_tempo_params , only : table_dp , & nbr , nbs , dr , av_s , bv_s , ds , fv_s , & ntb_r , ntb_r1 , n0r_exp , am_r , cre , crg , ore1 , r_r , & org1 , org2 , obmr , mu_r , dtr , ntb_t , ntb_s , r_s , & sa , sb , tc , bm_s , mu_s , lam0 , lam1 , kap0 , kap1 , dts , & bm_r , am_s , pi , ef_rs , table_dp integer , intent ( in ) :: local_start , local_end real ( table_dp ), intent ( out ), dimension (:,:,:,:) :: & ltcs_racs1 , ltmr_racs1 , ltcs_racs2 , ltmr_racs2 , & ltcr_sacr1 , ltms_sacr1 , ltcr_sacr2 , ltms_sacr2 , & ltnr_racs1 , ltnr_racs2 , ltnr_sacr1 , ltnr_sacr2 integer :: i , j , k , m , n , n2 real ( dp ), dimension ( nbr ) :: vr , d1 , n_r real ( dp ), dimension ( nbs ) :: vs , n_s real ( dp ) :: m0 , m2 , m3 , mrat , om3 real ( dp ) :: n0_r , lam_exp , lamr , slam1 , slam2 real ( dp ) :: dvs , dvr , masss , massr real ( dp ) :: t1 , t2 , t3 , t4 , z1 , z2 , z3 , z4 real ( dp ) :: y1 , y2 , y3 , y4 do n2 = 1 , nbr vr ( n2 ) = - 0.1021_dp + 4.932e3_dp * dr ( n2 ) - 0.9551e6_dp * dr ( n2 ) * dr ( n2 ) & + 0.07934e9_dp * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) & - 0.002362e12_dp * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) d1 ( n2 ) = ( vr ( n2 ) / av_s ) ** ( 1._dp / bv_s ) enddo do n = 1 , nbs vs ( n ) = 1.5_dp * av_s * ds ( n ) ** bv_s * exp ( real ( - fv_s * ds ( n ), kind = dp )) enddo do m = local_start , local_end do k = 1 , ntb_r1 lam_exp = ( n0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr n0_r = n0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr n_r ( n2 ) = n0_r * dr ( n2 ) ** mu_r * exp ( - lamr * dr ( n2 )) * dtr ( n2 ) enddo do j = 1 , ntb_t do i = 1 , ntb_s call snow_moments ( rs = r_s ( i ), tc = tc ( j ), smob = m2 , smoc = m3 ) om3 = 1._wp / m3 mrat = m2 * ( m2 * om3 ) * ( m2 * om3 ) * ( m2 * om3 ) m0 = ( m2 * om3 ) ** mu_s slam1 = m2 * om3 * lam0 slam2 = m2 * om3 * lam1 do n = 1 , nbs n_s ( n ) = mrat * ( kap0 * exp ( - slam1 * ds ( n )) & + kap1 * m0 * ds ( n ) ** mu_s * exp ( - slam2 * ds ( n ))) * dts ( n ) enddo t1 = 0._dp t2 = 0._dp t3 = 0._dp t4 = 0._dp z1 = 0._dp z2 = 0._dp z3 = 0._dp z4 = 0._dp y1 = 0._dp y2 = 0._dp y3 = 0._dp y4 = 0._dp do n2 = 1 , nbr massr = am_r * dr ( n2 ) ** bm_r do n = 1 , nbs masss = am_s * ds ( n ) ** bm_s dvs = 0.5_dp * (( vr ( n2 ) - vs ( n )) + abs ( vr ( n2 ) - vs ( n ))) dvr = 0.5_dp * (( vs ( n ) - vr ( n2 )) + abs ( vs ( n ) - vr ( n2 ))) if ( massr > 1.5 * masss ) then t1 = t1 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * masss * n_s ( n ) * n_r ( n2 ) z1 = z1 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * massr * n_s ( n ) * n_r ( n2 ) y1 = y1 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * n_s ( n ) * n_r ( n2 ) else t3 = t3 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * masss * n_s ( n ) * n_r ( n2 ) z3 = z3 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * massr * n_s ( n ) * n_r ( n2 ) y3 = y3 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvs * n_s ( n ) * n_r ( n2 ) endif if ( massr > 1.5_dp * masss ) then t2 = t2 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * massr * n_s ( n ) * n_r ( n2 ) y2 = y2 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * n_s ( n ) * n_r ( n2 ) z2 = z2 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * masss * n_s ( n ) * n_r ( n2 ) else t4 = t4 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * massr * n_s ( n ) * n_r ( n2 ) y4 = y4 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * n_s ( n ) * n_r ( n2 ) z4 = z4 + pi * . 25_dp * ef_rs * ( ds ( n ) + dr ( n2 )) * ( ds ( n ) + dr ( n2 )) & * dvr * masss * n_s ( n ) * n_r ( n2 ) endif enddo enddo ltcs_racs1 ( i , j , k , m - local_start + 1 ) = t1 ltmr_racs1 ( i , j , k , m - local_start + 1 ) = min ( z1 , real ( r_r ( m ), kind = dp )) ltcs_racs2 ( i , j , k , m - local_start + 1 ) = t3 ltmr_racs2 ( i , j , k , m - local_start + 1 ) = z3 ltcr_sacr1 ( i , j , k , m - local_start + 1 ) = t2 ltms_sacr1 ( i , j , k , m - local_start + 1 ) = z2 ltcr_sacr2 ( i , j , k , m - local_start + 1 ) = t4 ltms_sacr2 ( i , j , k , m - local_start + 1 ) = z4 ltnr_racs1 ( i , j , k , m - local_start + 1 ) = y1 ltnr_racs2 ( i , j , k , m - local_start + 1 ) = y3 ltnr_sacr1 ( i , j , k , m - local_start + 1 ) = y2 ltnr_sacr2 ( i , j , k , m - local_start + 1 ) = y4 enddo enddo enddo enddo end subroutine qr_acr_qs subroutine qr_acr_qg ( local_start , local_end , & ltcg_racg , ltmr_racg , ltcr_gacr , ltnr_racg , ltnr_gacr ) !! Rain collecting graupel (and inverse).  Explicit CE integration. use module_mp_tempo_params , only : table_dp , nrhg , nbg , nbr , dr , & av_g , dg , bv_g , ntb_r , ntb_r1 , & n0r_exp , am_r , cre , crg , r_r , ore1 , org1 , org2 , & obmr , mu_r , dtr , ntb_g , ntb_g1 , n0g_exp , am_g , cge , cgg , & r_g , oge1 , ogg1 , ogg2 , obmg , mu_g , dtg , bm_r , bm_g , pi , ef_rg integer , intent ( in ) :: local_start , local_end real ( table_dp ), intent ( out ), dimension (:,:,:,:,:) :: & ltcg_racg , ltmr_racg , ltcr_gacr , ltnr_racg , ltnr_gacr integer :: i , j , k , m , n , n2 , n3 real ( dp ), dimension ( nbg ) :: n_g real ( dp ), dimension ( nbg , nrhg ) :: vg real ( dp ), dimension ( nbr ) :: vr , n_r real ( dp ) :: n0_r , n0_g , lam_exp , lamg , lamr real ( dp ) :: massg , massr , dvg , dvr , t1 , t2 , z1 , z2 , y1 , y2 do n2 = 1 , nbr vr ( n2 ) = - 0.1021_dp + 4.932e3_dp * dr ( n2 ) - 0.9551e6_dp * dr ( n2 ) * dr ( n2 ) & + 0.07934e9_dp * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) & - 0.002362e12_dp * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) * dr ( n2 ) enddo do n3 = 1 , nrhg do n = 1 , nbg vg ( n , n3 ) = av_g ( n3 ) * dg ( n ) ** bv_g ( n3 ) enddo enddo do m = local_start , local_end do k = 1 , ntb_r1 lam_exp = ( n0r_exp ( k ) * am_r * crg ( 1 ) / r_r ( m )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr n0_r = n0r_exp ( k ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) do n2 = 1 , nbr n_r ( n2 ) = n0_r * dr ( n2 ) ** mu_r * exp ( - lamr * dr ( n2 )) * dtr ( n2 ) enddo do n3 = 1 , nrhg do j = 1 , ntb_g do i = 1 , ntb_g1 lam_exp = ( n0g_exp ( i ) * am_g ( n3 ) * cgg ( 1 , 1 ) / r_g ( j )) ** oge1 lamg = lam_exp * ( cgg ( 3 , 1 ) * ogg2 * ogg1 ) ** obmg n0_g = n0g_exp ( i ) / ( cgg ( 2 , 1 ) * lam_exp ) * lamg ** cge ( 2 , 1 ) do n = 1 , nbg n_g ( n ) = n0_g * dg ( n ) ** mu_g * exp ( - lamg * dg ( n )) * dtg ( n ) enddo t1 = 0._dp t2 = 0._dp z1 = 0._dp z2 = 0._dp y1 = 0._dp y2 = 0._dp do n2 = 1 , nbr massr = am_r * dr ( n2 ) ** bm_r do n = 1 , nbg massg = am_g ( n3 ) * dg ( n ) ** bm_g dvg = 0.5_dp * (( vr ( n2 ) - vg ( n , n3 )) + abs ( vr ( n2 ) - vg ( n , n3 ))) dvr = 0.5_dp * (( vg ( n , n3 ) - vr ( n2 )) + abs ( vg ( n , n3 ) - vr ( n2 ))) t1 = t1 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvg * massg * n_g ( n ) * n_r ( n2 ) z1 = z1 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvg * massr * n_g ( n ) * n_r ( n2 ) y1 = y1 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvg * n_g ( n ) * n_r ( n2 ) t2 = t2 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvr * massr * n_g ( n ) * n_r ( n2 ) y2 = y2 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvr * n_g ( n ) * n_r ( n2 ) z2 = z2 + pi * . 25_wp * ef_rg * ( dg ( n ) + dr ( n2 )) * ( dg ( n ) + dr ( n2 )) & * dvr * massg * n_g ( n ) * n_r ( n2 ) enddo enddo ltcg_racg ( i , j , n3 , k , m - local_start + 1 ) = t1 ltmr_racg ( i , j , n3 , k , m - local_start + 1 ) = min ( z1 , real ( r_r ( m ), kind = dp )) ltcr_gacr ( i , j , n3 , k , m - local_start + 1 ) = t2 ltnr_racg ( i , j , n3 , k , m - local_start + 1 ) = y1 ltnr_gacr ( i , j , n3 , k , m - local_start + 1 ) = y2 enddo enddo enddo enddo enddo end subroutine qr_acr_qg subroutine freezewater () !! freeze water from  Bigg (1953), calculating the probability of drops of a particular volume freezing use module_mp_tempo_params , only : nbc , nbr , rho_w , & am_r , dr , dtr , bm_r , dc , dtc , ntb_in , ntb_r1 , ntb_r , nt_in , & n0r_exp , cre , crg , r_r , ore1 , org2 , org1 , obmr , mu_r , & nu_c_scale , xm0g , t_nc , cce , ccg , ocg1 , r_c , ntb_c , & tpi_qrfz , tni_qrfz , tpg_qrfz , tnr_qrfz , tpi_qcfz , tni_qcfz ! data arrays integer :: i , j , k , m , n , n2 real ( dp ) :: n_r , n_c real ( dp ), dimension ( nbr ) :: massr real ( dp ), dimension ( nbc ) :: massc real ( dp ) :: sum1 , sum2 , sumn1 , sumn2 , & prob , vol , texp , orho_w , & lam_exp , lamr , N0_r , lamc , n0_c integer :: nu_c real ( wp ) :: t_adjust orho_w = 1._wp / rho_w do n2 = 1 , nbr massr ( n2 ) = am_r * dr ( n2 ) ** bm_r enddo do n = 1 , nbc massc ( n ) = am_r * dc ( n ) ** bm_r enddo ! the smallest drops become cloud ice, otherwise graupel do m = 1 , ntb_in t_adjust = max ( - 3.0_wp , min ( 3.0_wp - log10 ( nt_in ( m )), 3.0_wp )) do k = 1 , 45 texp = exp ( real ( k , kind = dp ) - real ( t_adjust , kind = dp )) - 1.0_dp do j = 1 , ntb_r1 do i = 1 , ntb_r lam_exp = ( n0r_exp ( j ) * am_r * crg ( 1 ) / r_r ( i )) ** ore1 lamr = lam_exp * ( crg ( 3 ) * org2 * org1 ) ** obmr n0_r = n0r_exp ( j ) / ( crg ( 2 ) * lam_exp ) * lamr ** cre ( 2 ) sum1 = 0._dp sum2 = 0._dp sumn1 = 0._dp sumn2 = 0._dp do n2 = nbr , 1 , - 1 n_r = n0_r * dr ( n2 ) ** mu_r * exp ( - lamr * dr ( n2 )) * dtr ( n2 ) vol = massr ( n2 ) * orho_w prob = max ( 0.0_dp , 1.0_dp - exp ( - 12 0.0_dp * vol * 5.2d-4 * texp )) !!@note !! Graupel tuning parameter: In this table, if the frozen raindrop mass is >= xm0g, !! initialization to graupel occurs. !!@endnote if ( massr ( n2 ) < xm0g ) then sumn1 = sumn1 + prob * n_r sum1 = sum1 + prob * n_r * massr ( n2 ) else sumn2 = sumn2 + prob * n_r sum2 = sum2 + prob * n_r * massr ( n2 ) endif if (( sum1 + sum2 ) >= r_r ( i )) exit enddo tpi_qrfz ( i , j , k , m ) = sum1 tni_qrfz ( i , j , k , m ) = sumn1 tpg_qrfz ( i , j , k , m ) = sum2 tnr_qrfz ( i , j , k , m ) = sumn2 enddo enddo do j = 1 , nbc nu_c = min ( 15 , nint ( nu_c_scale / t_nc ( j )) + 2 ) do i = 1 , ntb_c lamc = ( t_nc ( j ) * am_r * ccg ( 2 , nu_c ) * ocg1 ( nu_c ) / r_c ( i )) ** obmr n0_c = t_nc ( j ) * ocg1 ( nu_c ) * lamc ** cce ( 1 , nu_c ) sum1 = 0._dp sumn2 = 0._dp do n = nbc , 1 , - 1 vol = massc ( n ) * orho_w prob = max ( 0.0_dp , 1.0_dp - exp ( - 12 0.0_dp * vol * 5.2e-4_dp * texp )) n_c = n0_c * dc ( n ) ** nu_c * exp ( - lamc * dc ( n )) * dtc ( n ) sumn2 = min ( t_nc ( j ), sumn2 + prob * n_c ) sum1 = sum1 + prob * n_c * massc ( n ) if ( sum1 >= r_c ( i )) exit enddo tpi_qcfz ( i , j , k , m ) = sum1 tni_qcfz ( i , j , k , m ) = sumn2 enddo enddo enddo enddo end subroutine freezewater subroutine qi_aut_qs () !! fills data array that contain values of cloud ice conversion to snow !! and depositional growth by binning cloud ice distributions and !! determining both the size bins > d0s (that are converted to snow) and the !! depositional growth up to d0s (for cloud ice) and > d0s for snow !! following Harrington et al. (1995) use module_mp_tempo_params , only : wp , sp , dp , & nbi , ntb_i , ntb_i1 , & am_i , cie , cig , oig1 , nt_i , r_i , obmi , bm_i , mu_i , d0s , d0i , & tpi_ide , tps_iaus , tni_iaus , di , dti integer :: i , j , n2 real ( dp ), dimension ( nbi ) :: n_i real ( dp ) :: n0_i , lami , di_mean , t1 , t2 real ( wp ) :: xlimit_intg do j = 1 , ntb_i1 do i = 1 , ntb_i lami = ( am_i * cig ( 2 ) * oig1 * nt_i ( j ) / r_i ( i )) ** obmi di_mean = ( bm_i + mu_i + 1. ) / lami n0_i = nt_i ( j ) * oig1 * lami ** cie ( 1 ) t1 = 0. t2 = 0. if ( real ( di_mean , kind = wp ) > 5. * d0s ) then t1 = r_i ( i ) t2 = nt_i ( j ) tpi_ide ( i , j ) = 0. elseif ( real ( di_mean , kind = wp ) < d0i ) then t1 = 0. t2 = 0. tpi_ide ( i , j ) = 1. else xlimit_intg = lami * d0s tpi_ide ( i , j ) = real ( calc_gamma_p ( mu_i + 2.0 , xlimit_intg ), kind = dp ) do n2 = 1 , nbi n_i ( n2 ) = n0_i * di ( n2 ) ** mu_i * exp ( - lami * di ( n2 )) * dti ( n2 ) if ( di ( n2 ) >= d0s ) then t1 = t1 + n_i ( n2 ) * am_i * di ( n2 ) ** bm_i t2 = t2 + n_i ( n2 ) endif enddo endif tps_iaus ( i , j ) = t1 tni_iaus ( i , j ) = t2 enddo enddo end subroutine qi_aut_qs end module module_mp_tempo_init","tags":"","url":"sourcefile/module_mp_tempo_init.f90.html"},{"title":"module_mp_tempo_diags.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_diags.f90~~EfferentGraph sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_radar.f90 module_mp_radar.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_radar.f90 sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~module_mp_tempo_diags.f90~~AfferentGraph sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_diags.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module module_mp_tempo_diags !! utilities for tempo microphysics use module_mp_tempo_params ! only : wp, sp, dp ! use module_mp_tempo_init, only : tempo_init_cfgs use module_mp_radar implicit none private public :: calc_effectRad , calc_refl10cm , hail_size_diagnostics contains !================================================================================================================= !..Compute _radiation_ effective radii of cloud water, ice, and snow. !.. These are entirely consistent with microphysics assumptions, not !.. constant or otherwise ad hoc as is internal to most radiation !.. schemes.  Since only the smallest snowflakes should impact !.. radiation, compute from first portion of complicated Field number !.. distribution, not the second part, which is the larger sizes. subroutine calc_effectRad ( t1d , p1d , qv1d , qc1d , nc1d , qi1d , ni1d , qs1d , re_qc1d , re_qi1d , re_qs1d , kts , kte , lsml ) IMPLICIT NONE !..Sub arguments INTEGER , INTENT ( IN ) :: kts , kte REAL , DIMENSION ( kts : kte ), INTENT ( IN ) :: & & t1d , p1d , qv1d , qc1d , nc1d , qi1d , ni1d , qs1d REAL , DIMENSION ( kts : kte ), INTENT ( INOUT ) :: re_qc1d , re_qi1d , re_qs1d integer , intent ( in ), optional :: lsml !..Local variables INTEGER :: k REAL , DIMENSION ( kts : kte ) :: rho , rc , nc , ri , ni , rs REAL :: smo2 , smob , smoc REAL :: tc0 , loga_ , a_ , b_ DOUBLE PRECISION :: lamc , lami LOGICAL :: has_qc , has_qi , has_qs INTEGER :: inu_c real , dimension ( 15 ), parameter :: g_ratio = ( / 24 , 60 , 120 , 210 , 336 , 504 , 720 , 990 , 1320 , 1716 , 2184 , 2730 , 3360 , 4080 , 4896 / ) has_qc = . false . has_qi = . false . has_qs = . false . re_qc1d = 0. re_qi1d = 0. re_qs1d = 0. do k = kts , kte rho ( k ) = 0.622 * p1d ( k ) / ( R * t1d ( k ) * ( qv1d ( k ) + 0.622 )) rc ( k ) = MAX ( R1 , qc1d ( k ) * rho ( k )) nc ( k ) = MAX ( 2. , MIN ( nc1d ( k ) * rho ( k ), Nt_c_max )) if (. not . ( tempo_init_cfgs % aerosolaware_flag . or . merra2_aerosol_aware )) then nc ( k ) = Nt_c if ( present ( lsml )) then if ( lsml == 1 ) then nc ( k ) = Nt_c_l else nc ( k ) = Nt_c_o endif endif endif if ( rc ( k ). gt . R1 . and . nc ( k ). gt . R2 ) has_qc = . true . ri ( k ) = MAX ( R1 , qi1d ( k ) * rho ( k )) ni ( k ) = MAX ( R2 , ni1d ( k ) * rho ( k )) if ( ri ( k ). gt . R1 . and . ni ( k ). gt . R2 ) has_qi = . true . rs ( k ) = MAX ( R1 , qs1d ( k ) * rho ( k )) if ( rs ( k ). gt . R1 ) has_qs = . true . enddo if ( has_qc ) then do k = kts , kte if ( rc ( k ). le . R1 . or . nc ( k ). le . R2 ) CYCLE if ( nc ( k ). lt . 100 ) then inu_c = 15 elseif ( nc ( k ). gt . 1.E10 ) then inu_c = 2 else inu_c = MIN ( 15 , NINT ( 100 0.E6 / nc ( k )) + 2 ) endif lamc = ( nc ( k ) * am_r * g_ratio ( inu_c ) / rc ( k )) ** obmr re_qc1d ( k ) = MAX ( 2.51E-6 , MIN ( SNGL ( 0.5D0 * DBLE ( 3. + inu_c ) / lamc ), 5 0.E-6 )) enddo endif if ( has_qi ) then do k = kts , kte if ( ri ( k ). le . R1 . or . ni ( k ). le . R2 ) CYCLE lami = ( am_i * cig ( 2 ) * oig1 * ni ( k ) / ri ( k )) ** obmi re_qi1d ( k ) = MAX ( 2.51E-6 , MIN ( SNGL ( 0.5D0 * DBLE ( 3. + mu_i ) / lami ), 12 5.E-6 )) enddo endif if ( has_qs ) then do k = kts , kte if ( rs ( k ). le . R1 ) CYCLE tc0 = MIN ( - 0.1 , t1d ( k ) - 27 3.15 ) smob = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 = smob else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 = ( smob / a_ ) ** ( 1. / b_ ) endif !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc = a_ * smo2 ** b_ re_qs1d ( k ) = MAX ( 5.01E-6 , MIN ( 0.5 * ( smoc / smob ), 99 9.E-6 )) enddo endif end subroutine calc_effectRad !================================================================================================================= !..Compute radar reflectivity assuming 10 cm wavelength radar and using !.. Rayleigh approximation.  Only complication is melted snow/graupel !.. which we treat as water-coated ice spheres and use Uli Blahak's !.. library of routines.  The meltwater fraction is simply the amount !.. of frozen species remaining from what initially existed at the !.. melting level interface. subroutine calc_refl10cm ( qv1d , qc1d , qr1d , nr1d , qs1d , qg1d , ng1d , qb1d , & t1d , p1d , dBZ , kts , kte , ii , jj , rand1 , melti , & vt_dBZ , first_time_step ) IMPLICIT NONE !..Sub arguments INTEGER , INTENT ( IN ) :: kts , kte , ii , jj REAL , OPTIONAL , INTENT ( IN ) :: rand1 REAL , DIMENSION ( kts : kte ), INTENT ( IN ) :: & qv1d , qc1d , qr1d , nr1d , qs1d , qg1d , ng1d , qb1d , t1d , p1d REAL , DIMENSION ( kts : kte ), INTENT ( INOUT ) :: dBZ REAL , DIMENSION ( kts : kte ), OPTIONAL , INTENT ( INOUT ) :: vt_dBZ LOGICAL , OPTIONAL , INTENT ( IN ) :: first_time_step !..Local variables LOGICAL :: do_vt_dBZ LOGICAL :: allow_wet_graupel LOGICAL :: allow_wet_snow REAL , DIMENSION ( kts : kte ) :: temp , pres , qv , rho , rhof REAL , DIMENSION ( kts : kte ) :: rc , rr , nr , rs , rg , ng , rb INTEGER , DIMENSION ( kts : kte ) :: idx_bg DOUBLE PRECISION , DIMENSION ( kts : kte ) :: ilamr , ilamg , N0_r , N0_g REAL , DIMENSION ( kts : kte ) :: mvd_r REAL , DIMENSION ( kts : kte ) :: smob , smo2 , smoc , smoz REAL :: oM3 , M0 , Mrat , slam1 , slam2 , xDs REAL :: ils1 , ils2 , t1_vts , t2_vts , t3_vts , t4_vts REAL :: vtr_dbz_wt , vts_dbz_wt , vtg_dbz_wt REAL , DIMENSION ( kts : kte ) :: ze_rain , ze_snow , ze_graupel DOUBLE PRECISION :: N0_exp , N0_min , lam_exp , lamr , lamg REAL :: a_ , b_ , loga_ , tc0 , SR DOUBLE PRECISION :: fmelt_s , fmelt_g INTEGER :: i , k , k_0 , kbot , n LOGICAL , OPTIONAL , INTENT ( IN ) :: melti LOGICAL , DIMENSION ( kts : kte ) :: L_qr , L_qs , L_qg DOUBLE PRECISION :: cback , x , eta , f_d REAL :: xslw1 , ygra1 , zans1 xam_r = am_r xbm_r = bm_r xmu_r = mu_r xam_s = am_s xbm_s = bm_s xmu_s = mu_s xam_g = am_g ( idx_bg1 ) xbm_g = bm_g xmu_g = mu_g !+---+ if ( present ( vt_dBZ ) . and . present ( first_time_step )) then do_vt_dBZ = . true . if ( first_time_step ) then !           no bright banding, to be consistent with hydrometeor retrieval in GSI allow_wet_snow = . false . else allow_wet_snow = . true . endif allow_wet_graupel = . false . else do_vt_dBZ = . false . allow_wet_snow = . true . allow_wet_graupel = . false . endif do k = kts , kte dBZ ( k ) = - 3 5.0 enddo !+---+-----------------------------------------------------------------+ !..Put column of data into local arrays. !+---+-----------------------------------------------------------------+ do k = kts , kte temp ( k ) = t1d ( k ) qv ( k ) = MAX ( 1.E-10 , qv1d ( k )) pres ( k ) = p1d ( k ) rho ( k ) = 0.622 * pres ( k ) / ( R * temp ( k ) * ( qv ( k ) + 0.622 )) rhof ( k ) = SQRT ( RHO_NOT / rho ( k )) rc ( k ) = MAX ( R1 , qc1d ( k ) * rho ( k )) if ( qr1d ( k ) . gt . R1 ) then rr ( k ) = qr1d ( k ) * rho ( k ) nr ( k ) = MAX ( R2 , nr1d ( k ) * rho ( k )) lamr = ( am_r * crg ( 3 ) * org2 * nr ( k ) / rr ( k )) ** obmr ilamr ( k ) = 1. / lamr N0_r ( k ) = nr ( k ) * org2 * lamr ** cre ( 2 ) mvd_r ( k ) = ( 3.0 + mu_r + 0.672 ) * ilamr ( k ) L_qr ( k ) = . true . else rr ( k ) = R1 nr ( k ) = R1 mvd_r ( k ) = 5 0.E-6 L_qr ( k ) = . false . endif if ( qs1d ( k ) . gt . R2 ) then rs ( k ) = qs1d ( k ) * rho ( k ) L_qs ( k ) = . true . else rs ( k ) = R1 L_qs ( k ) = . false . endif if ( qg1d ( k ) . gt . R2 ) then rg ( k ) = qg1d ( k ) * rho ( k ) ng ( k ) = MAX ( R2 , ng1d ( k ) * rho ( k )) rb ( k ) = MAX ( qg1d ( k ) / rho_g ( NRHG ), qb1d ( k )) rb ( k ) = MIN ( qg1d ( k ) / rho_g ( 1 ), rb ( k )) idx_bg ( k ) = MAX ( 1 , MIN ( NINT ( qg1d ( k ) / rb ( k ) * 0.01 ) + 1 , NRHG )) if (. not . tempo_init_cfgs % hailaware_flag ) idx_bg ( k ) = idx_bg1 L_qg ( k ) = . true . else rg ( k ) = R1 ng ( k ) = R2 idx_bg ( k ) = idx_bg1 L_qg ( k ) = . false . endif enddo !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope, and useful moments for snow. !+---+-----------------------------------------------------------------+ do k = kts , kte smo2 ( k ) = 0. smob ( k ) = 0. smoc ( k ) = 0. smoz ( k ) = 0. enddo if ( ANY ( L_qs . eqv . . true .)) then do k = kts , kte if (. not . L_qs ( k )) CYCLE tc0 = MIN ( - 0.1 , temp ( k ) - 27 3.15 ) smob ( k ) = rs ( k ) * oams !..All other moments based on reference, 2nd moment.  If bm_s.ne.2, !.. then we must compute actual 2nd moment and use as reference. if ( bm_s . gt .( 2.0 - 1.e-3 ) . and . bm_s . lt .( 2.0 + 1.e-3 )) then smo2 ( k ) = smob ( k ) else loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * bm_s & & + sa ( 4 ) * tc0 * bm_s + sa ( 5 ) * tc0 * tc0 & & + sa ( 6 ) * bm_s * bm_s + sa ( 7 ) * tc0 * tc0 * bm_s & & + sa ( 8 ) * tc0 * bm_s * bm_s + sa ( 9 ) * tc0 * tc0 * tc0 & & + sa ( 10 ) * bm_s * bm_s * bm_s a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * bm_s & & + sb ( 4 ) * tc0 * bm_s + sb ( 5 ) * tc0 * tc0 & & + sb ( 6 ) * bm_s * bm_s + sb ( 7 ) * tc0 * tc0 * bm_s & & + sb ( 8 ) * tc0 * bm_s * bm_s + sb ( 9 ) * tc0 * tc0 * tc0 & & + sb ( 10 ) * bm_s * bm_s * bm_s smo2 ( k ) = ( smob ( k ) / a_ ) ** ( 1. / b_ ) endif !..Calculate bm_s+1 (th) moment.  Useful for diameter calcs. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 1 ) & & + sa ( 4 ) * tc0 * cse ( 1 ) + sa ( 5 ) * tc0 * tc0 & & + sa ( 6 ) * cse ( 1 ) * cse ( 1 ) + sa ( 7 ) * tc0 * tc0 * cse ( 1 ) & & + sa ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) + sa ( 9 ) * tc0 * tc0 * tc0 & & + sa ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 1 ) + sb ( 4 ) * tc0 * cse ( 1 ) & & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 1 ) * cse ( 1 ) & & + sb ( 7 ) * tc0 * tc0 * cse ( 1 ) + sb ( 8 ) * tc0 * cse ( 1 ) * cse ( 1 ) & & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 1 ) * cse ( 1 ) * cse ( 1 ) smoc ( k ) = a_ * smo2 ( k ) ** b_ !..Calculate bm_s*2 (th) moment.  Useful for reflectivity. loga_ = sa ( 1 ) + sa ( 2 ) * tc0 + sa ( 3 ) * cse ( 3 ) & & + sa ( 4 ) * tc0 * cse ( 3 ) + sa ( 5 ) * tc0 * tc0 & & + sa ( 6 ) * cse ( 3 ) * cse ( 3 ) + sa ( 7 ) * tc0 * tc0 * cse ( 3 ) & & + sa ( 8 ) * tc0 * cse ( 3 ) * cse ( 3 ) + sa ( 9 ) * tc0 * tc0 * tc0 & & + sa ( 10 ) * cse ( 3 ) * cse ( 3 ) * cse ( 3 ) a_ = 1 0.0 ** loga_ b_ = sb ( 1 ) + sb ( 2 ) * tc0 + sb ( 3 ) * cse ( 3 ) + sb ( 4 ) * tc0 * cse ( 3 ) & & + sb ( 5 ) * tc0 * tc0 + sb ( 6 ) * cse ( 3 ) * cse ( 3 ) & & + sb ( 7 ) * tc0 * tc0 * cse ( 3 ) + sb ( 8 ) * tc0 * cse ( 3 ) * cse ( 3 ) & & + sb ( 9 ) * tc0 * tc0 * tc0 + sb ( 10 ) * cse ( 3 ) * cse ( 3 ) * cse ( 3 ) smoz ( k ) = a_ * smo2 ( k ) ** b_ enddo endif !+---+-----------------------------------------------------------------+ !..Calculate y-intercept, slope values for graupel. !+---+-----------------------------------------------------------------+ if ( ANY ( L_qg . eqv . . true .)) then do k = kte , kts , - 1 lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng ( k ) / rg ( k )) ** obmg ilamg ( k ) = 1. / lamg N0_g ( k ) = ng ( k ) * ogg2 * lamg ** cge ( 2 , 1 ) enddo else ilamg (:) = 0. N0_g (:) = 0. endif !+---+-----------------------------------------------------------------+ !..Locate K-level of start of melting (k_0 is level above). !+---+-----------------------------------------------------------------+ k_0 = kts if ( present ( melti )) then if ( melti ) then K_LOOP : do k = kte - 1 , kts , - 1 if (( temp ( k ). gt . 27 3.15 ) . and . L_qr ( k ) & & . and . ( L_qs ( k + 1 ). or . L_qg ( k + 1 )) ) then k_0 = MAX ( k + 1 , k_0 ) EXIT K_LOOP endif enddo K_LOOP endif endif !+---+-----------------------------------------------------------------+ !..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps) !.. and non-water-coated snow and graupel when below freezing are !.. simple. Integrations of m(D)*m(D)*N(D)*dD. !+---+-----------------------------------------------------------------+ do k = kts , kte ze_rain ( k ) = 1.e-22 ze_snow ( k ) = 1.e-22 ze_graupel ( k ) = 1.e-22 if ( L_qr ( k )) ze_rain ( k ) = N0_r ( k ) * crg ( 4 ) * ilamr ( k ) ** cre ( 4 ) if ( L_qs ( k )) ze_snow ( k ) = ( 0.176 / 0.93 ) * ( 6.0 / PI ) * ( 6.0 / PI ) & & * ( am_s / 90 0.0 ) * ( am_s / 90 0.0 ) * smoz ( k ) if ( L_qg ( k )) ze_graupel ( k ) = ( 0.176 / 0.93 ) * ( 6.0 / PI ) * ( 6.0 / PI ) & & * ( am_g ( idx_bg ( k )) / 90 0.0 ) * ( am_g ( idx_bg ( k )) / 90 0.0 ) & & * N0_g ( k ) * cgg ( 4 , 1 ) * ilamg ( k ) ** cge ( 4 , 1 ) enddo !+---+-----------------------------------------------------------------+ !..Special case of melting ice (snow/graupel) particles.  Assume the !.. ice is surrounded by the liquid water.  Fraction of meltwater is !.. extremely simple based on amount found above the melting level. !.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting !.. routines). !+---+-----------------------------------------------------------------+ if ( present ( melti )) then if (. not . iiwarm . and . melti . and . k_0 . ge . 2 ) then do k = k_0 - 1 , kts , - 1 ! ..Reflectivity contributed by melting snow if ( allow_wet_snow . and . L_qs ( k ) . and . L_qs ( k_0 ) ) then SR = MAX ( 0.01 , MIN ( 1.0 - rs ( k ) / ( rs ( k ) + rr ( k )), 0.99 )) fmelt_s = DBLE ( SR * SR ) eta = 0.d0 oM3 = 1. / smoc ( k ) M0 = ( smob ( k ) * oM3 ) Mrat = smob ( k ) * M0 * M0 * M0 slam1 = M0 * Lam0 slam2 = M0 * Lam1 do n = 1 , nrbins x = am_s * xxDs ( n ) ** bm_s call rayleigh_soak_wetgraupel ( x , DBLE ( ocms ), DBLE ( obms ), & & fmelt_s , melt_outside_s , m_w_0 , m_i_0 , lamda_radar , & & CBACK , mixingrulestring_s , matrixstring_s , & & inclusionstring_s , hoststring_s , & & hostmatrixstring_s , hostinclusionstring_s ) f_d = Mrat * ( Kap0 * DEXP ( - slam1 * xxDs ( n )) & & + Kap1 * ( M0 * xxDs ( n )) ** mu_s * DEXP ( - slam2 * xxDs ( n ))) eta = eta + f_d * CBACK * simpson ( n ) * xdts ( n ) enddo ze_snow ( k ) = SNGL ( lamda4 / ( pi5 * K_w ) * eta ) endif !..Reflectivity contributed by melting graupel if ( allow_wet_graupel . and . L_qg ( k ) . and . L_qg ( k_0 ) ) then SR = MAX ( 0.01 , MIN ( 1.0 - rg ( k ) / ( rg ( k ) + rr ( k )), 0.99 )) fmelt_g = DBLE ( SR * SR ) eta = 0.d0 lamg = 1. / ilamg ( k ) do n = 1 , nrbins x = am_g ( idx_bg ( k )) * xxDg ( n ) ** bm_g call rayleigh_soak_wetgraupel ( x , DBLE ( ocmg ( idx_bg ( k ))), DBLE ( obmg ), & & fmelt_g , melt_outside_g , m_w_0 , m_i_0 , lamda_radar , & & CBACK , mixingrulestring_g , matrixstring_g , & & inclusionstring_g , hoststring_g , & & hostmatrixstring_g , hostinclusionstring_g ) f_d = N0_g ( k ) * xxDg ( n ) ** mu_g * DEXP ( - lamg * xxDg ( n )) eta = eta + f_d * CBACK * simpson ( n ) * xdtg ( n ) enddo ze_graupel ( k ) = SNGL ( lamda4 / ( pi5 * K_w ) * eta ) endif enddo endif endif do k = kte , kts , - 1 dBZ ( k ) = 1 0. * log10 (( ze_rain ( k ) + ze_snow ( k ) + ze_graupel ( k )) * 1.d18 ) enddo !..Reflectivity-weighted terminal velocity (snow, rain, graupel, mix). if ( do_vt_dBZ ) then do k = kte , kts , - 1 vt_dBZ ( k ) = 1.E-3 if ( rs ( k ). gt . R2 ) then Mrat = smob ( k ) / smoc ( k ) ils1 = 1. / ( Mrat * Lam0 + fv_s ) ils2 = 1. / ( Mrat * Lam1 + fv_s ) t1_vts = Kap0 * csg ( 5 ) * ils1 ** cse ( 5 ) t2_vts = Kap1 * Mrat ** mu_s * csg ( 11 ) * ils2 ** cse ( 11 ) ils1 = 1. / ( Mrat * Lam0 ) ils2 = 1. / ( Mrat * Lam1 ) t3_vts = Kap0 * csg ( 6 ) * ils1 ** cse ( 6 ) t4_vts = Kap1 * Mrat ** mu_s * csg ( 12 ) * ils2 ** cse ( 12 ) vts_dbz_wt = rhof ( k ) * av_s * ( t1_vts + t2_vts ) / ( t3_vts + t4_vts ) if ( temp ( k ). ge . 27 3.15 . and . temp ( k ). lt . 27 5.15 ) then vts_dbz_wt = vts_dbz_wt * 1.5 elseif ( temp ( k ). ge . 27 5.15 ) then vts_dbz_wt = vts_dbz_wt * 2.0 endif else vts_dbz_wt = 1.E-3 endif if ( rr ( k ). gt . R1 ) then lamr = 1. / ilamr ( k ) vtr_dbz_wt = rhof ( k ) * av_r * crg ( 13 ) * ( lamr + fv_r ) ** ( - cre ( 13 )) & / ( crg ( 4 ) * lamr ** ( - cre ( 4 ))) else vtr_dbz_wt = 1.E-3 endif if ( rg ( k ). gt . R2 ) then lamg = 1. / ilamg ( k ) vtg_dbz_wt = rhof ( k ) * av_g ( idx_bg ( k )) * cgg ( 5 , idx_bg ( k )) * lamg ** ( - cge ( 5 , idx_bg ( k ))) & & / ( cgg ( 4 , 1 ) * lamg ** ( - cge ( 4 , 1 ))) else vtg_dbz_wt = 1.E-3 endif ! if (rg(k).gt.R2) then !     lamg = 1./ilamg(k) !     vtg_dbz_wt = rhof(k)*av_g*cgg(5)*lamg**(-cge(5))               & !         / (cgg(4)*lamg**(-cge(4))) ! else !     vtg_dbz_wt = 1.E-3 ! endif vt_dBZ ( k ) = ( vts_dbz_wt * ze_snow ( k ) + vtr_dbz_wt * ze_rain ( k ) & + vtg_dbz_wt * ze_graupel ( k )) & / ( ze_rain ( k ) + ze_snow ( k ) + ze_graupel ( k )) enddo endif end subroutine calc_refl10cm !================================================================================================================= !..Compute max hail size aloft and at the ground (both 2D fields) subroutine hail_size_diagnostics ( kts , kte , qg1d , ng1d , qb1d , t1d , p1d , qv1d , qg_max_diam1d ) implicit none integer , intent ( in ) :: kts , kte real ( wp ), dimension ( kts : kte ), intent ( in ) :: qg1d , ng1d , qb1d , t1d , p1d , qv1d real ( wp ), dimension ( kts : kte ), intent ( out ) :: qg_max_diam1d ! local variables real ( wp ), dimension ( kts : kte ) :: rho , rg , ng , rb integer , dimension ( kts : kte ) :: idx_bg real ( dp ) :: lamg , N0_g , f_d , sum_nh , sum_t , hail_max integer :: k , n integer , parameter :: nhbins = 50 real ( dp ), dimension ( nhbins ) :: hbins , dhbins real ( dp ), parameter :: lowbin = 50 0.e-6 real ( dp ), parameter :: highbin = 0.075 real ( dp ), parameter :: threshold_conc = 0.0005 ! Binned number distribution method call create_bins ( numbins = nhbins , lowbin = lowbin , highbin = highbin , bins = hbins , deltabins = dhbins ) do k = kts , kte qg_max_diam1d ( k ) = 0. if ( qg1d ( k ) >= 1.e-6 ) then rho ( k ) = 0.622 * p1d ( k ) / ( R * t1d ( k ) * ( qv1d ( k ) + 0.622 )) rg ( k ) = qg1d ( k ) * rho ( k ) ng ( k ) = max ( R2 , ng1d ( k ) * rho ( k )) rb ( k ) = max ( qg1d ( k ) / rho_g ( nrhg ), qb1d ( k )) rb ( k ) = min ( qg1d ( k ) / rho_g ( 1 ), rb ( k )) idx_bg ( k ) = max ( 1 , min ( nint ( qg1d ( k ) / rb ( k ) * 0.01 ) + 1 , nrhg )) if (. not . tempo_init_cfgs % hailaware_flag ) idx_bg ( k ) = idx_bg1 if ( rho_g ( idx_bg ( k )) < 35 0. ) cycle lamg = ( am_g ( idx_bg ( k )) * cgg ( 3 , 1 ) * ogg2 * ng ( k ) / rg ( k )) ** obmg N0_g = ng ( k ) * ogg2 * lamg ** cge ( 2 , 1 ) sum_nh = 0. sum_t = 0. do n = nhbins , 1 , - 1 f_d = N0_g * hbins ( n ) ** mu_g * exp ( - lamg * hbins ( n )) * dhbins ( n ) sum_nh = sum_nh + f_d if ( sum_nh > threshold_conc ) exit sum_t = sum_nh enddo if ( n >= nhbins ) then hail_max = hbins ( nhbins ) elseif ( hbins ( n + 1 ) . gt . 1.e-3 ) then hail_max = hbins ( n ) - ( sum_nh - threshold_conc ) / ( sum_nh - sum_t ) * ( hbins ( n ) - hbins ( n + 1 )) else hail_max = 1.e-4 endif qg_max_diam1d ( k ) = 100 0. * hail_max ! convert to mm endif enddo end subroutine hail_size_diagnostics end module module_mp_tempo_diags","tags":"","url":"sourcefile/module_mp_tempo_diags.f90.html"},{"title":"module_mp_tempo_params.F90 – TEMPO Microphysics","text":"This file depends on sourcefile~~module_mp_tempo_params.f90~~EfferentGraph sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~machine.f90 machine.F90 sourcefile~module_mp_tempo_params.f90->sourcefile~machine.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~module_mp_tempo_params.f90~~AfferentGraph sourcefile~module_mp_tempo_params.f90 module_mp_tempo_params.F90 sourcefile~module_mp_tempo_diags.f90 module_mp_tempo_diags.F90 sourcefile~module_mp_tempo_diags.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_driver.f90 module_mp_tempo_driver.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_diags.f90 sourcefile~module_mp_tempo_main.f90 module_mp_tempo_main.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_main.f90 sourcefile~module_mp_tempo_ml.f90 module_mp_tempo_ml.F90 sourcefile~module_mp_tempo_driver.f90->sourcefile~module_mp_tempo_ml.f90 sourcefile~module_mp_tempo_init.f90 module_mp_tempo_init.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90 module_mp_tempo_utils.F90 sourcefile~module_mp_tempo_init.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_main.f90->sourcefile~module_mp_tempo_utils.f90 sourcefile~module_mp_tempo_ml.f90->sourcefile~module_mp_tempo_params.f90 sourcefile~module_mp_tempo_utils.f90->sourcefile~module_mp_tempo_params.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module module_mp_tempo_params !! parameters and variables used in tempo microphysics ! define machine precision #if defined(mpas) use mpas_kind_types , only : wp => RKIND , sp => R4KIND , dp => R8KIND #elif defined(ccpp) use machine , only : wp => kind_phys , sp => kind_sngl_prec , dp => kind_dbl_prec #else use machine , only : wp => kind_phys , sp => kind_sngl_prec , dp => kind_dbl_prec #endif use iso_fortran_env , only : real32 , real64 ! for machine independent lookup table precisions implicit none public character ( len = 11 ) :: tempo_version !! tempo version string (max is xxx.xxx.xxx) ! tempo configuration flags for init type :: ty_tempo_init_cfgs logical :: aerosolaware_flag = . true . !! flag to run aerosol-aware microphysics logical :: hailaware_flag = . true . !! flag to run hail-aware microphysics logical :: restart_flag = . false . !! flag for restart or DA cycling character ( len = 4 ) :: model_flag !! flag for model end type ! tempo configuration flags for the driver type :: ty_tempo_driver_cfgs logical :: semi_sedi = . false . !! flag for semi-lagrangian sedimentation end type ! tempo lookup table filenames type :: ty_tempo_table_cfgs character ( len = 100 ) :: ccn_table_name = 'ccn_activate.bin' !! ccn table name character ( len = 100 ) :: qrqg_table_name = 'qr_acr_qg_data_tempo_v3' !! rain-graupel collection table name character ( len = 100 ) :: qrqs_table_name = 'qr_acr_qs_data_tempo_v3' !! rain-snow collection table name character ( len = 100 ) :: freezewater_table_name = 'freeze_water_data_tempo_v3' !! freeze water collection table name end type ! tempo configurations type ( ty_tempo_init_cfgs ) :: tempo_init_cfgs type ( ty_tempo_driver_cfgs ) :: tempo_driver_cfgs type ( ty_tempo_table_cfgs ) :: tempo_table_cfgs ! parameters that can be changed ------------------------------------------------------------------------ integer , parameter :: idx_bg1 = 6 !! index from rho_g when hail_aware = false: density = 500 kg\\, m&#94;{-3} real ( wp ), parameter :: av_r = 485 4._wp !! rain fallspeed power-law coefficient real ( wp ), parameter :: bv_r = 1.0_wp !! rain fallspeed power-law coefficient !! @note !! fallspeed power law relations are !!  v =(a_{v}D&#94;{b_{v}})\\exp\\left(-f_{v}D\\right), \\textrm{where}\\,fv = 0\\, \\textrm{for graupel/ice}  !! and coefficients are from from Ferrier (1994) for rain and !! Thompson et al. (2008) for ice, snow, and graupel !! @endnote real ( wp ), parameter :: av_s = 4 0._wp !! snow fallspeed power-law coefficient real ( wp ), parameter :: bv_s = 0.55_wp !! snow fallspeed power-law coefficient real ( wp ), parameter :: fv_s = 10 0._wp !! snow fallspeed power-law coefficient real ( wp ), parameter :: bv_c = 2.0_wp !! cloud fallspeed power-law coefficient real ( wp ), parameter :: bv_i = 1.0_wp !! ice fallspeed power-law coefficient real ( wp ), parameter :: av_g_old = 44 2._wp !! graupel fallspeed power-law coefficient (hail_aware = false) real ( wp ), parameter :: bv_g_old = 0.89_wp !! graupel fallspeed power-law coefficient (hail_aware = false) real ( wp ), parameter :: am_s = 0.069_wp !! snow mass power-law coefficient real ( wp ), parameter :: bm_s = 2.0_wp !! snow mass power-law coefficient !! @note !! mass power law relations are !!  m = a_{m}D&#94;{b_{m}}  !! and coefficients for snow are from Field et al. (2005) and !! others assume a spherical form !! @endnote real ( wp ), parameter :: bm_g = 3.0_wp !! graupel mass power-law coefficient real ( wp ), parameter :: bm_i = 3.0_wp !! ice mass power-law coefficient real ( wp ), parameter :: bm_r = 3.0_wp !! rain mass power-law coefficient real ( wp ), parameter :: rho_i = 89 0._wp !! density of cloud ice [kg\\, m&#94;{-3}] real ( wp ), parameter :: xm0i = 1.e-12_wp !! ice initiates with this mass [kg] real ( wp ), parameter :: d0c = 1.e-6_wp !! minimum diameter of cloud droplets [m] real ( wp ), parameter :: d0r = 5 0.e-6_wp !! minimum diameter of raindrops [m] real ( wp ), parameter :: d0s = 30 0.e-6_wp !! minimum diameter of snow [m] real ( wp ), parameter :: d0g = 35 0.e-6_wp !! minimum diameter of graupel [m] real ( wp ), parameter :: c_cube = 0.5_wp !! capacitance of a sphere \\left(D&#94;{3}\\right) real ( wp ), parameter :: c_sqrd = 0.15_wp !! capacitance of plates/aggregates \\left(D&#94;{2}\\right) real ( wp ), parameter :: mu_r = 0.0_wp !! shape parameter for rain real ( wp ), parameter :: mu_s = 0.6357_wp !! shape parameter for snow real ( wp ), parameter :: mu_g = 0.0_wp !! shape parameter for graupel real ( wp ), parameter :: mu_i = 0.0_wp !! shape parameter for cloud ice !! @note !! generalized gamma distributions for rain, graupel and cloud ice have the form !!  n\\left(D\\right) = n_{0} D&#94;{\\mu}\\exp(-\\lambda D)  !!  \\textrm{where}\\\\ \\mu = 0 \\\\ \\textrm{is exponential}  !! @endnote real ( wp ), parameter :: nu_c_scale = 100 0.e6_wp !! scaling parameter for nu_c integer , parameter :: nu_c_max = 15 !! maximum value for nu_c integer , parameter :: nu_c_min = 2 !! minimum value for nu_c ! parameters that should NOT be changed ----------------------------------------------------------------- integer , parameter :: table_sp = real32 !! precision for lookup tables (machine independent) integer , parameter :: table_dp = real64 !! precision for lookup tables (machine independent) integer , parameter :: nrhg = 9 !! graupel density array size when hail_aware = true integer , parameter :: nrhg1 = 1 !! graupel density array size when hail_aware = false real ( wp ), parameter :: rho_w = 100 0._wp !! density of liquid water [kg\\, m&#94;{-3}] real ( wp ), dimension ( nrhg ), parameter :: rho_g = [ 5 0._wp , 10 0._wp , 20 0._wp , 30 0._wp , 40 0._wp , & 50 0._wp , 60 0._wp , 70 0._wp , 80 0._wp ] !! !! densities of graupel when hail_aware = true [kg\\, m&#94;{-3}] real ( wp ), parameter :: sc = 0.632_wp !! schmidt number ! these can be overwritten by a host model and don't have a parameter attribute real ( wp ) :: pi = 3.1415926536_wp !! pi is approximately 355/113 real ( wp ) :: lsub = 2.834e6_wp !! enthalpy of sublimation [J\\, kg&#94;{-1}] real ( wp ) :: lvap0 = 2.5e6_wp !! enthalpy of vaporization [J\\, kg&#94;{-1}] real ( wp ) :: rv = 46 1.5_wp !! gas constant for water vapor [J\\, K&#94;{-1}\\, kg&#94;{-1}] real ( wp ) :: r = 28 7.04_wp !! gas constant for dry air [J\\, K&#94;{-1}\\, kg&#94;{-1}] ! lookup table dimensions integer , parameter :: nbins = 100 !! lookup table dimension (number of bins) integer , parameter :: nbc = nbins !! lookup table dimension for cloud water integer , parameter :: nbr = nbins !! lookup table dimension for rain integer , parameter :: nbs = nbins !! lookup table dimension for snow integer , parameter :: nbi = nbins !! lookup table dimension integer , parameter :: nbg = nbins !! lookup table dimension integer , parameter :: ntb_i = 64 !! lookup table dimension for cloud ice integer , parameter :: ntb_i1 = 55 !! lookup table dimension for cloud ice integer , parameter :: ntb_c = 37 !! lookup table dimension for cloud water integer , parameter :: ntb_t = 9 !! lookup table dimension for temperature integer , parameter :: ntb_g1 = 37 !! lookup table dimension for graupel integer , parameter :: ntb_s = 37 !! lookup table dimension for snow integer , parameter :: ntb_g = 37 !! lookup table dimension for graupel integer , parameter :: ntb_r = 37 !! lookup table dimension for rain integer , parameter :: ntb_r1 = 37 !! lookup table dimension for rain integer , parameter :: ntb_t1 = 45 !! lookup table dimension for temperature integer , parameter :: ntb_in = 55 !! lookup table dimension for IN integer , parameter :: ntb_arc = 7 !! lookup table dimension for CCN activation integer , parameter :: ntb_arw = 9 !! lookup table dimension for CCN activation integer , parameter :: ntb_art = 7 !! lookup table dimension for CCN activation integer , parameter :: ntb_arr = 5 !! lookup table dimension for CCN activation integer , parameter :: ntb_ark = 4 !! lookup table dimension for CCN activation ! lookup table data real ( wp ), dimension ( ntb_c ), parameter :: & r_c = [ 1.e-6_wp , 2.e-6_wp , 3.e-6_wp , 4.e-6_wp , 5.e-6_wp , 6.e-6_wp , 7.e-6_wp , 8.e-6_wp , 9.e-6_wp , & 1.e-5_wp , 2.e-5_wp , 3.e-5_wp , 4.e-5_wp , 5.e-5_wp , 6.e-5_wp , 7.e-5_wp , 8.e-5_wp , 9.e-5_wp , & 1.e-4_wp , 2.e-4_wp , 3.e-4_wp , 4.e-4_wp , 5.e-4_wp , 6.e-4_wp , 7.e-4_wp , 8.e-4_wp , 9.e-4_wp , & 1.e-3_wp , 2.e-3_wp , 3.e-3_wp , 4.e-3_wp , 5.e-3_wp , 6.e-3_wp , 7.e-3_wp , 8.e-3_wp , 9.e-3_wp , & 1.e-2_wp ] !! mass bins for cloud water [kg\\, m&#94;{-3}] real ( wp ), dimension ( ntb_i ), parameter :: & r_i = [ 1.e-10_wp , 2.e-10_wp , 3.e-10_wp , 4.e-10_wp , & 5.e-10_wp , 6.e-10_wp , 7.e-10_wp , 8.e-10_wp , 9.e-10_wp , & 1.e-9_wp , 2.e-9_wp , 3.e-9_wp , 4.e-9_wp , 5.e-9_wp , 6.e-9_wp , 7.e-9_wp , 8.e-9_wp , 9.e-9_wp , & 1.e-8_wp , 2.e-8_wp , 3.e-8_wp , 4.e-8_wp , 5.e-8_wp , 6.e-8_wp , 7.e-8_wp , 8.e-8_wp , 9.e-8_wp , & 1.e-7_wp , 2.e-7_wp , 3.e-7_wp , 4.e-7_wp , 5.e-7_wp , 6.e-7_wp , 7.e-7_wp , 8.e-7_wp , 9.e-7_wp , & 1.e-6_wp , 2.e-6_wp , 3.e-6_wp , 4.e-6_wp , 5.e-6_wp , 6.e-6_wp , 7.e-6_wp , 8.e-6_wp , 9.e-6_wp , & 1.e-5_wp , 2.e-5_wp , 3.e-5_wp , 4.e-5_wp , 5.e-5_wp , 6.e-5_wp , 7.e-5_wp , 8.e-5_wp , 9.e-5_wp , & 1.e-4_wp , 2.e-4_wp , 3.e-4_wp , 4.e-4_wp , 5.e-4_wp , 6.e-4_wp , 7.e-4_wp , 8.e-4_wp , 9.e-4_wp , & 1.e-3_wp ] !! mass bins for ice water [kg\\, m&#94;{-3}] real ( wp ), dimension ( ntb_r ), parameter :: & r_r = [ 1.e-6_wp , 2.e-6_wp , 3.e-6_wp , 4.e-6_wp , 5.e-6_wp , 6.e-6_wp , 7.e-6_wp , 8.e-6_wp , 9.e-6_wp , & 1.e-5_wp , 2.e-5_wp , 3.e-5_wp , 4.e-5_wp , 5.e-5_wp , 6.e-5_wp , 7.e-5_wp , 8.e-5_wp , 9.e-5_wp , & 1.e-4_wp , 2.e-4_wp , 3.e-4_wp , 4.e-4_wp , 5.e-4_wp , 6.e-4_wp , 7.e-4_wp , 8.e-4_wp , 9.e-4_wp , & 1.e-3_wp , 2.e-3_wp , 3.e-3_wp , 4.e-3_wp , 5.e-3_wp , 6.e-3_wp , 7.e-3_wp , 8.e-3_wp , 9.e-3_wp , & 1.e-2_wp ] !! mass bins for rain [kg\\, m&#94;{-3}] real ( wp ), dimension ( ntb_s ), parameter :: & r_s = [ 1.e-6_wp , 2.e-6_wp , 3.e-6_wp , 4.e-6_wp , 5.e-6_wp , 6.e-6_wp , 7.e-6_wp , 8.e-6_wp , 9.e-6_wp , & 1.e-5_wp , 2.e-5_wp , 3.e-5_wp , 4.e-5_wp , 5.e-5_wp , 6.e-5_wp , 7.e-5_wp , 8.e-5_wp , 9.e-5_wp , & 1.e-4_wp , 2.e-4_wp , 3.e-4_wp , 4.e-4_wp , 5.e-4_wp , 6.e-4_wp , 7.e-4_wp , 8.e-4_wp , 9.e-4_wp , & 1.e-3_wp , 2.e-3_wp , 3.e-3_wp , 4.e-3_wp , 5.e-3_wp , 6.e-3_wp , 7.e-3_wp , 8.e-3_wp , 9.e-3_wp , & 1.e-2_wp ] !! mass bins for snow [kg\\, m&#94;{-3}] real ( wp ), dimension ( ntb_g ), parameter :: & r_g = [ 1.e-6_wp , 2.e-6_wp , 3.e-6_wp , 4.e-6_wp , 5.e-6_wp , 6.e-6_wp , 7.e-6_wp , 8.e-6_wp , 9.e-6_wp , & 1.e-5_wp , 2.e-5_wp , 3.e-5_wp , 4.e-5_wp , 5.e-5_wp , 6.e-5_wp , 7.e-5_wp , 8.e-5_wp , 9.e-5_wp , & 1.e-4_wp , 2.e-4_wp , 3.e-4_wp , 4.e-4_wp , 5.e-4_wp , 6.e-4_wp , 7.e-4_wp , 8.e-4_wp , 9.e-4_wp , & 1.e-3_wp , 2.e-3_wp , 3.e-3_wp , 4.e-3_wp , 5.e-3_wp , 6.e-3_wp , 7.e-3_wp , 8.e-3_wp , 9.e-3_wp , & 1.e-2_wp ] !! mass bins for graupel [kg\\, m&#94;{-3}] real ( wp ), dimension ( ntb_r1 ), parameter :: & n0r_exp = [ 1.e6_wp , 2.e6_wp , 3.e6_wp , 4.e6_wp , 5.e6_wp , 6.e6_wp , 7.e6_wp , 8.e6_wp , 9.e6_wp , & 1.e7_wp , 2.e7_wp , 3.e7_wp , 4.e7_wp , 5.e7_wp , 6.e7_wp , 7.e7_wp , 8.e7_wp , 9.e7_wp , & 1.e8_wp , 2.e8_wp , 3.e8_wp , 4.e8_wp , 5.e8_wp , 6.e8_wp , 7.e8_wp , 8.e8_wp , 9.e8_wp , & 1.e9_wp , 2.e9_wp , 3.e9_wp , 4.e9_wp , 5.e9_wp , 6.e9_wp , 7.e9_wp , 8.e9_wp , 9.e9_wp , & 1.e10_wp ] !! y-intercept bins for rain [m&#94;{-4}] real ( wp ), dimension ( ntb_g1 ), parameter :: & n0g_exp = [ 1.e2_wp , 2.e2_wp , 3.e2_wp , 4.e2_wp , 5.e2_wp , 6.e2_wp , 7.e2_wp , 8.e2_wp , 9.e2_wp , & 1.e3_wp , 2.e3_wp , 3.e3_wp , 4.e3_wp , 5.e3_wp , 6.e3_wp , 7.e3_wp , 8.e3_wp , 9.e3_wp , & 1.e4_wp , 2.e4_wp , 3.e4_wp , 4.e4_wp , 5.e4_wp , 6.e4_wp , 7.e4_wp , 8.e4_wp , 9.e4_wp , & 1.e5_wp , 2.e5_wp , 3.e5_wp , 4.e5_wp , 5.e5_wp , 6.e5_wp , 7.e5_wp , 8.e5_wp , 9.e5_wp , & 1.e6_wp ] !! y-intercept bins for graupel [m&#94;{-4}] real ( wp ), dimension ( ntb_i1 ), parameter :: & nt_i = [ 1.0_wp , 2.0_wp , 3.0_wp , 4.0_wp , 5.0_wp , 6.0_wp , 7.0_wp , 8.0_wp , 9.0_wp , & 1.e1_wp , 2.e1_wp , 3.e1_wp , 4.e1_wp , 5.e1_wp , 6.e1_wp , 7.e1_wp , 8.e1_wp , 9.e1_wp , & 1.e2_wp , 2.e2_wp , 3.e2_wp , 4.e2_wp , 5.e2_wp , 6.e2_wp , 7.e2_wp , 8.e2_wp , 9.e2_wp , & 1.e3_wp , 2.e3_wp , 3.e3_wp , 4.e3_wp , 5.e3_wp , 6.e3_wp , 7.e3_wp , 8.e3_wp , 9.e3_wp , & 1.e4_wp , 2.e4_wp , 3.e4_wp , 4.e4_wp , 5.e4_wp , 6.e4_wp , 7.e4_wp , 8.e4_wp , 9.e4_wp , & 1.e5_wp , 2.e5_wp , 3.e5_wp , 4.e5_wp , 5.e5_wp , 6.e5_wp , 7.e5_wp , 8.e5_wp , 9.e5_wp , & 1.e6_wp ] !! number bins for ice [m&#94;{-3}] real ( wp ), dimension ( ntb_in ), parameter :: & nt_in = [ 1.0_wp , 2.0_wp , 3.0_wp , 4.0_wp , 5.0_wp , 6.0_wp , 7.0_wp , 8.0_wp , 9.0_wp , & 1.e1_wp , 2.e1_wp , 3.e1_wp , 4.e1_wp , 5.e1_wp , 6.e1_wp , 7.e1_wp , 8.e1_wp , 9.e1_wp , & 1.e2_wp , 2.e2_wp , 3.e2_wp , 4.e2_wp , 5.e2_wp , 6.e2_wp , 7.e2_wp , 8.e2_wp , 9.e2_wp , & 1.e3_wp , 2.e3_wp , 3.e3_wp , 4.e3_wp , 5.e3_wp , 6.e3_wp , 7.e3_wp , 8.e3_wp , 9.e3_wp , & 1.e4_wp , 2.e4_wp , 3.e4_wp , 4.e4_wp , 5.e4_wp , 6.e4_wp , 7.e4_wp , 8.e4_wp , 9.e4_wp , & 1.e5_wp , 2.e5_wp , 3.e5_wp , 4.e5_wp , 5.e5_wp , 6.e5_wp , 7.e5_wp , 8.e5_wp , 9.e5_wp , & 1.e6_wp ] !! number bins for IN concentration from 0.001-1000\\, L&#94;{-1} [m&#94;{-3}] ! variables --------------------------------------------------------------------------------------------- integer :: dim_nrhg !! number of dimensions for graupel density real ( wp ), dimension ( nrhg ) :: av_g = [ 4 5.9173813_wp , 6 7.0867386_wp , 9 8.0158463_wp , & 12 2.353378_wp , 14 3.204224_wp , 16 1.794724_wp , & 17 8.762115_wp , 19 4.488785_wp , 20 9.225876_wp ] !! graupel fallspeed power-law coefficients (hail_aware = true) real ( wp ), dimension ( nrhg ) :: bv_g = [ 0.640961647_wp , 0.640961647_wp , 0.640961647_wp , & 0.640961647_wp , 0.640961647_wp , 0.640961647_wp , & 0.640961647_wp , 0.640961647_wp , 0.640961647_wp ] !! graupel fallspeed power-law coefficients (hail_aware = true) !! @note !! av_g and bv_g values from A. Heymsfield: Best - Reynolds relationship !! @endnote real ( wp ) :: am_i !! ice mass-diameter power-law coefficient real ( wp ) :: am_r !! rain mass-diameter power-law coefficient real ( wp ), dimension ( nrhg ) :: am_g !! graupel mass-diameter power-law coefficient real ( wp ) :: lfus !! enthalpy of fusion [J\\, kg&#94;{-1}] real ( wp ) :: olfus !! 1 / lfus [kg\\, J&#94;{-1}] real ( wp ) :: orv !! 1 / rv [K\\, kg\\, J&#94;{-1}] real ( wp ) :: sc3 !! schmidt number to the 1/3 power real ( wp ) :: d0i !! minimum diameter of cloud ice [m] real ( wp ) :: xm0s !! minimum mass of snow [kg] real ( wp ) :: xm0g !! minimum mass of graupel [kg] real ( wp ) :: obmi !! 1 / bm_i real ( wp ) :: obmr !! 1 / bm_r real ( wp ) :: oams !! 1 / am_s real ( wp ) :: obms !! 1 / bm_s real ( wp ) :: ocms !! oams &#94; obms real ( wp ), dimension ( nrhg ) :: oamg !! 1 / am_g real ( wp ), dimension ( nrhg ) :: ocmg !! oamg &#94; obmg real ( wp ) :: obmg !! 1 / bm_g ! various gamma calculations used throughout tempo real ( wp ), dimension ( 5 , 15 ) :: cce , ccg !! for ccg = \\Gamma(x), cce is x for cloud water real ( wp ), dimension ( 15 ) :: ocg1 , ocg2 !! inverse of specific ccg values real ( wp ), dimension ( 7 ) :: cie , cig !! for cig = \\Gamma(x), cie is x for cloud ice real ( wp ) :: oig1 , oig2 !! inverse of specific cig values real ( wp ), dimension ( 13 ) :: cre , crg !! for crg = \\Gamma(x), cre is x for rain real ( wp ) :: ore1 , org1 , org2 , org3 !! inverse of specific cre and crg values real ( wp ), dimension ( 17 ) :: cse , csg !! for csg = \\Gamma(x), cse is x for snow real ( wp ), dimension ( 12 , nrhg ) :: cge , cgg !! for cgg = \\Gamma(x), cge is x for graupel real ( wp ) :: oge1 , ogg1 , ogg2 , ogg3 !! inverse of specific cge and cgg values ! precomputed constants in various rate equations real ( wp ) :: t1_qr_qc , t1_qr_qi , t2_qr_qi !! terms for rain collecting cloud water and cloud ice equations real ( wp ) :: t1_qs_qc , t1_qs_qi !! terms for snow collecting cloud water and cloud ice equations real ( wp ) :: t1_qr_ev , t2_qr_ev !! terms for rain evaporation equation real ( wp ) :: t1_qs_sd , t2_qs_sd !! terms for deposition/sublimation of snow equation real ( wp ) :: t1_qs_me , t2_qs_me !! terms for melting snow equation real ( wp ) :: t1_qg_sd !! term for deposition/sublimation of graupel equation real ( wp ) :: t1_qg_me !! term for melting graupel equation integer :: nic2 , nii2 , nii3 , nir2 , nir3 , nis2 , nig2 , nig3 , niin2 !! lookup table indexes integer :: nic1 !! used for cloud droplet number concentration lookup table !! @bug !! nic1 should be real(dp) !! @endbug real ( dp ), dimension ( nbc ) :: dc , dtc !! diameter and bin space for cloud water bins [m] real ( dp ), dimension ( nbi ) :: di , dti !! diameter and bin space for ice bins [m] real ( dp ), dimension ( nbr ) :: dr , dtr !! diameter and bin space for rain bins [m] real ( dp ), dimension ( nbs ) :: ds , dts !! diameter and bin space for snow bins [m] real ( dp ), dimension ( nbg ) :: dg , dtg !! diameter and bin space for graupel bins [m] real ( dp ), dimension ( nbc ) :: t_nc !! cloud droplet number concentration bins [cm&#94;{-3}] ! lookup table data real ( dp ), allocatable , dimension (:,:) :: t_efrw , t_efsw !! collection efficiency data arrays real ( dp ), allocatable , dimension (:,:,:) :: tpc_wev , tnc_wev !! evaporation data arrays real ( table_sp ), allocatable , dimension (:,:,:,:,:) :: tnccn_act !! cloud condensation nuclei data arrays real ( table_dp ), allocatable , dimension (:,:,:,:,:) :: tcg_racg , tmr_racg , tcr_gacr , & tnr_racg , tnr_gacr !! rain-graupel collection data arrays real ( table_dp ), allocatable , dimension (:,:,:,:) :: tcs_racs1 , tmr_racs1 , tcs_racs2 , & tmr_racs2 , tcr_sacr1 , tms_sacr1 , tcr_sacr2 , tms_sacr2 , & tnr_racs1 , tnr_racs2 , tnr_sacr1 , tnr_sacr2 !! rain-snow collection data arrays real ( table_dp ), allocatable , dimension (:,:,:,:) :: tpi_qcfz , tni_qcfz !! cloud droplet freezing data arrays real ( table_dp ), allocatable , dimension (:,:,:,:) :: tpi_qrfz , tpg_qrfz , tni_qrfz , tnr_qrfz !! rain freezing data arrays real ( table_dp ), allocatable , dimension (:,:) :: tps_iaus , tni_iaus , tpi_ide !! cloud ice depositional growth and conversion to snow data arrays !================================================================================================================= ! HERE STARTS OLD TEMPO PARAMS FILE CONTENT !================================================================================================================= real ( wp ) :: RoverRv = 0.622 real ( wp ) :: Cp2 = 100 4.0 ! AAJ change to Cp2 ! ====================================================================== ! Minimum microphys values ! R1 value, 1.e-12, cannot be set lower because of numerical ! problems with Paul Field's moments and should not be set larger ! because of truncation problems in snow/ice growth. real ( wp ), parameter :: R1 = 1.e-12 real ( wp ), parameter :: R2 = 1.e-6 real ( wp ), parameter :: eps = 1.e-15 !    logical :: is_aerosol_aware = .true. logical :: merra2_aerosol_aware = . false . logical :: sedi_semi = . false . ! Hail-aware microphysics options integer :: dimNRHG ! Densities of rain, graupel, and cloud ice. real ( wp ), parameter :: rho_w2 = 100 0.0 ! Change to rho_w2 to solve MPAS same var name conflict real ( wp ) :: t1_qg_qc , t2_qg_sd , t2_qg_me !================================================================================================================= ! Parameters needed by the microphysics driver ! Prescribed number of cloud droplets.  Set according to known data or ! roughly 100 per cc (100.e6 m&#94;-3) for Maritime cases and ! 300 per cc (300.e6 m&#94;-3) for Continental.  Gamma shape parameter, ! mu_c, calculated based on Nt_c is important in autoconversion ! scheme.  In 2-moment cloud water, Nt_c represents a maximum of ! droplet concentration and nu_c is also variable depending on local ! droplet number concentration. real ( wp ), parameter :: Nt_c_o = 5 0.e6 real ( wp ), parameter :: Nt_c_l = 10 0.e6 real ( wp ), parameter :: Nt_c_max = 199 9.e6 real ( wp ) :: Nt_c , mu_c real ( wp ) :: mu_c_o , mu_c_l real ( wp ) :: min_qv = 1.e-10 #if defined(ccpp_default) real ( wp ), parameter :: demott_nuc_ssati = 0.15 ! 0.15 for CCPP #else real ( wp ), parameter :: demott_nuc_ssati = 0.25 #endif ! Declaration of constants for assumed CCN/IN aerosols when none in ! the input data.  Look inside the init routine for modifications ! due to surface land-sea points or vegetation characteristics. real ( wp ), parameter :: nwfa_default = 1 1.1e6 real ( wp ), parameter :: naIN1 = 0.5e6 real ( wp ), parameter :: nifa_default = naIN1 * 0.01 real ( wp ), parameter :: aero_max = 999 9.e6 real ( dp ), parameter :: max_ni = 499 9.e3 real ( wp ), parameter :: icenuc_max = 100 0.e3 real ( wp ), parameter :: rime_threshold = 2.0 ! For MPAS real ( wp ), parameter :: rime_conversion = 0.95 ! For MPAS real ( wp ), parameter :: fv_r = 19 5.0 real ( wp ) :: rho_s2 = 10 0.0 ! AAJ change to rho_s2 to solve MPAS same var name conflict real ( wp ), parameter :: av_c = 0.316946e8 logical , parameter :: iiwarm = . false . logical , parameter :: dustyIce = . true . logical , parameter :: homogIce = . true . integer , parameter :: IFDRY = 0 real ( wp ) :: T_0 = 27 3.15 real ( wp ), parameter :: naIN0 = 1.5e6 real ( wp ), parameter :: naCCN0 = 30 0.0e6 real ( wp ), parameter :: naCCN1 = 5 0.0e6 ! Sum of two gamma distrib for snow (Field et al. 2005). ! N(D) = M2**4/M3**3 * [Kap0*exp(-M2*Lam0*D/M3) !      + Kap1*(M2/M3)**mu_s * D**mu_s * exp(-M2*Lam1*D/M3)] ! M2 and M3 are the (bm_s)th and (bm_s+1)th moments respectively ! calculated as function of ice water content and temperature. real ( wp ), parameter :: Kap0 = 49 0.6 real ( wp ), parameter :: Kap1 = 1 7.46 real ( wp ), parameter :: Lam0 = 2 0.78 real ( wp ), parameter :: Lam1 = 3.29 ! Y-intercept parameter for graupel is not constant and depends on ! mixing ratio.  Also, when mu_g is non-zero, these become equiv ! y-intercept for an exponential distrib and proper values are ! computed based on same mixing ratio and total number concentration. real ( dp ), parameter :: gonv_min = 1.e2 real ( dp ), parameter :: gonv_max = 1.e6 real ( wp ), parameter :: a_coeff = 0.47244157 real ( wp ), parameter :: b_coeff = 0.54698726 #if defined(ccpp_default) real ( wp ) :: av_i #else real ( wp ), parameter :: av_i = 149 3.9 #endif ! Collection efficiencies.  Rain/snow/graupel collection of cloud ! droplets use variables (Ef_rw, Ef_sw, Ef_gw respectively) and ! get computed elsewhere because they are dependent on stokes ! number. real ( wp ), parameter :: Ef_si = 0.05 real ( wp ), parameter :: Ef_rs = 0.95 real ( wp ), parameter :: Ef_rg = 0.75 real ( wp ), parameter :: Ef_ri = 0.95 ! Constants in Cooper curve relation for cloud ice number. real ( wp ), parameter :: TNO = 5.0 real ( wp ), parameter :: ATO = 0.304 ! Rho_not used in fallspeed relations (rho_not/rho)**.5 adjustment. real ( wp ), parameter :: rho_not = 10132 5.0 / ( 28 7.05 * 29 8.0 ) ! Homogeneous freezing temperature real ( wp ), parameter :: HGFR = 23 5.16 real ( wp ) :: R_uni = 8.314 ! J (mol K)-1 real ( dp ) :: k_b = 1.38065e-23 ! Boltzmann constant [J/K] real ( dp ) :: M_w = 1 8.01528e-3 ! molecular mass of water [kg/mol] real ( dp ) :: M_a = 2 8.96e-3 ! molecular mass of air [kg/mol] real ( dp ) :: N_avo = 6.022e23 ! Avogadro number [1/mol] real ( dp ) :: ma_w ! mass of water molecule [kg] (= M_w / N_avo, set in mp_tempo_params_init) real ( wp ) :: ar_volume ! assume radius of 0.025 micrometer, 2.5e-6 cm (= 4.0 / 3.0 * PI * (2.5e-6)**3, set in mp_tempo_params_init) ! Aerosol table parameter: Number of available aerosols, vertical ! velocity, temperature, aerosol mean radius, and hygroscopicity. real ( wp ), dimension ( ntb_arc ), parameter :: & ta_Na = ( / 1 0.0 , 3 1.6 , 10 0.0 , 31 6.0 , 100 0.0 , 316 0.0 , 1000 0.0 / ) real ( wp ), dimension ( ntb_arw ), parameter :: & ta_Ww = ( / 0.01 , 0.0316 , 0.1 , 0.316 , 1.0 , 3.16 , 1 0.0 , 3 1.6 , 10 0.0 / ) real ( wp ), dimension ( ntb_art ), parameter :: & ta_Tk = ( / 24 3.15 , 25 3.15 , 26 3.15 , 27 3.15 , 28 3.15 , 29 3.15 , 30 3.15 / ) real ( wp ), dimension ( ntb_arr ), parameter :: & ta_Ra = ( / 0.01 , 0.02 , 0.04 , 0.08 , 0.16 / ) real ( wp ), dimension ( ntb_ark ), parameter :: & ta_Ka = ( / 0.2 , 0.4 , 0.6 , 0.8 / ) ! For snow moments conversions (from Field et al. 2005) real ( wp ), dimension ( 10 ), parameter :: & sa = ( / 5.065339 , - 0.062659 , - 3.032362 , 0.029469 , - 0.000285 , & 0.31255 , 0.000204 , 0.003199 , 0.0 , - 0.015952 / ) real ( wp ), dimension ( 10 ), parameter :: & sb = ( / 0.476221 , - 0.015896 , 0.165977 , 0.007468 , - 0.000141 , & 0.060366 , 0.000079 , 0.000594 , 0.0 , - 0.003577 / ) ! Temperatures (5 C interval 0 to -40) used in lookup tables. real ( wp ), dimension ( ntb_t ), parameter :: & Tc = ( /- 0.01 , - 5. , - 1 0. , - 1 5. , - 2 0. , - 2 5. , - 3 0. , - 3 5. , - 4 0. / ) #if defined(ccpp_default) ! To permit possible creation of new lookup tables as variables expand/change, ! specify a name of external file(s) including version number for pre-computed ! Thompson tables. character ( len =* ), parameter :: thomp_table_file = 'thompson_tables_precomp_v2.sl' character ( len =* ), parameter :: qr_acr_qg_file = 'MP_TEMPO_QRacrQG.dat' character ( len =* ), parameter :: qr_acr_qg_hailaware_file = 'MP_TEMPO_HAILAWARE_QRacrQG.dat' character ( len =* ), parameter :: qr_acr_qs_file = 'MP_TEMPO_QRacrQS.dat' character ( len =* ), parameter :: freeze_h2o_file = 'MP_TEMPO_freezeH2O.dat' ! Min and max radiative effective radius of cloud water, cloud ice, and snow; ! performed by subroutine calc_effectRad. On purpose, these should stay PUBLIC. real ( wp ), parameter :: re_qc_min = 2.50e-6 ! 2.5 microns real ( wp ), parameter :: re_qc_max = 5 0.0e-6 ! 50 microns real ( wp ), parameter :: re_qi_min = 2.50e-6 ! 2.5 microns real ( wp ), parameter :: re_qi_max = 12 5.0e-6 ! 125 microns real ( wp ), parameter :: re_qs_min = 5.00e-6 ! 5 microns real ( wp ), parameter :: re_qs_max = 99 9.0e-6 ! 999 microns (1 mm) ! MPI communicator ! type(MPI_Comm) :: mpi_communicator ! Write tables with master MPI task after computing them in tempo_init logical :: thompson_table_writer #endif ! ML data integer , parameter :: nc_ml_input = 7 integer , parameter :: nc_ml_nodes = 24 integer , parameter :: nc_ml_output = 1 integer , parameter :: nr_ml_input = 7 integer , parameter :: nr_ml_nodes = 24 integer , parameter :: nr_ml_output = 1 real ( wp ), dimension ( nc_ml_input ), parameter :: & nc_ml_trans_mean = ( / 0.000191556196486247 , 3.58145042772654e-05 , & 3.12611085359273e-07 , 5.74303078738579e-05 , 8419 1.2092225319 , & 27 9.070551773565 , 0.123679354084004 / ) real ( wp ), dimension ( nc_ml_input ), parameter :: & nc_ml_trans_var = ( / 5.78143564171777e-08 , 3.22834309750552e-08 , & 6.45745893307455e-11 , 4.16625579383794e-08 , 21569463 1.771185 , & 9 4.6576255386858 , 0.384841247662964 / ) real ( wp ), dimension ( nc_ml_input * nc_ml_nodes ), parameter :: & nc_ml_w00 = ( /- 2.006957 , - 0.2812008 , - 0.339073 , 1.596426 , 2.395225 , 1.76315 , & - 0.0626798 , 1.267002 , - 0.02234177 , - 6.522605e-33 , 0.4792154 , - 0.1253034 , & - 3.217191 , - 3.092887 , - 0.0863651 , 1.071625 , 0.09741028 , 0.2255831 , & - 0.6929023 , - 0.02693799 , - 3.432344e-33 , - 0.8791879 , - 0.9359049 , 1.083484 , & - 0.07909214 , - 0.0122418 , - 0.02815927 , 0.1676407 , 0.08252326 , 0.6697816 , & - 0.4019359 , 0.4687141 , 0.001813132 , - 9.792186e-33 , 0.0409322 , 0.0113192 , & - 0.01354596 , 0.00307771 , - 0.4635534 , 0.03835761 , - 0.1015553 , 0.7316446 , & - 0.05791711 , - 0.0002690362 , - 7.920147e-33 , - 0.1216918 , - 0.3190572 , 0.09809405 , & - 0.16476 , - 0.03387314 , 0.005422261 , 0.04043967 , 0.03901243 , 0.07444729 , & 0.01954299 , 0.06918761 , 0.04823543 , - 8.637957e-33 , 0.06371575 , - 0.09250915 , & - 1.109653 , - 1.373999 , - 0.2412623 , - 0.04482195 , 0.1584691 , 0.06353725 , & 0.0006248798 , 0.04593191 , - 8.878673e-33 , - 0.4988684 , 0.01110262 , 0.04623203 , & 0.006581791 , 0.03536217 , - 0.1890567 , - 0.08839592 , 0.1327181 , 0.03478973 , & - 0.1565902 , - 0.100401 , - 0.1179777 , - 8.879818e-33 , - 0.1383738 , 0.02847495 , & - 0.005902881 , 0.005615512 , - 0.6308192 , - 0.02431803 , - 0.141971 , - 0.3490018 , & - 0.9850957 , - 0.1449479 , - 8.059166e-33 , - 0.1186465 , - 1.165381 , 0.069015 , & 0.003388841 , - 0.04041302 , 0.1638467 , 0.1147008 , - 0.04833491 , - 0.07755993 , & - 0.5137688 , 0.04546477 , 0.04101883 , 6.752353e-33 , 0.3541977 , 0.04880851 , & - 0.00102834 , - 0.01280629 , - 0.1116254 , - 0.02204754 , 0.07100908 , 0.2354002 , & 0.07129629 , 0.2489657 , 8.080785e-33 , - 0.03449865 , 0.06037927 , - 0.02023619 , & 0.7779589 , 0.04680278 , 0.7492616 , 0.6545208 , - 1.09497 , - 1.176524 , & - 0.451585 , 0.881124 , - 0.4551499 , - 8.708624e-33 , 1.006558 , - 0.04979523 , & - 0.0006915367 , - 0.002993054 , 0.01654614 , - 0.07141764 , - 0.2216591 , 0.8637336 , & 0.8358089 , - 0.7576646 , 8.186339e-33 , 0.1161914 , 0.7121871 , - 1.146734 , & 0.03925339 , 0.9975697 , - 0.06953461 , - 0.07598846 , - 0.06418022 , - 0.01897495 , & - 0.03612464 , - 0.06703389 , - 0.103049 , 9.364858e-33 , - 0.03949085 , 1.005938 , & 0.0001625419 , - 0.01027657 , 0.03823901 , 0.3197246 , - 0.1160718 , 0.04449431 , & 0.009831783 , 0.6551342 , - 8.470687e-33 , 0.1374123 , - 0.01782138 , 0.01719949 / ) real ( wp ), dimension ( nc_ml_nodes ), parameter :: & nc_ml_w01 = ( /- 4.045869 , 0.558111 , - 1.567351 , - 1.64972 , 2.748608 , & - 1.909901 , 0.3955558 , 1.507247 , 0.3599722 , - 0.0001173223 , - 0.9398569 , & - 0.6867028 , - 6 1.72853 , - 6 3.13766 , 1.165811 , - 0.6848684 , 0.1931683 , & 1.1208 , 2.63087 , 0.740169 , - 2 1.62499 , 1.545568 , 3.575141 , - 1.299604 / ) real ( wp ), dimension ( nc_ml_nodes ), parameter :: & nc_ml_b00 = ( /- 0.9842531 , 0.3064759 , - 0.4500185 , 1.28336 , 1.384105 , 0.528031 , & 0.8453538 , 1.579872 , 2.245679 , - 0.008679952 , 0.4549862 , - 0.136581 , & - 2.576741 , - 2.483647 , - 0.2089484 , 0.7607977 , 1.847745 , 0.7316047 , & - 0.287945 , 2.227298 , - 2.314714 , - 0.2561245 , - 0.6993448 , - 0.1359731 / ) real ( wp ), dimension ( nc_ml_output ), parameter :: & nc_ml_b01 = ( / 1.572826 / ) ! ------------------------------------------------------------------------------------------------------- ! ------------------------------------------------------------------------------------------------------- contains subroutine initialize_graupel_vars ( hail_flag ) !! initialize graupel variables based on hail-aware configuration flag logical , intent ( in ) :: hail_flag if ( hail_flag ) then dim_nrhg = nrhg else av_g ( idx_bg1 ) = av_g_old bv_g ( idx_bg1 ) = bv_g_old dim_nrhg = nrhg1 endif end subroutine initialize_graupel_vars subroutine initialize_parameters () !! initialize tempo parameters and variables integer :: m , n ! pi could be set by a host model, thus these parameters need to be calculated here am_i = pi * rho_i / 6.0_wp am_r = pi * rho_w / 6.0_wp am_g = [ pi * rho_g ( 1 ) / 6.0_wp , & pi * rho_g ( 2 ) / 6.0_wp , & pi * rho_g ( 3 ) / 6.0_wp , & pi * rho_g ( 4 ) / 6.0_wp , & pi * rho_g ( 5 ) / 6.0_wp , & pi * rho_g ( 6 ) / 6.0_wp , & pi * rho_g ( 7 ) / 6.0_wp , & pi * rho_g ( 8 ) / 6.0_wp , & pi * rho_g ( 9 ) / 6.0_wp ] ! av_i = av_s * D0s ** (bv_s - bv_i) lfus = lsub - lvap0 olfus = 1.0_wp / lfus orv = 1.0_wp / rv ! Schmidt number to one-third used numerous times sc3 = sc ** ( 1.0_wp / 3.0_wp ) ! compute minimum ice diameter from mass and minimum snow/graupel mass from diameter d0i = ( xm0i / am_i ) ** ( 1.0_wp / bm_i ) ! pre-compute various constants used in the microphysics equations xm0s = am_s * d0s ** bm_s xm0g = am_g ( nrhg ) * d0g ** bm_g obmi = 1.0_wp / bm_i obmr = 1.0_wp / bm_r oams = 1.0_wp / am_s obms = 1.0_wp / bm_s ocms = oams ** obms obmg = 1.0_wp / bm_g do m = 1 , nrhg oamg ( m ) = 1.0_wp / am_g ( m ) ocmg ( m ) = oamg ( m ) ** obmg enddo ! gamma functions for cloud water do n = 1 , 15 cce ( 1 , n ) = n + 1._wp cce ( 2 , n ) = bm_r + n + 1._wp cce ( 3 , n ) = bm_r + n + 4._wp cce ( 4 , n ) = n + bv_c + 1._wp cce ( 5 , n ) = bm_r + n + bv_c + 1._wp ccg ( 1 , n ) = gamma ( cce ( 1 , n )) ccg ( 2 , n ) = gamma ( cce ( 2 , n )) ccg ( 3 , n ) = gamma ( cce ( 3 , n )) ccg ( 4 , n ) = gamma ( cce ( 4 , n )) ccg ( 5 , n ) = gamma ( cce ( 5 , n )) ocg1 ( n ) = 1.0_wp / ccg ( 1 , n ) ocg2 ( n ) = 1.0_wp / ccg ( 2 , n ) enddo ! gamma functions for cloud ice cie ( 1 ) = mu_i + 1._wp cie ( 2 ) = bm_i + mu_i + 1._wp cie ( 3 ) = bm_i + mu_i + bv_i + 1._wp cie ( 4 ) = mu_i + bv_i + 1._wp cie ( 5 ) = mu_i + 2._wp cie ( 6 ) = bm_i * 0.5_wp + mu_i + bv_i + 1._wp cie ( 7 ) = bm_i * 0.5_wp + mu_i + 1._wp cig ( 1 ) = gamma ( cie ( 1 )) cig ( 2 ) = gamma ( cie ( 2 )) cig ( 3 ) = gamma ( cie ( 3 )) cig ( 4 ) = gamma ( cie ( 4 )) cig ( 5 ) = gamma ( cie ( 5 )) cig ( 6 ) = gamma ( cie ( 6 )) cig ( 7 ) = gamma ( cie ( 7 )) oig1 = 1.0_wp / cig ( 1 ) oig2 = 1.0_wp / cig ( 2 ) ! gamma functions for rain cre ( 1 ) = bm_r + 1._wp cre ( 2 ) = mu_r + 1._wp cre ( 3 ) = bm_r + mu_r + 1._wp cre ( 4 ) = bm_r * 2._wp + mu_r + 1._wp cre ( 5 ) = mu_r + bv_r + 1._wp cre ( 6 ) = bm_r + mu_r + bv_r + 1._wp cre ( 7 ) = bm_r * 0.5_wp + mu_r + bv_r + 1._wp cre ( 8 ) = bm_r + mu_r + bv_r + 3._wp cre ( 9 ) = mu_r + bv_r + 3._wp cre ( 10 ) = mu_r + 2._wp cre ( 11 ) = 0.5_wp * ( bv_r + 5._wp + 2._wp * mu_r ) cre ( 12 ) = bm_r * 0.5_wp + mu_r + 1._wp cre ( 13 ) = bm_r * 2._wp + mu_r + bv_r + 1._wp do n = 1 , 13 crg ( n ) = gamma ( cre ( n )) enddo ore1 = 1.0_wp / cre ( 1 ) org1 = 1.0_wp / crg ( 1 ) org2 = 1.0_wp / crg ( 2 ) org3 = 1.0_wp / crg ( 3 ) ! gamma functions for snow cse ( 1 ) = bm_s + 1._wp cse ( 2 ) = bm_s + 2._wp cse ( 3 ) = bm_s * 2._wp cse ( 4 ) = bm_s + bv_s + 1._wp cse ( 5 ) = bm_s * 2._wp + bv_s + 1._wp cse ( 6 ) = bm_s * 2._wp + 1._wp cse ( 7 ) = bm_s + mu_s + 1._wp cse ( 8 ) = bm_s + mu_s + 2._wp cse ( 9 ) = bm_s + mu_s + 3._wp cse ( 10 ) = bm_s + mu_s + bv_s + 1._wp cse ( 11 ) = bm_s * 2._wp + mu_s + bv_s + 1._wp cse ( 12 ) = bm_s * 2._wp + mu_s + 1._wp cse ( 13 ) = bv_s + 2._wp cse ( 14 ) = bm_s + bv_s cse ( 15 ) = mu_s + 1._wp cse ( 16 ) = 1.0_wp + ( 1.0_wp + bv_s ) / 2._wp cse ( 17 ) = bm_s + bv_s + 2._wp do n = 1 , 17 csg ( n ) = gamma ( cse ( n )) enddo ! gamma functions for graupel cge ( 1 ,:) = bm_g + 1._wp cge ( 2 ,:) = mu_g + 1._wp cge ( 3 ,:) = bm_g + mu_g + 1._wp cge ( 4 ,:) = bm_g * 2. + mu_g + 1._wp cge ( 10 ,:) = mu_g + 2._wp cge ( 12 ,:) = bm_g * 0.5_wp + mu_g + 1._wp do m = 1 , nrhg cge ( 5 , m ) = bm_g * 2._wp + mu_g + bv_g ( m ) + 1._wp cge ( 6 , m ) = bm_g + mu_g + bv_g ( m ) + 1._wp cge ( 7 , m ) = bm_g * 0.5_wp + mu_g + bv_g ( m ) + 1._wp cge ( 8 , m ) = mu_g + bv_g ( m ) + 1._wp cge ( 9 , m ) = mu_g + bv_g ( m ) + 3._wp cge ( 11 , m ) = 0.5_wp * ( bv_g ( m ) + 5._wp + 2._wp * mu_g ) enddo do m = 1 , nrhg do n = 1 , 12 cgg ( n , m ) = gamma ( cge ( n , m )) enddo enddo oge1 = 1.0_wp / cge ( 1 , 1 ) ogg1 = 1.0_wp / cgg ( 1 , 1 ) ogg2 = 1.0_wp / cgg ( 2 , 1 ) ogg3 = 1.0_wp / cgg ( 3 , 1 ) ! rain collecting cloud water and cloud ice t1_qr_qc = pi * 0.25_wp * av_r * crg ( 9 ) t1_qr_qi = pi * 0.25_wp * av_r * crg ( 9 ) t2_qr_qi = pi * 0.25_wp * am_r * av_r * crg ( 8 ) ! snow collecting cloud water and cloud ice t1_qs_qc = pi * 0.25_wp * av_s t1_qs_qi = pi * 0.25_wp * av_s ! evaporation of rain; ignore depositional growth of rain. t1_qr_ev = 0.78_wp * crg ( 10 ) t2_qr_ev = 0.308_wp * sc3 * sqrt ( av_r ) * crg ( 11 ) ! sublimation/depositional growth of snow t1_qs_sd = 0.86_wp t2_qs_sd = 0.28_wp * sc3 * sqrt ( av_s ) ! melting of snow t1_qs_me = pi * 4._wp * c_sqrd * olfus * 0.86_wp t2_qs_me = pi * 4._wp * c_sqrd * olfus * 0.28_wp * sc3 * sqrt ( av_s ) ! sublimation/depositional growth of graupel t1_qg_sd = 0.86_wp * cgg ( 10 , 1 ) ! melting of graupel t1_qg_me = pi * 4._wp * c_cube * olfus * 0.86_wp * cgg ( 10 , 1 ) end subroutine initialize_parameters subroutine initialize_bins_for_tables () !! initialize log-spaced bins of hydrometer quantities used for lookup tables integer :: n ! constants for helping find lookup table indexes. nic2 = nint ( log10 ( r_c ( 1 ))) nii2 = nint ( log10 ( r_i ( 1 ))) nir2 = nint ( log10 ( r_r ( 1 ))) nis2 = nint ( log10 ( r_s ( 1 ))) nig2 = nint ( log10 ( r_g ( 1 ))) nii3 = nint ( log10 ( nt_i ( 1 ))) nir3 = nint ( log10 ( n0r_exp ( 1 ))) nig3 = nint ( log10 ( n0g_exp ( 1 ))) niin2 = nint ( log10 ( nt_in ( 1 ))) ! bins of cloud water (from minimum diameter to 100 microns). dc ( 1 ) = real ( d0c , kind = dp ) dtc ( 1 ) = real ( d0c , kind = dp ) do n = 2 , nbc dc ( n ) = dc ( n - 1 ) + 1.0e-6_dp dtc ( n ) = ( dc ( n ) - dc ( n - 1 )) enddo ! bins of cloud ice (from min diameter up to 2x min snow size). call create_bins ( numbins = nbi , lowbin = real ( d0i , kind = dp ), & highbin = 2.0_dp * d0s , bins = di , deltabins = dti ) ! bins of rain (from min diameter up to 5 mm). call create_bins ( numbins = nbr , lowbin = real ( d0r , kind = dp ), & highbin = 0.005_dp , bins = dr , deltabins = dtr ) ! bins of snow (from min diameter up to 2 cm). call create_bins ( numbins = nbs , lowbin = real ( d0s , kind = dp ), & highbin = 0.02_dp , bins = ds , deltabins = dts ) ! bins of graupel (from min diameter up to 5 cm). call create_bins ( numbins = nbg , lowbin = real ( d0g , kind = dp ), & highbin = 0.05_dp , bins = dg , deltabins = dtg ) ! bins of cloud droplet number concentration (1 to 3000 per cc). call create_bins ( numbins = nbc , lowbin = 1.0_dp , & highbin = 300 0.0_dp , bins = t_nc ) t_nc = t_nc * 1.0e6_dp nic1 = real ( log ( t_nc ( nbc ) / t_nc ( 1 )), kind = dp ) end subroutine initialize_bins_for_tables subroutine create_bins ( numbins , lowbin , highbin , bins , deltabins ) !! calculates log-spaced bins of hydrometer sizes to simplify calculations later integer , intent ( in ) :: numbins real ( dp ), intent ( in ) :: lowbin , highbin real ( dp ), dimension (:), intent ( out ) :: bins real ( dp ), dimension (:), intent ( out ), optional :: deltabins integer :: n real ( dp ), dimension ( numbins + 1 ) :: xdx xdx ( 1 ) = lowbin xdx ( numbins + 1 ) = highbin do n = 2 , numbins xdx ( n ) = exp ( real ( n - 1 , kind = dp ) / real ( numbins , kind = dp ) * log ( xdx ( numbins + 1 ) / xdx ( 1 )) + log ( xdx ( 1 ))) enddo do n = 1 , numbins bins ( n ) = sqrt ( xdx ( n ) * xdx ( n + 1 )) enddo if ( present ( deltabins )) then do n = 1 , numbins deltabins ( n ) = xdx ( n + 1 ) - xdx ( n ) enddo endif end subroutine create_bins subroutine initialize_arrays_freezewater ( table_size ) !! initialize data arrays for Bigg (1953) freezing of cloud water and rain integer , intent ( out ), optional :: table_size ! Cloud water freezing if (. not . allocated ( tpi_qcfz )) allocate ( tpi_qcfz ( ntb_c , nbc , ntb_t1 , ntb_in ), source = 0._table_dp ) if (. not . allocated ( tni_qcfz )) allocate ( tni_qcfz ( ntb_c , nbc , ntb_t1 , ntb_in ), source = 0._table_dp ) ! Rain freezing if (. not . allocated ( tpi_qrfz )) allocate ( tpi_qrfz ( ntb_r , ntb_r1 , ntb_t1 , ntb_in ), source = 0._table_dp ) if (. not . allocated ( tpg_qrfz )) allocate ( tpg_qrfz ( ntb_r , ntb_r1 , ntb_t1 , ntb_in ), source = 0._table_dp ) if (. not . allocated ( tni_qrfz )) allocate ( tni_qrfz ( ntb_r , ntb_r1 , ntb_t1 , ntb_in ), source = 0._table_dp ) if (. not . allocated ( tnr_qrfz )) allocate ( tnr_qrfz ( ntb_r , ntb_r1 , ntb_t1 , ntb_in ), source = 0._table_dp ) ! Table size is precision * entries * dimensions + 8 bytes (sp + sp) per entry for start and end markers if ( present ( table_size )) then table_size = ( table_dp * 2 * ( ntb_c * nbc * ntb_t1 * ntb_in )) + & ( table_dp * 4 * ( ntb_r * ntb_r1 * ntb_t1 * ntb_in )) + ( table_sp + table_sp ) * 6 endif end subroutine initialize_arrays_freezewater subroutine initialize_arrays_qr_acr_qs ( table_size ) !! initialize data arrays for rain-snow collection integer , intent ( out ), optional :: table_size if (. not . allocated ( tcs_racs1 )) allocate ( tcs_racs1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tmr_racs1 )) allocate ( tmr_racs1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tcs_racs2 )) allocate ( tcs_racs2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tmr_racs2 )) allocate ( tmr_racs2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tcr_sacr1 )) allocate ( tcr_sacr1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tms_sacr1 )) allocate ( tms_sacr1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tcr_sacr2 )) allocate ( tcr_sacr2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tms_sacr2 )) allocate ( tms_sacr2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_racs1 )) allocate ( tnr_racs1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_racs2 )) allocate ( tnr_racs2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_sacr1 )) allocate ( tnr_sacr1 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_sacr2 )) allocate ( tnr_sacr2 ( ntb_s , ntb_t , ntb_r1 , ntb_r ), source = 0._table_dp ) ! Table size is precision * entries * dimensions + 8 bytes (sp + sp) per entry for start and end markers if ( present ( table_size )) then table_size = table_dp * 12 * ( ntb_s * ntb_t * ntb_r1 * ntb_r ) + ( table_sp + table_sp ) * 12 endif end subroutine initialize_arrays_qr_acr_qs subroutine initialize_arrays_qr_acr_qg ( table_size ) !! initialize data arrays for rain-graupel collection integer , intent ( out ), optional :: table_size ! Rain-graupel if (. not . allocated ( tcg_racg )) allocate ( tcg_racg ( ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tmr_racg )) allocate ( tmr_racg ( ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tcr_gacr )) allocate ( tcr_gacr ( ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_racg )) allocate ( tnr_racg ( ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r ), source = 0._table_dp ) if (. not . allocated ( tnr_gacr )) allocate ( tnr_gacr ( ntb_g1 , ntb_g , nrhg , ntb_r1 , ntb_r ), source = 0._table_dp ) ! Table size is precision * entries * dimensions + 8 bytes (sp + sp) per entry for start and end markers if ( present ( table_size )) then table_size = table_dp * 5 * ( ntb_g1 * ntb_g * nrhg * ntb_r1 * ntb_r ) + ( table_sp + table_sp ) * 5 endif end subroutine initialize_arrays_qr_acr_qg subroutine initialize_arrays_ccn ( table_size ) !! initialize data arrays for ccn lookup table integer , intent ( out ), optional :: table_size if (. not . allocated ( tnccn_act )) & allocate ( tnccn_act ( ntb_arc , ntb_arw , ntb_art , ntb_arr , ntb_ark ), source = 0._table_sp ) ! Table size is precision * entries * dimensions + 8 bytes (sp + sp) per entry for start and end markers if ( present ( table_size )) then table_size = table_sp * 1 * ( ntb_arc * ntb_arw * ntb_art * ntb_arr * ntb_ark ) + ( table_sp + table_sp ) * 1 endif end subroutine initialize_arrays_ccn subroutine initialize_arrays_drop_evap () !! initialize data arrays for drop evaporation data if (. not . allocated ( tpc_wev )) allocate ( tpc_wev ( nbc , ntb_c , nbc ), source = 0._dp ) if (. not . allocated ( tnc_wev )) allocate ( tnc_wev ( nbc , ntb_c , nbc ), source = 0._dp ) end subroutine initialize_arrays_drop_evap subroutine initialize_array_efsw () !! initializes the collision efficiency data array for snow collecting cloud water if (. not . allocated ( t_efsw )) allocate ( t_efsw ( nbs , nbc ), source = 0._dp ) end subroutine initialize_array_efsw subroutine initialize_array_efrw () !! initializes the collision efficiency data array for rain collecting cloud water if (. not . allocated ( t_efrw )) allocate ( t_efrw ( nbr , nbc ), source = 0._dp ) end subroutine initialize_array_efrw subroutine initialize_arrays_qi_aut_qs () !! initializes data arrays for cloud ice to snow conversion and growth if (. not . allocated ( tps_iaus )) allocate ( tps_iaus ( ntb_i , ntb_i1 ), source = 0._dp ) if (. not . allocated ( tni_iaus )) allocate ( tni_iaus ( ntb_i , ntb_i1 ), source = 0._dp ) if (. not . allocated ( tpi_ide )) allocate ( tpi_ide ( ntb_i , ntb_i1 ), source = 0._dp ) end subroutine initialize_arrays_qi_aut_qs end module module_mp_tempo_params","tags":"","url":"sourcefile/module_mp_tempo_params.f90.html"}]}